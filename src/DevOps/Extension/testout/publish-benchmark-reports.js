/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/azure-pipelines-task-lib sync recursive":
/*!*****************************************************!*\
  !*** ./node_modules/azure-pipelines-task-lib/ sync ***!
  \*****************************************************/
/***/ ((module) => {

eval("function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = \"./node_modules/azure-pipelines-task-lib sync recursive\";\nmodule.exports = webpackEmptyContext;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\azure-pipelines-task-lib%7Csync");

/***/ }),

/***/ "./node_modules/@nodelib/fs.scandir/out/adapters/fs.js":
/*!*************************************************************!*\
  !*** ./node_modules/@nodelib/fs.scandir/out/adapters/fs.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nexports.FILE_SYSTEM_ADAPTER = {\n  lstat: fs.lstat,\n  stat: fs.stat,\n  lstatSync: fs.lstatSync,\n  statSync: fs.statSync,\n  readdir: fs.readdir,\n  readdirSync: fs.readdirSync\n};\nfunction createFileSystemAdapter(fsMethods) {\n  if (fsMethods === undefined) {\n    return exports.FILE_SYSTEM_ADAPTER;\n  }\n  return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);\n}\nexports.createFileSystemAdapter = createFileSystemAdapter;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\@nodelib\\fs.scandir\\out\\adapters\\fs.js");

/***/ }),

/***/ "./node_modules/@nodelib/fs.scandir/out/constants.js":
/*!***********************************************************!*\
  !*** ./node_modules/@nodelib/fs.scandir/out/constants.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;\nconst NODE_PROCESS_VERSION_PARTS = process.versions.node.split('.');\nif (NODE_PROCESS_VERSION_PARTS[0] === undefined || NODE_PROCESS_VERSION_PARTS[1] === undefined) {\n  throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);\n}\nconst MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);\nconst MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);\nconst SUPPORTED_MAJOR_VERSION = 10;\nconst SUPPORTED_MINOR_VERSION = 10;\nconst IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;\nconst IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;\n/**\n * IS `true` for Node.js 10.10 and greater.\n */\nexports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\@nodelib\\fs.scandir\\out\\constants.js");

/***/ }),

/***/ "./node_modules/@nodelib/fs.scandir/out/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@nodelib/fs.scandir/out/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.Settings = exports.scandirSync = exports.scandir = void 0;\nconst async = __webpack_require__(/*! ./providers/async */ \"./node_modules/@nodelib/fs.scandir/out/providers/async.js\");\nconst sync = __webpack_require__(/*! ./providers/sync */ \"./node_modules/@nodelib/fs.scandir/out/providers/sync.js\");\nconst settings_1 = __webpack_require__(/*! ./settings */ \"./node_modules/@nodelib/fs.scandir/out/settings.js\");\nexports.Settings = settings_1.default;\nfunction scandir(path, optionsOrSettingsOrCallback, callback) {\n  if (typeof optionsOrSettingsOrCallback === 'function') {\n    async.read(path, getSettings(), optionsOrSettingsOrCallback);\n    return;\n  }\n  async.read(path, getSettings(optionsOrSettingsOrCallback), callback);\n}\nexports.scandir = scandir;\nfunction scandirSync(path, optionsOrSettings) {\n  const settings = getSettings(optionsOrSettings);\n  return sync.read(path, settings);\n}\nexports.scandirSync = scandirSync;\nfunction getSettings(settingsOrOptions = {}) {\n  if (settingsOrOptions instanceof settings_1.default) {\n    return settingsOrOptions;\n  }\n  return new settings_1.default(settingsOrOptions);\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\@nodelib\\fs.scandir\\out\\index.js");

/***/ }),

/***/ "./node_modules/@nodelib/fs.scandir/out/providers/async.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@nodelib/fs.scandir/out/providers/async.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.readdir = exports.readdirWithFileTypes = exports.read = void 0;\nconst fsStat = __webpack_require__(/*! @nodelib/fs.stat */ \"./node_modules/@nodelib/fs.stat/out/index.js\");\nconst rpl = __webpack_require__(/*! run-parallel */ \"./node_modules/run-parallel/index.js\");\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./node_modules/@nodelib/fs.scandir/out/constants.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"./node_modules/@nodelib/fs.scandir/out/utils/index.js\");\nconst common = __webpack_require__(/*! ./common */ \"./node_modules/@nodelib/fs.scandir/out/providers/common.js\");\nfunction read(directory, settings, callback) {\n  if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {\n    readdirWithFileTypes(directory, settings, callback);\n    return;\n  }\n  readdir(directory, settings, callback);\n}\nexports.read = read;\nfunction readdirWithFileTypes(directory, settings, callback) {\n  settings.fs.readdir(directory, {\n    withFileTypes: true\n  }, (readdirError, dirents) => {\n    if (readdirError !== null) {\n      callFailureCallback(callback, readdirError);\n      return;\n    }\n    const entries = dirents.map(dirent => ({\n      dirent,\n      name: dirent.name,\n      path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)\n    }));\n    if (!settings.followSymbolicLinks) {\n      callSuccessCallback(callback, entries);\n      return;\n    }\n    const tasks = entries.map(entry => makeRplTaskEntry(entry, settings));\n    rpl(tasks, (rplError, rplEntries) => {\n      if (rplError !== null) {\n        callFailureCallback(callback, rplError);\n        return;\n      }\n      callSuccessCallback(callback, rplEntries);\n    });\n  });\n}\nexports.readdirWithFileTypes = readdirWithFileTypes;\nfunction makeRplTaskEntry(entry, settings) {\n  return done => {\n    if (!entry.dirent.isSymbolicLink()) {\n      done(null, entry);\n      return;\n    }\n    settings.fs.stat(entry.path, (statError, stats) => {\n      if (statError !== null) {\n        if (settings.throwErrorOnBrokenSymbolicLink) {\n          done(statError);\n          return;\n        }\n        done(null, entry);\n        return;\n      }\n      entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);\n      done(null, entry);\n    });\n  };\n}\nfunction readdir(directory, settings, callback) {\n  settings.fs.readdir(directory, (readdirError, names) => {\n    if (readdirError !== null) {\n      callFailureCallback(callback, readdirError);\n      return;\n    }\n    const tasks = names.map(name => {\n      const path = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);\n      return done => {\n        fsStat.stat(path, settings.fsStatSettings, (error, stats) => {\n          if (error !== null) {\n            done(error);\n            return;\n          }\n          const entry = {\n            name,\n            path,\n            dirent: utils.fs.createDirentFromStats(name, stats)\n          };\n          if (settings.stats) {\n            entry.stats = stats;\n          }\n          done(null, entry);\n        });\n      };\n    });\n    rpl(tasks, (rplError, entries) => {\n      if (rplError !== null) {\n        callFailureCallback(callback, rplError);\n        return;\n      }\n      callSuccessCallback(callback, entries);\n    });\n  });\n}\nexports.readdir = readdir;\nfunction callFailureCallback(callback, error) {\n  callback(error);\n}\nfunction callSuccessCallback(callback, result) {\n  callback(null, result);\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\@nodelib\\fs.scandir\\out\\providers\\async.js");

/***/ }),

/***/ "./node_modules/@nodelib/fs.scandir/out/providers/common.js":
/*!******************************************************************!*\
  !*** ./node_modules/@nodelib/fs.scandir/out/providers/common.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.joinPathSegments = void 0;\nfunction joinPathSegments(a, b, separator) {\n  /**\n   * The correct handling of cases when the first segment is a root (`/`, `C:/`) or UNC path (`//?/C:/`).\n   */\n  if (a.endsWith(separator)) {\n    return a + b;\n  }\n  return a + separator + b;\n}\nexports.joinPathSegments = joinPathSegments;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\@nodelib\\fs.scandir\\out\\providers\\common.js");

/***/ }),

/***/ "./node_modules/@nodelib/fs.scandir/out/providers/sync.js":
/*!****************************************************************!*\
  !*** ./node_modules/@nodelib/fs.scandir/out/providers/sync.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.readdir = exports.readdirWithFileTypes = exports.read = void 0;\nconst fsStat = __webpack_require__(/*! @nodelib/fs.stat */ \"./node_modules/@nodelib/fs.stat/out/index.js\");\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./node_modules/@nodelib/fs.scandir/out/constants.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"./node_modules/@nodelib/fs.scandir/out/utils/index.js\");\nconst common = __webpack_require__(/*! ./common */ \"./node_modules/@nodelib/fs.scandir/out/providers/common.js\");\nfunction read(directory, settings) {\n  if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {\n    return readdirWithFileTypes(directory, settings);\n  }\n  return readdir(directory, settings);\n}\nexports.read = read;\nfunction readdirWithFileTypes(directory, settings) {\n  const dirents = settings.fs.readdirSync(directory, {\n    withFileTypes: true\n  });\n  return dirents.map(dirent => {\n    const entry = {\n      dirent,\n      name: dirent.name,\n      path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)\n    };\n    if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {\n      try {\n        const stats = settings.fs.statSync(entry.path);\n        entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);\n      } catch (error) {\n        if (settings.throwErrorOnBrokenSymbolicLink) {\n          throw error;\n        }\n      }\n    }\n    return entry;\n  });\n}\nexports.readdirWithFileTypes = readdirWithFileTypes;\nfunction readdir(directory, settings) {\n  const names = settings.fs.readdirSync(directory);\n  return names.map(name => {\n    const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);\n    const stats = fsStat.statSync(entryPath, settings.fsStatSettings);\n    const entry = {\n      name,\n      path: entryPath,\n      dirent: utils.fs.createDirentFromStats(name, stats)\n    };\n    if (settings.stats) {\n      entry.stats = stats;\n    }\n    return entry;\n  });\n}\nexports.readdir = readdir;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\@nodelib\\fs.scandir\\out\\providers\\sync.js");

/***/ }),

/***/ "./node_modules/@nodelib/fs.scandir/out/settings.js":
/*!**********************************************************!*\
  !*** ./node_modules/@nodelib/fs.scandir/out/settings.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nconst path = __webpack_require__(/*! path */ \"path\");\nconst fsStat = __webpack_require__(/*! @nodelib/fs.stat */ \"./node_modules/@nodelib/fs.stat/out/index.js\");\nconst fs = __webpack_require__(/*! ./adapters/fs */ \"./node_modules/@nodelib/fs.scandir/out/adapters/fs.js\");\nclass Settings {\n  constructor(_options = {}) {\n    this._options = _options;\n    this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);\n    this.fs = fs.createFileSystemAdapter(this._options.fs);\n    this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);\n    this.stats = this._getValue(this._options.stats, false);\n    this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);\n    this.fsStatSettings = new fsStat.Settings({\n      followSymbolicLink: this.followSymbolicLinks,\n      fs: this.fs,\n      throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink\n    });\n  }\n  _getValue(option, value) {\n    return option !== null && option !== void 0 ? option : value;\n  }\n}\nexports[\"default\"] = Settings;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\@nodelib\\fs.scandir\\out\\settings.js");

/***/ }),

/***/ "./node_modules/@nodelib/fs.scandir/out/utils/fs.js":
/*!**********************************************************!*\
  !*** ./node_modules/@nodelib/fs.scandir/out/utils/fs.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.createDirentFromStats = void 0;\nclass DirentFromStats {\n  constructor(name, stats) {\n    this.name = name;\n    this.isBlockDevice = stats.isBlockDevice.bind(stats);\n    this.isCharacterDevice = stats.isCharacterDevice.bind(stats);\n    this.isDirectory = stats.isDirectory.bind(stats);\n    this.isFIFO = stats.isFIFO.bind(stats);\n    this.isFile = stats.isFile.bind(stats);\n    this.isSocket = stats.isSocket.bind(stats);\n    this.isSymbolicLink = stats.isSymbolicLink.bind(stats);\n  }\n}\nfunction createDirentFromStats(name, stats) {\n  return new DirentFromStats(name, stats);\n}\nexports.createDirentFromStats = createDirentFromStats;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\@nodelib\\fs.scandir\\out\\utils\\fs.js");

/***/ }),

/***/ "./node_modules/@nodelib/fs.scandir/out/utils/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@nodelib/fs.scandir/out/utils/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.fs = void 0;\nconst fs = __webpack_require__(/*! ./fs */ \"./node_modules/@nodelib/fs.scandir/out/utils/fs.js\");\nexports.fs = fs;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\@nodelib\\fs.scandir\\out\\utils\\index.js");

/***/ }),

/***/ "./node_modules/@nodelib/fs.stat/out/adapters/fs.js":
/*!**********************************************************!*\
  !*** ./node_modules/@nodelib/fs.stat/out/adapters/fs.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nexports.FILE_SYSTEM_ADAPTER = {\n  lstat: fs.lstat,\n  stat: fs.stat,\n  lstatSync: fs.lstatSync,\n  statSync: fs.statSync\n};\nfunction createFileSystemAdapter(fsMethods) {\n  if (fsMethods === undefined) {\n    return exports.FILE_SYSTEM_ADAPTER;\n  }\n  return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);\n}\nexports.createFileSystemAdapter = createFileSystemAdapter;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\@nodelib\\fs.stat\\out\\adapters\\fs.js");

/***/ }),

/***/ "./node_modules/@nodelib/fs.stat/out/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@nodelib/fs.stat/out/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.statSync = exports.stat = exports.Settings = void 0;\nconst async = __webpack_require__(/*! ./providers/async */ \"./node_modules/@nodelib/fs.stat/out/providers/async.js\");\nconst sync = __webpack_require__(/*! ./providers/sync */ \"./node_modules/@nodelib/fs.stat/out/providers/sync.js\");\nconst settings_1 = __webpack_require__(/*! ./settings */ \"./node_modules/@nodelib/fs.stat/out/settings.js\");\nexports.Settings = settings_1.default;\nfunction stat(path, optionsOrSettingsOrCallback, callback) {\n  if (typeof optionsOrSettingsOrCallback === 'function') {\n    async.read(path, getSettings(), optionsOrSettingsOrCallback);\n    return;\n  }\n  async.read(path, getSettings(optionsOrSettingsOrCallback), callback);\n}\nexports.stat = stat;\nfunction statSync(path, optionsOrSettings) {\n  const settings = getSettings(optionsOrSettings);\n  return sync.read(path, settings);\n}\nexports.statSync = statSync;\nfunction getSettings(settingsOrOptions = {}) {\n  if (settingsOrOptions instanceof settings_1.default) {\n    return settingsOrOptions;\n  }\n  return new settings_1.default(settingsOrOptions);\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\@nodelib\\fs.stat\\out\\index.js");

/***/ }),

/***/ "./node_modules/@nodelib/fs.stat/out/providers/async.js":
/*!**************************************************************!*\
  !*** ./node_modules/@nodelib/fs.stat/out/providers/async.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.read = void 0;\nfunction read(path, settings, callback) {\n  settings.fs.lstat(path, (lstatError, lstat) => {\n    if (lstatError !== null) {\n      callFailureCallback(callback, lstatError);\n      return;\n    }\n    if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {\n      callSuccessCallback(callback, lstat);\n      return;\n    }\n    settings.fs.stat(path, (statError, stat) => {\n      if (statError !== null) {\n        if (settings.throwErrorOnBrokenSymbolicLink) {\n          callFailureCallback(callback, statError);\n          return;\n        }\n        callSuccessCallback(callback, lstat);\n        return;\n      }\n      if (settings.markSymbolicLink) {\n        stat.isSymbolicLink = () => true;\n      }\n      callSuccessCallback(callback, stat);\n    });\n  });\n}\nexports.read = read;\nfunction callFailureCallback(callback, error) {\n  callback(error);\n}\nfunction callSuccessCallback(callback, result) {\n  callback(null, result);\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\@nodelib\\fs.stat\\out\\providers\\async.js");

/***/ }),

/***/ "./node_modules/@nodelib/fs.stat/out/providers/sync.js":
/*!*************************************************************!*\
  !*** ./node_modules/@nodelib/fs.stat/out/providers/sync.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.read = void 0;\nfunction read(path, settings) {\n  const lstat = settings.fs.lstatSync(path);\n  if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {\n    return lstat;\n  }\n  try {\n    const stat = settings.fs.statSync(path);\n    if (settings.markSymbolicLink) {\n      stat.isSymbolicLink = () => true;\n    }\n    return stat;\n  } catch (error) {\n    if (!settings.throwErrorOnBrokenSymbolicLink) {\n      return lstat;\n    }\n    throw error;\n  }\n}\nexports.read = read;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\@nodelib\\fs.stat\\out\\providers\\sync.js");

/***/ }),

/***/ "./node_modules/@nodelib/fs.stat/out/settings.js":
/*!*******************************************************!*\
  !*** ./node_modules/@nodelib/fs.stat/out/settings.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nconst fs = __webpack_require__(/*! ./adapters/fs */ \"./node_modules/@nodelib/fs.stat/out/adapters/fs.js\");\nclass Settings {\n  constructor(_options = {}) {\n    this._options = _options;\n    this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);\n    this.fs = fs.createFileSystemAdapter(this._options.fs);\n    this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);\n    this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);\n  }\n  _getValue(option, value) {\n    return option !== null && option !== void 0 ? option : value;\n  }\n}\nexports[\"default\"] = Settings;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\@nodelib\\fs.stat\\out\\settings.js");

/***/ }),

/***/ "./node_modules/@nodelib/fs.walk/out/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@nodelib/fs.walk/out/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.Settings = exports.walkStream = exports.walkSync = exports.walk = void 0;\nconst async_1 = __webpack_require__(/*! ./providers/async */ \"./node_modules/@nodelib/fs.walk/out/providers/async.js\");\nconst stream_1 = __webpack_require__(/*! ./providers/stream */ \"./node_modules/@nodelib/fs.walk/out/providers/stream.js\");\nconst sync_1 = __webpack_require__(/*! ./providers/sync */ \"./node_modules/@nodelib/fs.walk/out/providers/sync.js\");\nconst settings_1 = __webpack_require__(/*! ./settings */ \"./node_modules/@nodelib/fs.walk/out/settings.js\");\nexports.Settings = settings_1.default;\nfunction walk(directory, optionsOrSettingsOrCallback, callback) {\n  if (typeof optionsOrSettingsOrCallback === 'function') {\n    new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);\n    return;\n  }\n  new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);\n}\nexports.walk = walk;\nfunction walkSync(directory, optionsOrSettings) {\n  const settings = getSettings(optionsOrSettings);\n  const provider = new sync_1.default(directory, settings);\n  return provider.read();\n}\nexports.walkSync = walkSync;\nfunction walkStream(directory, optionsOrSettings) {\n  const settings = getSettings(optionsOrSettings);\n  const provider = new stream_1.default(directory, settings);\n  return provider.read();\n}\nexports.walkStream = walkStream;\nfunction getSettings(settingsOrOptions = {}) {\n  if (settingsOrOptions instanceof settings_1.default) {\n    return settingsOrOptions;\n  }\n  return new settings_1.default(settingsOrOptions);\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\@nodelib\\fs.walk\\out\\index.js");

/***/ }),

/***/ "./node_modules/@nodelib/fs.walk/out/providers/async.js":
/*!**************************************************************!*\
  !*** ./node_modules/@nodelib/fs.walk/out/providers/async.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nconst async_1 = __webpack_require__(/*! ../readers/async */ \"./node_modules/@nodelib/fs.walk/out/readers/async.js\");\nclass AsyncProvider {\n  constructor(_root, _settings) {\n    this._root = _root;\n    this._settings = _settings;\n    this._reader = new async_1.default(this._root, this._settings);\n    this._storage = [];\n  }\n  read(callback) {\n    this._reader.onError(error => {\n      callFailureCallback(callback, error);\n    });\n    this._reader.onEntry(entry => {\n      this._storage.push(entry);\n    });\n    this._reader.onEnd(() => {\n      callSuccessCallback(callback, this._storage);\n    });\n    this._reader.read();\n  }\n}\nexports[\"default\"] = AsyncProvider;\nfunction callFailureCallback(callback, error) {\n  callback(error);\n}\nfunction callSuccessCallback(callback, entries) {\n  callback(null, entries);\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\@nodelib\\fs.walk\\out\\providers\\async.js");

/***/ }),

/***/ "./node_modules/@nodelib/fs.walk/out/providers/stream.js":
/*!***************************************************************!*\
  !*** ./node_modules/@nodelib/fs.walk/out/providers/stream.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst async_1 = __webpack_require__(/*! ../readers/async */ \"./node_modules/@nodelib/fs.walk/out/readers/async.js\");\nclass StreamProvider {\n  constructor(_root, _settings) {\n    this._root = _root;\n    this._settings = _settings;\n    this._reader = new async_1.default(this._root, this._settings);\n    this._stream = new stream_1.Readable({\n      objectMode: true,\n      read: () => {},\n      destroy: () => {\n        if (!this._reader.isDestroyed) {\n          this._reader.destroy();\n        }\n      }\n    });\n  }\n  read() {\n    this._reader.onError(error => {\n      this._stream.emit('error', error);\n    });\n    this._reader.onEntry(entry => {\n      this._stream.push(entry);\n    });\n    this._reader.onEnd(() => {\n      this._stream.push(null);\n    });\n    this._reader.read();\n    return this._stream;\n  }\n}\nexports[\"default\"] = StreamProvider;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\@nodelib\\fs.walk\\out\\providers\\stream.js");

/***/ }),

/***/ "./node_modules/@nodelib/fs.walk/out/providers/sync.js":
/*!*************************************************************!*\
  !*** ./node_modules/@nodelib/fs.walk/out/providers/sync.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nconst sync_1 = __webpack_require__(/*! ../readers/sync */ \"./node_modules/@nodelib/fs.walk/out/readers/sync.js\");\nclass SyncProvider {\n  constructor(_root, _settings) {\n    this._root = _root;\n    this._settings = _settings;\n    this._reader = new sync_1.default(this._root, this._settings);\n  }\n  read() {\n    return this._reader.read();\n  }\n}\nexports[\"default\"] = SyncProvider;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\@nodelib\\fs.walk\\out\\providers\\sync.js");

/***/ }),

/***/ "./node_modules/@nodelib/fs.walk/out/readers/async.js":
/*!************************************************************!*\
  !*** ./node_modules/@nodelib/fs.walk/out/readers/async.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst fsScandir = __webpack_require__(/*! @nodelib/fs.scandir */ \"./node_modules/@nodelib/fs.scandir/out/index.js\");\nconst fastq = __webpack_require__(/*! fastq */ \"./node_modules/fastq/queue.js\");\nconst common = __webpack_require__(/*! ./common */ \"./node_modules/@nodelib/fs.walk/out/readers/common.js\");\nconst reader_1 = __webpack_require__(/*! ./reader */ \"./node_modules/@nodelib/fs.walk/out/readers/reader.js\");\nclass AsyncReader extends reader_1.default {\n  constructor(_root, _settings) {\n    super(_root, _settings);\n    this._settings = _settings;\n    this._scandir = fsScandir.scandir;\n    this._emitter = new events_1.EventEmitter();\n    this._queue = fastq(this._worker.bind(this), this._settings.concurrency);\n    this._isFatalError = false;\n    this._isDestroyed = false;\n    this._queue.drain = () => {\n      if (!this._isFatalError) {\n        this._emitter.emit('end');\n      }\n    };\n  }\n  read() {\n    this._isFatalError = false;\n    this._isDestroyed = false;\n    setImmediate(() => {\n      this._pushToQueue(this._root, this._settings.basePath);\n    });\n    return this._emitter;\n  }\n  get isDestroyed() {\n    return this._isDestroyed;\n  }\n  destroy() {\n    if (this._isDestroyed) {\n      throw new Error('The reader is already destroyed');\n    }\n    this._isDestroyed = true;\n    this._queue.killAndDrain();\n  }\n  onEntry(callback) {\n    this._emitter.on('entry', callback);\n  }\n  onError(callback) {\n    this._emitter.once('error', callback);\n  }\n  onEnd(callback) {\n    this._emitter.once('end', callback);\n  }\n  _pushToQueue(directory, base) {\n    const queueItem = {\n      directory,\n      base\n    };\n    this._queue.push(queueItem, error => {\n      if (error !== null) {\n        this._handleError(error);\n      }\n    });\n  }\n  _worker(item, done) {\n    this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {\n      if (error !== null) {\n        done(error, undefined);\n        return;\n      }\n      var _iterator = _createForOfIteratorHelper(entries),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          const entry = _step.value;\n          this._handleEntry(entry, item.base);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      done(null, undefined);\n    });\n  }\n  _handleError(error) {\n    if (this._isDestroyed || !common.isFatalError(this._settings, error)) {\n      return;\n    }\n    this._isFatalError = true;\n    this._isDestroyed = true;\n    this._emitter.emit('error', error);\n  }\n  _handleEntry(entry, base) {\n    if (this._isDestroyed || this._isFatalError) {\n      return;\n    }\n    const fullpath = entry.path;\n    if (base !== undefined) {\n      entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);\n    }\n    if (common.isAppliedFilter(this._settings.entryFilter, entry)) {\n      this._emitEntry(entry);\n    }\n    if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {\n      this._pushToQueue(fullpath, base === undefined ? undefined : entry.path);\n    }\n  }\n  _emitEntry(entry) {\n    this._emitter.emit('entry', entry);\n  }\n}\nexports[\"default\"] = AsyncReader;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\@nodelib\\fs.walk\\out\\readers\\async.js");

/***/ }),

/***/ "./node_modules/@nodelib/fs.walk/out/readers/common.js":
/*!*************************************************************!*\
  !*** ./node_modules/@nodelib/fs.walk/out/readers/common.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.joinPathSegments = exports.replacePathSegmentSeparator = exports.isAppliedFilter = exports.isFatalError = void 0;\nfunction isFatalError(settings, error) {\n  if (settings.errorFilter === null) {\n    return true;\n  }\n  return !settings.errorFilter(error);\n}\nexports.isFatalError = isFatalError;\nfunction isAppliedFilter(filter, value) {\n  return filter === null || filter(value);\n}\nexports.isAppliedFilter = isAppliedFilter;\nfunction replacePathSegmentSeparator(filepath, separator) {\n  return filepath.split(/[/\\\\]/).join(separator);\n}\nexports.replacePathSegmentSeparator = replacePathSegmentSeparator;\nfunction joinPathSegments(a, b, separator) {\n  if (a === '') {\n    return b;\n  }\n  /**\n   * The correct handling of cases when the first segment is a root (`/`, `C:/`) or UNC path (`//?/C:/`).\n   */\n  if (a.endsWith(separator)) {\n    return a + b;\n  }\n  return a + separator + b;\n}\nexports.joinPathSegments = joinPathSegments;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\@nodelib\\fs.walk\\out\\readers\\common.js");

/***/ }),

/***/ "./node_modules/@nodelib/fs.walk/out/readers/reader.js":
/*!*************************************************************!*\
  !*** ./node_modules/@nodelib/fs.walk/out/readers/reader.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nconst common = __webpack_require__(/*! ./common */ \"./node_modules/@nodelib/fs.walk/out/readers/common.js\");\nclass Reader {\n  constructor(_root, _settings) {\n    this._root = _root;\n    this._settings = _settings;\n    this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);\n  }\n}\nexports[\"default\"] = Reader;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\@nodelib\\fs.walk\\out\\readers\\reader.js");

/***/ }),

/***/ "./node_modules/@nodelib/fs.walk/out/readers/sync.js":
/*!***********************************************************!*\
  !*** ./node_modules/@nodelib/fs.walk/out/readers/sync.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nconst fsScandir = __webpack_require__(/*! @nodelib/fs.scandir */ \"./node_modules/@nodelib/fs.scandir/out/index.js\");\nconst common = __webpack_require__(/*! ./common */ \"./node_modules/@nodelib/fs.walk/out/readers/common.js\");\nconst reader_1 = __webpack_require__(/*! ./reader */ \"./node_modules/@nodelib/fs.walk/out/readers/reader.js\");\nclass SyncReader extends reader_1.default {\n  constructor() {\n    super(...arguments);\n    this._scandir = fsScandir.scandirSync;\n    this._storage = [];\n    this._queue = new Set();\n  }\n  read() {\n    this._pushToQueue(this._root, this._settings.basePath);\n    this._handleQueue();\n    return this._storage;\n  }\n  _pushToQueue(directory, base) {\n    this._queue.add({\n      directory,\n      base\n    });\n  }\n  _handleQueue() {\n    var _iterator = _createForOfIteratorHelper(this._queue.values()),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        const item = _step.value;\n        this._handleDirectory(item.directory, item.base);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  _handleDirectory(directory, base) {\n    try {\n      const entries = this._scandir(directory, this._settings.fsScandirSettings);\n      var _iterator2 = _createForOfIteratorHelper(entries),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          const entry = _step2.value;\n          this._handleEntry(entry, base);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    } catch (error) {\n      this._handleError(error);\n    }\n  }\n  _handleError(error) {\n    if (!common.isFatalError(this._settings, error)) {\n      return;\n    }\n    throw error;\n  }\n  _handleEntry(entry, base) {\n    const fullpath = entry.path;\n    if (base !== undefined) {\n      entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);\n    }\n    if (common.isAppliedFilter(this._settings.entryFilter, entry)) {\n      this._pushToStorage(entry);\n    }\n    if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {\n      this._pushToQueue(fullpath, base === undefined ? undefined : entry.path);\n    }\n  }\n  _pushToStorage(entry) {\n    this._storage.push(entry);\n  }\n}\nexports[\"default\"] = SyncReader;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\@nodelib\\fs.walk\\out\\readers\\sync.js");

/***/ }),

/***/ "./node_modules/@nodelib/fs.walk/out/settings.js":
/*!*******************************************************!*\
  !*** ./node_modules/@nodelib/fs.walk/out/settings.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nconst path = __webpack_require__(/*! path */ \"path\");\nconst fsScandir = __webpack_require__(/*! @nodelib/fs.scandir */ \"./node_modules/@nodelib/fs.scandir/out/index.js\");\nclass Settings {\n  constructor(_options = {}) {\n    this._options = _options;\n    this.basePath = this._getValue(this._options.basePath, undefined);\n    this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);\n    this.deepFilter = this._getValue(this._options.deepFilter, null);\n    this.entryFilter = this._getValue(this._options.entryFilter, null);\n    this.errorFilter = this._getValue(this._options.errorFilter, null);\n    this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);\n    this.fsScandirSettings = new fsScandir.Settings({\n      followSymbolicLinks: this._options.followSymbolicLinks,\n      fs: this._options.fs,\n      pathSegmentSeparator: this._options.pathSegmentSeparator,\n      stats: this._options.stats,\n      throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink\n    });\n  }\n  _getValue(option, value) {\n    return option !== null && option !== void 0 ? option : value;\n  }\n}\nexports[\"default\"] = Settings;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\@nodelib\\fs.walk\\out\\settings.js");

/***/ }),

/***/ "./node_modules/azure-pipelines-task-lib/internal.js":
/*!***********************************************************!*\
  !*** ./node_modules/azure-pipelines-task-lib/internal.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports._exposeCertSettings = exports._exposeProxySettings = exports._normalizeSeparators = exports._isRooted = exports._getDirectoryName = exports._ensureRooted = exports._isUncPath = exports._loadData = exports._ensurePatternRooted = exports._getFindInfoFromPattern = exports._cloneMatchOptions = exports._legacyFindFiles_convertPatternToRegExp = exports._which = exports._checkPath = exports._exist = exports._debug = exports._error = exports._warning = exports._command = exports._getVariableKey = exports._getVariable = exports._loc = exports._setResourcePath = exports._setErrStream = exports._setStdStream = exports._writeLine = exports._endsWith = exports._startsWith = exports._vault = exports._knownVariableMap = void 0;\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar os = __webpack_require__(/*! os */ \"os\");\nvar minimatch = __webpack_require__(/*! minimatch */ \"./node_modules/azure-pipelines-task-lib/node_modules/minimatch/minimatch.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar tcm = __webpack_require__(/*! ./taskcommand */ \"./node_modules/azure-pipelines-task-lib/taskcommand.js\");\nvar vm = __webpack_require__(/*! ./vault */ \"./node_modules/azure-pipelines-task-lib/vault.js\");\nvar semver = __webpack_require__(/*! semver */ \"./node_modules/azure-pipelines-task-lib/node_modules/semver/semver.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\n/**\n * Hash table of known variable info. The formatted env var name is the lookup key.\n *\n * The purpose of this hash table is to keep track of known variables. The hash table\n * needs to be maintained for multiple reasons:\n *  1) to distinguish between env vars and job vars\n *  2) to distinguish between secret vars and public\n *  3) to know the real variable name and not just the formatted env var name.\n */\nexports._knownVariableMap = {};\n//-----------------------------------------------------\n// Validation Checks\n//-----------------------------------------------------\n// async await needs generators in node 4.x+\nif (semver.lt(process.versions.node, '4.2.0')) {\n  _warning('Tasks require a new agent.  Upgrade your agent or node to 4.2.0 or later');\n}\n//-----------------------------------------------------\n// String convenience\n//-----------------------------------------------------\nfunction _startsWith(str, start) {\n  return str.slice(0, start.length) == start;\n}\nexports._startsWith = _startsWith;\nfunction _endsWith(str, end) {\n  return str.slice(-end.length) == end;\n}\nexports._endsWith = _endsWith;\n//-----------------------------------------------------\n// General Helpers\n//-----------------------------------------------------\nvar _outStream = process.stdout;\nvar _errStream = process.stderr;\nfunction _writeLine(str) {\n  _outStream.write(str + os.EOL);\n}\nexports._writeLine = _writeLine;\nfunction _setStdStream(stdStream) {\n  _outStream = stdStream;\n}\nexports._setStdStream = _setStdStream;\nfunction _setErrStream(errStream) {\n  _errStream = errStream;\n}\nexports._setErrStream = _setErrStream;\n//-----------------------------------------------------\n// Loc Helpers\n//-----------------------------------------------------\nvar _locStringCache = {};\nvar _resourceFiles = {};\nvar _libResourceFileLoaded = false;\nvar _resourceCulture = 'en-US';\nfunction _loadResJson(resjsonFile) {\n  var resJson;\n  if (_exist(resjsonFile)) {\n    var resjsonContent = fs.readFileSync(resjsonFile, 'utf8').toString();\n    // remove BOM\n    if (resjsonContent.indexOf('\\uFEFF') == 0) {\n      resjsonContent = resjsonContent.slice(1);\n    }\n    try {\n      resJson = JSON.parse(resjsonContent);\n    } catch (err) {\n      _debug('unable to parse resjson with err: ' + err.message);\n    }\n  } else {\n    _debug('.resjson file not found: ' + resjsonFile);\n  }\n  return resJson;\n}\nfunction _loadLocStrings(resourceFile, culture) {\n  var locStrings = {};\n  if (_exist(resourceFile)) {\n    var resourceJson = __webpack_require__(\"./node_modules/azure-pipelines-task-lib sync recursive\")(resourceFile);\n    if (resourceJson && resourceJson.hasOwnProperty('messages')) {\n      var locResourceJson;\n      // load up resource resjson for different culture\n      var localizedResourceFile = path.join(path.dirname(resourceFile), 'Strings', 'resources.resjson');\n      var upperCulture = culture.toUpperCase();\n      var cultures = [];\n      try {\n        cultures = fs.readdirSync(localizedResourceFile);\n      } catch (ex) {}\n      for (var i = 0; i < cultures.length; i++) {\n        if (cultures[i].toUpperCase() == upperCulture) {\n          localizedResourceFile = path.join(localizedResourceFile, cultures[i], 'resources.resjson');\n          if (_exist(localizedResourceFile)) {\n            locResourceJson = _loadResJson(localizedResourceFile);\n          }\n          break;\n        }\n      }\n      for (var key in resourceJson.messages) {\n        if (locResourceJson && locResourceJson.hasOwnProperty('loc.messages.' + key)) {\n          locStrings[key] = locResourceJson['loc.messages.' + key];\n        } else {\n          locStrings[key] = resourceJson.messages[key];\n        }\n      }\n    }\n  } else {\n    _warning('LIB_ResourceFile does not exist');\n  }\n  return locStrings;\n}\n/**\n * Sets the location of the resources json.  This is typically the task.json file.\n * Call once at the beginning of the script before any calls to loc.\n * @param     path      Full path to the json.\n * @param     ignoreWarnings  Won't throw warnings if path already set.\n * @returns   void\n */\nfunction _setResourcePath(path, ignoreWarnings) {\n  if (ignoreWarnings === void 0) {\n    ignoreWarnings = false;\n  }\n  if (process.env['TASKLIB_INPROC_UNITS']) {\n    _resourceFiles = {};\n    _libResourceFileLoaded = false;\n    _locStringCache = {};\n    _resourceCulture = 'en-US';\n  }\n  if (!_resourceFiles[path]) {\n    _checkPath(path, 'resource file path');\n    _resourceFiles[path] = path;\n    _debug('adding resource file: ' + path);\n    _resourceCulture = _getVariable('system.culture') || _resourceCulture;\n    var locStrs = _loadLocStrings(path, _resourceCulture);\n    for (var key in locStrs) {\n      //cache loc string\n      _locStringCache[key] = locStrs[key];\n    }\n  } else {\n    if (ignoreWarnings) {\n      _debug(_loc('LIB_ResourceFileAlreadySet', path));\n    } else {\n      _warning(_loc('LIB_ResourceFileAlreadySet', path));\n    }\n  }\n}\nexports._setResourcePath = _setResourcePath;\n/**\n * Gets the localized string from the json resource file.  Optionally formats with additional params.\n *\n * @param     key      key of the resources string in the resource file\n * @param     param    additional params for formatting the string\n * @returns   string\n */\nfunction _loc(key) {\n  var param = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    param[_i - 1] = arguments[_i];\n  }\n  if (!_libResourceFileLoaded) {\n    // merge loc strings from azure-pipelines-task-lib.\n    var libResourceFile = path.join(__dirname, 'lib.json');\n    var libLocStrs = _loadLocStrings(libResourceFile, _resourceCulture);\n    for (var libKey in libLocStrs) {\n      //cache azure-pipelines-task-lib loc string\n      _locStringCache[libKey] = libLocStrs[libKey];\n    }\n    _libResourceFileLoaded = true;\n  }\n  var locString;\n  ;\n  if (_locStringCache.hasOwnProperty(key)) {\n    locString = _locStringCache[key];\n  } else {\n    if (Object.keys(_resourceFiles).length <= 0) {\n      _warning(\"Resource file haven't been set, can't find loc string for key: \" + key);\n    } else {\n      _warning(\"Can't find loc string for key: \" + key);\n    }\n    locString = key;\n  }\n  if (param.length > 0) {\n    return util.format.apply(this, [locString].concat(param));\n  } else {\n    return locString;\n  }\n}\nexports._loc = _loc;\n//-----------------------------------------------------\n// Input Helpers\n//-----------------------------------------------------\n/**\n * Gets a variable value that is defined on the build/release definition or set at runtime.\n *\n * @param     name     name of the variable to get\n * @returns   string\n */\nfunction _getVariable(name) {\n  var varval;\n  // get the metadata\n  var info;\n  var key = _getVariableKey(name);\n  if (exports._knownVariableMap.hasOwnProperty(key)) {\n    info = exports._knownVariableMap[key];\n  }\n  if (info && info.secret) {\n    // get the secret value\n    varval = exports._vault.retrieveSecret('SECRET_' + key);\n  } else {\n    // get the public value\n    varval = process.env[key];\n    // fallback for pre 2.104.1 agent\n    if (!varval && name.toUpperCase() == 'AGENT.JOBSTATUS') {\n      varval = process.env['agent.jobstatus'];\n    }\n  }\n  _debug(name + '=' + varval);\n  return varval;\n}\nexports._getVariable = _getVariable;\nfunction _getVariableKey(name) {\n  if (!name) {\n    throw new Error(_loc('LIB_ParameterIsRequired', 'name'));\n  }\n  return name.replace(/\\./g, '_').replace(/ /g, '_').toUpperCase();\n}\nexports._getVariableKey = _getVariableKey;\n//-----------------------------------------------------\n// Cmd Helpers\n//-----------------------------------------------------\nfunction _command(command, properties, message) {\n  var taskCmd = new tcm.TaskCommand(command, properties, message);\n  _writeLine(taskCmd.toString());\n}\nexports._command = _command;\nfunction _warning(message) {\n  _command('task.issue', {\n    'type': 'warning'\n  }, message);\n}\nexports._warning = _warning;\nfunction _error(message) {\n  _command('task.issue', {\n    'type': 'error'\n  }, message);\n}\nexports._error = _error;\nfunction _debug(message) {\n  _command('task.debug', null, message);\n}\nexports._debug = _debug;\n// //-----------------------------------------------------\n// // Disk Functions\n// //-----------------------------------------------------\n/**\n * Returns whether a path exists.\n *\n * @param     path      path to check\n * @returns   boolean\n */\nfunction _exist(path) {\n  var exist = false;\n  try {\n    exist = !!(path && fs.statSync(path) != null);\n  } catch (err) {\n    if (err && err.code === 'ENOENT') {\n      exist = false;\n    } else {\n      throw err;\n    }\n  }\n  return exist;\n}\nexports._exist = _exist;\n/**\n * Checks whether a path exists.\n * If the path does not exist, it will throw.\n *\n * @param     p         path to check\n * @param     name      name only used in error message to identify the path\n * @returns   void\n */\nfunction _checkPath(p, name) {\n  _debug('check path : ' + p);\n  if (!_exist(p)) {\n    throw new Error(_loc('LIB_PathNotFound', name, p));\n  }\n}\nexports._checkPath = _checkPath;\n/**\n * Returns path of a tool had the tool actually been invoked.  Resolves via paths.\n * If you check and the tool does not exist, it will throw.\n *\n * @param     tool       name of the tool\n * @param     check      whether to check if tool exists\n * @returns   string\n */\nfunction _which(tool, check) {\n  if (!tool) {\n    throw new Error('parameter \\'tool\\' is required');\n  }\n  // recursive when check=true\n  if (check) {\n    var result = _which(tool, false);\n    if (result) {\n      return result;\n    } else {\n      if (process.platform == 'win32') {\n        throw new Error(_loc('LIB_WhichNotFound_Win', tool));\n      } else {\n        throw new Error(_loc('LIB_WhichNotFound_Linux', tool));\n      }\n    }\n  }\n  _debug(\"which '\" + tool + \"'\");\n  try {\n    // build the list of extensions to try\n    var extensions = [];\n    if (process.platform == 'win32' && process.env['PATHEXT']) {\n      for (var _i = 0, _a = process.env['PATHEXT'].split(path.delimiter); _i < _a.length; _i++) {\n        var extension = _a[_i];\n        if (extension) {\n          extensions.push(extension);\n        }\n      }\n    }\n    // if it's rooted, return it if exists. otherwise return empty.\n    if (_isRooted(tool)) {\n      var filePath = _tryGetExecutablePath(tool, extensions);\n      if (filePath) {\n        _debug(\"found: '\" + filePath + \"'\");\n        return filePath;\n      }\n      _debug('not found');\n      return '';\n    }\n    // if any path separators, return empty\n    if (tool.indexOf('/') >= 0 || process.platform == 'win32' && tool.indexOf('\\\\') >= 0) {\n      _debug('not found');\n      return '';\n    }\n    // build the list of directories\n    //\n    // Note, technically \"where\" checks the current directory on Windows. From a task lib perspective,\n    // it feels like we should not do this. Checking the current directory seems like more of a use\n    // case of a shell, and the which() function exposed by the task lib should strive for consistency\n    // across platforms.\n    var directories = [];\n    if (process.env['PATH']) {\n      for (var _b = 0, _c = process.env['PATH'].split(path.delimiter); _b < _c.length; _b++) {\n        var p = _c[_b];\n        if (p) {\n          directories.push(p);\n        }\n      }\n    }\n    // return the first match\n    for (var _d = 0, directories_1 = directories; _d < directories_1.length; _d++) {\n      var directory = directories_1[_d];\n      var filePath = _tryGetExecutablePath(directory + path.sep + tool, extensions);\n      if (filePath) {\n        _debug(\"found: '\" + filePath + \"'\");\n        return filePath;\n      }\n    }\n    _debug('not found');\n    return '';\n  } catch (err) {\n    throw new Error(_loc('LIB_OperationFailed', 'which', err.message));\n  }\n}\nexports._which = _which;\n/**\n * Best effort attempt to determine whether a file exists and is executable.\n * @param filePath    file path to check\n * @param extensions  additional file extensions to try\n * @return if file exists and is executable, returns the file path. otherwise empty string.\n */\nfunction _tryGetExecutablePath(filePath, extensions) {\n  try {\n    // test file exists\n    var stats = fs.statSync(filePath);\n    if (stats.isFile()) {\n      if (process.platform == 'win32') {\n        // on Windows, test for valid extension\n        var isExecutable = false;\n        var fileName = path.basename(filePath);\n        var dotIndex = fileName.lastIndexOf('.');\n        if (dotIndex >= 0) {\n          var upperExt_1 = fileName.substr(dotIndex).toUpperCase();\n          if (extensions.some(function (validExt) {\n            return validExt.toUpperCase() == upperExt_1;\n          })) {\n            return filePath;\n          }\n        }\n      } else {\n        if (isUnixExecutable(stats)) {\n          return filePath;\n        }\n      }\n    }\n  } catch (err) {\n    if (err.code != 'ENOENT') {\n      _debug(\"Unexpected error attempting to determine if executable file exists '\" + filePath + \"': \" + err);\n    }\n  }\n  // try each extension\n  var originalFilePath = filePath;\n  for (var _i = 0, extensions_1 = extensions; _i < extensions_1.length; _i++) {\n    var extension = extensions_1[_i];\n    var found = false;\n    var filePath_1 = originalFilePath + extension;\n    try {\n      var stats = fs.statSync(filePath_1);\n      if (stats.isFile()) {\n        if (process.platform == 'win32') {\n          // preserve the case of the actual file (since an extension was appended)\n          try {\n            var directory = path.dirname(filePath_1);\n            var upperName = path.basename(filePath_1).toUpperCase();\n            for (var _a = 0, _b = fs.readdirSync(directory); _a < _b.length; _a++) {\n              var actualName = _b[_a];\n              if (upperName == actualName.toUpperCase()) {\n                filePath_1 = path.join(directory, actualName);\n                break;\n              }\n            }\n          } catch (err) {\n            _debug(\"Unexpected error attempting to determine the actual case of the file '\" + filePath_1 + \"': \" + err);\n          }\n          return filePath_1;\n        } else {\n          if (isUnixExecutable(stats)) {\n            return filePath_1;\n          }\n        }\n      }\n    } catch (err) {\n      if (err.code != 'ENOENT') {\n        _debug(\"Unexpected error attempting to determine if executable file exists '\" + filePath_1 + \"': \" + err);\n      }\n    }\n  }\n  return '';\n}\n// on Mac/Linux, test the execute bit\n//     R   W  X  R  W X R W X\n//   256 128 64 32 16 8 4 2 1\nfunction isUnixExecutable(stats) {\n  return (stats.mode & 1) > 0 || (stats.mode & 8) > 0 && stats.gid === process.getgid() || (stats.mode & 64) > 0 && stats.uid === process.getuid();\n}\nfunction _legacyFindFiles_convertPatternToRegExp(pattern) {\n  pattern = (process.platform == 'win32' ? pattern.replace(/\\\\/g, '/') : pattern // normalize separator on Windows\n  ).replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&') // regex escape - from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n  .replace(/\\\\\\/\\\\\\*\\\\\\*\\\\\\//g, '((\\/.+/)|(\\/))') // replace directory globstar, e.g. /hello/**/world\n  .replace(/\\\\\\*\\\\\\*/g, '.*') // replace remaining globstars with a wildcard that can span directory separators, e.g. /hello/**dll\n  .replace(/\\\\\\*/g, '[^\\/]*') // replace asterisks with a wildcard that cannot span directory separators, e.g. /hello/*.dll\n  .replace(/\\\\\\?/g, '[^\\/]'); // replace single character wildcards, e.g. /hello/log?.dll\n  pattern = \"^\" + pattern + \"$\";\n  var flags = process.platform == 'win32' ? 'i' : '';\n  return new RegExp(pattern, flags);\n}\nexports._legacyFindFiles_convertPatternToRegExp = _legacyFindFiles_convertPatternToRegExp;\nfunction _cloneMatchOptions(matchOptions) {\n  return {\n    debug: matchOptions.debug,\n    nobrace: matchOptions.nobrace,\n    noglobstar: matchOptions.noglobstar,\n    dot: matchOptions.dot,\n    noext: matchOptions.noext,\n    nocase: matchOptions.nocase,\n    nonull: matchOptions.nonull,\n    matchBase: matchOptions.matchBase,\n    nocomment: matchOptions.nocomment,\n    nonegate: matchOptions.nonegate,\n    flipNegate: matchOptions.flipNegate\n  };\n}\nexports._cloneMatchOptions = _cloneMatchOptions;\nfunction _getFindInfoFromPattern(defaultRoot, pattern, matchOptions) {\n  // parameter validation\n  if (!defaultRoot) {\n    throw new Error('getFindRootFromPattern() parameter defaultRoot cannot be empty');\n  }\n  if (!pattern) {\n    throw new Error('getFindRootFromPattern() parameter pattern cannot be empty');\n  }\n  if (!matchOptions.nobrace) {\n    throw new Error('getFindRootFromPattern() expected matchOptions.nobrace to be true');\n  }\n  // for the sake of determining the findPath, pretend nocase=false\n  matchOptions = _cloneMatchOptions(matchOptions);\n  matchOptions.nocase = false;\n  // check if basename only and matchBase=true\n  if (matchOptions.matchBase && !_isRooted(pattern) && (process.platform == 'win32' ? pattern.replace(/\\\\/g, '/') : pattern).indexOf('/') < 0) {\n    return {\n      adjustedPattern: pattern,\n      findPath: defaultRoot,\n      statOnly: false\n    };\n  }\n  // the technique applied by this function is to use the information on the Minimatch object determine\n  // the findPath. Minimatch breaks the pattern into path segments, and exposes information about which\n  // segments are literal vs patterns.\n  //\n  // note, the technique currently imposes a limitation for drive-relative paths with a glob in the\n  // first segment, e.g. C:hello*/world. it's feasible to overcome this limitation, but is left unsolved\n  // for now.\n  var minimatchObj = new minimatch.Minimatch(pattern, matchOptions);\n  // the \"set\" property is an array of arrays of parsed path segment info. the outer array should only\n  // contain one item, otherwise something went wrong. brace expansion can result in multiple arrays,\n  // but that should be turned off by the time this function is reached.\n  if (minimatchObj.set.length != 1) {\n    throw new Error('getFindRootFromPattern() expected Minimatch(...).set.length to be 1. Actual: ' + minimatchObj.set.length);\n  }\n  var literalSegments = [];\n  for (var _i = 0, _a = minimatchObj.set[0]; _i < _a.length; _i++) {\n    var parsedSegment = _a[_i];\n    if (typeof parsedSegment == 'string') {\n      // the item is a string when the original input for the path segment does not contain any\n      // unescaped glob characters.\n      //\n      // note, the string here is already unescaped (i.e. glob escaping removed), so it is ready\n      // to pass to find() as-is. for example, an input string 'hello\\\\*world' => 'hello*world'.\n      literalSegments.push(parsedSegment);\n      continue;\n    }\n    break;\n  }\n  // join the literal segments back together. Minimatch converts '\\' to '/' on Windows, then squashes\n  // consequetive slashes, and finally splits on slash. this means that UNC format is lost, but can\n  // be detected from the original pattern.\n  var joinedSegments = literalSegments.join('/');\n  if (joinedSegments && process.platform == 'win32' && _startsWith(pattern.replace(/\\\\/g, '/'), '//')) {\n    joinedSegments = '/' + joinedSegments; // restore UNC format\n  }\n  // determine the find path\n  var findPath;\n  if (_isRooted(pattern)) {\n    // the pattern was rooted\n    findPath = joinedSegments;\n  } else if (joinedSegments) {\n    // the pattern was not rooted, and literal segments were found\n    findPath = _ensureRooted(defaultRoot, joinedSegments);\n  } else {\n    // the pattern was not rooted, and no literal segments were found\n    findPath = defaultRoot;\n  }\n  // clean up the path\n  if (findPath) {\n    findPath = _getDirectoryName(_ensureRooted(findPath, '_')); // hack to remove unnecessary trailing slash\n    findPath = _normalizeSeparators(findPath); // normalize slashes\n  }\n\n  return {\n    adjustedPattern: _ensurePatternRooted(defaultRoot, pattern),\n    findPath: findPath,\n    statOnly: literalSegments.length == minimatchObj.set[0].length\n  };\n}\nexports._getFindInfoFromPattern = _getFindInfoFromPattern;\nfunction _ensurePatternRooted(root, p) {\n  if (!root) {\n    throw new Error('ensurePatternRooted() parameter \"root\" cannot be empty');\n  }\n  if (!p) {\n    throw new Error('ensurePatternRooted() parameter \"p\" cannot be empty');\n  }\n  if (_isRooted(p)) {\n    return p;\n  }\n  // normalize root\n  root = _normalizeSeparators(root);\n  // escape special glob characters\n  root = (process.platform == 'win32' ? root : root.replace(/\\\\/g, '\\\\\\\\') // escape '\\' on OSX/Linux\n  ).replace(/(\\[)(?=[^\\/]+\\])/g, '[[]') // escape '[' when ']' follows within the path segment\n  .replace(/\\?/g, '[?]') // escape '?'\n  .replace(/\\*/g, '[*]') // escape '*'\n  .replace(/\\+\\(/g, '[+](') // escape '+('\n  .replace(/@\\(/g, '[@](') // escape '@('\n  .replace(/!\\(/g, '[!]('); // escape '!('\n  return _ensureRooted(root, p);\n}\nexports._ensurePatternRooted = _ensurePatternRooted;\n//-------------------------------------------------------------------\n// Populate the vault with sensitive data.  Inputs and Endpoints\n//-------------------------------------------------------------------\nfunction _loadData() {\n  // in agent, prefer TempDirectory then workFolder.\n  // In interactive dev mode, it won't be\n  var keyPath = _getVariable(\"agent.TempDirectory\") || _getVariable(\"agent.workFolder\") || process.cwd();\n  exports._vault = new vm.Vault(keyPath);\n  exports._knownVariableMap = {};\n  _debug('loading inputs and endpoints');\n  var loaded = 0;\n  for (var envvar in process.env) {\n    if (_startsWith(envvar, 'INPUT_') || _startsWith(envvar, 'ENDPOINT_AUTH_') || _startsWith(envvar, 'SECUREFILE_TICKET_') || _startsWith(envvar, 'SECRET_') || _startsWith(envvar, 'VSTS_TASKVARIABLE_')) {\n      // Record the secret variable metadata. This is required by getVariable to know whether\n      // to retrieve the value from the vault. In a 2.104.1 agent or higher, this metadata will\n      // be overwritten when the VSTS_SECRET_VARIABLES env var is processed below.\n      if (_startsWith(envvar, 'SECRET_')) {\n        var variableName = envvar.substring('SECRET_'.length);\n        if (variableName) {\n          // This is technically not the variable name (has underscores instead of dots),\n          // but it's good enough to make getVariable work in a pre-2.104.1 agent where\n          // the VSTS_SECRET_VARIABLES env var is not defined.\n          exports._knownVariableMap[_getVariableKey(variableName)] = {\n            name: variableName,\n            secret: true\n          };\n        }\n      }\n      // store the secret\n      var value = process.env[envvar];\n      if (value) {\n        ++loaded;\n        _debug('loading ' + envvar);\n        exports._vault.storeSecret(envvar, value);\n        delete process.env[envvar];\n      }\n    }\n  }\n  _debug('loaded ' + loaded);\n  // store public variable metadata\n  var names;\n  try {\n    names = JSON.parse(process.env['VSTS_PUBLIC_VARIABLES'] || '[]');\n  } catch (err) {\n    throw new Error('Failed to parse VSTS_PUBLIC_VARIABLES as JSON. ' + err); // may occur during interactive testing\n  }\n\n  names.forEach(function (name) {\n    exports._knownVariableMap[_getVariableKey(name)] = {\n      name: name,\n      secret: false\n    };\n  });\n  delete process.env['VSTS_PUBLIC_VARIABLES'];\n  // store secret variable metadata\n  try {\n    names = JSON.parse(process.env['VSTS_SECRET_VARIABLES'] || '[]');\n  } catch (err) {\n    throw new Error('Failed to parse VSTS_SECRET_VARIABLES as JSON. ' + err); // may occur during interactive testing\n  }\n\n  names.forEach(function (name) {\n    exports._knownVariableMap[_getVariableKey(name)] = {\n      name: name,\n      secret: true\n    };\n  });\n  delete process.env['VSTS_SECRET_VARIABLES'];\n  // avoid loading twice (overwrites .taskkey)\n  global['_vsts_task_lib_loaded'] = true;\n}\nexports._loadData = _loadData;\n//--------------------------------------------------------------------------------\n// Internal path helpers.\n//--------------------------------------------------------------------------------\n/**\n * Defines if path is unc-path.\n *\n * @param path  a path to a file.\n * @returns     true if path starts with double backslash, otherwise returns false.\n */\nfunction _isUncPath(path) {\n  return /^\\\\\\\\[^\\\\]/.test(path);\n}\nexports._isUncPath = _isUncPath;\nfunction _ensureRooted(root, p) {\n  if (!root) {\n    throw new Error('ensureRooted() parameter \"root\" cannot be empty');\n  }\n  if (!p) {\n    throw new Error('ensureRooted() parameter \"p\" cannot be empty');\n  }\n  if (_isRooted(p)) {\n    return p;\n  }\n  if (process.platform == 'win32' && root.match(/^[A-Z]:$/i)) {\n    // e.g. C:\n    return root + p;\n  }\n  // ensure root ends with a separator\n  if (_endsWith(root, '/') || process.platform == 'win32' && _endsWith(root, '\\\\')) {\n    // root already ends with a separator\n  } else {\n    root += path.sep; // append separator\n  }\n\n  return root + p;\n}\nexports._ensureRooted = _ensureRooted;\n/**\n * Determines the parent path and trims trailing slashes (when safe). Path separators are normalized\n * in the result. This function works similar to the .NET System.IO.Path.GetDirectoryName() method.\n * For example, C:\\hello\\world\\ returns C:\\hello\\world (trailing slash removed). Returns empty when\n * no higher directory can be determined.\n */\nfunction _getDirectoryName(p) {\n  // short-circuit if empty\n  if (!p) {\n    return '';\n  }\n  // normalize separators\n  p = _normalizeSeparators(p);\n  // on Windows, the goal of this function is to match the behavior of\n  // [System.IO.Path]::GetDirectoryName(), e.g.\n  //      C:/             =>\n  //      C:/hello        => C:\\\n  //      C:/hello/       => C:\\hello\n  //      C:/hello/world  => C:\\hello\n  //      C:/hello/world/ => C:\\hello\\world\n  //      C:              =>\n  //      C:hello         => C:\n  //      C:hello/        => C:hello\n  //      /               =>\n  //      /hello          => \\\n  //      /hello/         => \\hello\n  //      //hello         =>\n  //      //hello/        =>\n  //      //hello/world   =>\n  //      //hello/world/  => \\\\hello\\world\n  //\n  // unfortunately, path.dirname() can't simply be used. for example, on Windows\n  // it yields different results from Path.GetDirectoryName:\n  //      C:/             => C:/\n  //      C:/hello        => C:/\n  //      C:/hello/       => C:/\n  //      C:/hello/world  => C:/hello\n  //      C:/hello/world/ => C:/hello\n  //      C:              => C:\n  //      C:hello         => C:\n  //      C:hello/        => C:\n  //      /               => /\n  //      /hello          => /\n  //      /hello/         => /\n  //      //hello         => /\n  //      //hello/        => /\n  //      //hello/world   => //hello/world\n  //      //hello/world/  => //hello/world/\n  //      //hello/world/again => //hello/world/\n  //      //hello/world/again/ => //hello/world/\n  //      //hello/world/again/again => //hello/world/again\n  //      //hello/world/again/again/ => //hello/world/again\n  if (process.platform == 'win32') {\n    if (/^[A-Z]:\\\\?[^\\\\]+$/i.test(p)) {\n      // e.g. C:\\hello or C:hello\n      return p.charAt(2) == '\\\\' ? p.substring(0, 3) : p.substring(0, 2);\n    } else if (/^[A-Z]:\\\\?$/i.test(p)) {\n      // e.g. C:\\ or C:\n      return '';\n    }\n    var lastSlashIndex = p.lastIndexOf('\\\\');\n    if (lastSlashIndex < 0) {\n      // file name only\n      return '';\n    } else if (p == '\\\\') {\n      // relative root\n      return '';\n    } else if (lastSlashIndex == 0) {\n      // e.g. \\\\hello\n      return '\\\\';\n    } else if (/^\\\\\\\\[^\\\\]+(\\\\[^\\\\]*)?$/.test(p)) {\n      // UNC root, e.g. \\\\hello or \\\\hello\\ or \\\\hello\\world\n      return '';\n    }\n    return p.substring(0, lastSlashIndex); // e.g. hello\\world => hello or hello\\world\\ => hello\\world\n    // note, this means trailing slashes for non-root directories\n    // (i.e. not C:\\, \\, or \\\\unc\\) will simply be removed.\n  }\n  // OSX/Linux\n  if (p.indexOf('/') < 0) {\n    // file name only\n    return '';\n  } else if (p == '/') {\n    return '';\n  } else if (_endsWith(p, '/')) {\n    return p.substring(0, p.length - 1);\n  }\n  return path.dirname(p);\n}\nexports._getDirectoryName = _getDirectoryName;\n/**\n * On OSX/Linux, true if path starts with '/'. On Windows, true for paths like:\n * \\, \\hello, \\\\hello\\share, C:, and C:\\hello (and corresponding alternate separator cases).\n */\nfunction _isRooted(p) {\n  p = _normalizeSeparators(p);\n  if (!p) {\n    throw new Error('isRooted() parameter \"p\" cannot be empty');\n  }\n  if (process.platform == 'win32') {\n    return _startsWith(p, '\\\\') ||\n    // e.g. \\ or \\hello or \\\\hello\n    /^[A-Z]:/i.test(p); // e.g. C: or C:\\hello\n  }\n\n  return _startsWith(p, '/'); // e.g. /hello\n}\n\nexports._isRooted = _isRooted;\nfunction _normalizeSeparators(p) {\n  p = p || '';\n  if (process.platform == 'win32') {\n    // convert slashes on Windows\n    p = p.replace(/\\//g, '\\\\');\n    // remove redundant slashes\n    var isUnc = /^\\\\\\\\+[^\\\\]/.test(p); // e.g. \\\\hello\n    return (isUnc ? '\\\\' : '') + p.replace(/\\\\\\\\+/g, '\\\\'); // preserve leading // for UNC\n  }\n  // remove redundant slashes\n  return p.replace(/\\/\\/+/g, '/');\n}\nexports._normalizeSeparators = _normalizeSeparators;\n//-----------------------------------------------------\n// Expose proxy information to vsts-node-api\n//-----------------------------------------------------\nfunction _exposeProxySettings() {\n  var proxyUrl = _getVariable('Agent.ProxyUrl');\n  if (proxyUrl && proxyUrl.length > 0) {\n    var proxyUsername = _getVariable('Agent.ProxyUsername');\n    var proxyPassword = _getVariable('Agent.ProxyPassword');\n    var proxyBypassHostsJson = _getVariable('Agent.ProxyBypassList');\n    global['_vsts_task_lib_proxy_url'] = proxyUrl;\n    global['_vsts_task_lib_proxy_username'] = proxyUsername;\n    global['_vsts_task_lib_proxy_bypass'] = proxyBypassHostsJson;\n    global['_vsts_task_lib_proxy_password'] = _exposeTaskLibSecret('proxy', proxyPassword || '');\n    _debug('expose agent proxy configuration.');\n    global['_vsts_task_lib_proxy'] = true;\n  }\n}\nexports._exposeProxySettings = _exposeProxySettings;\n//-----------------------------------------------------\n// Expose certificate information to vsts-node-api\n//-----------------------------------------------------\nfunction _exposeCertSettings() {\n  var ca = _getVariable('Agent.CAInfo');\n  if (ca) {\n    global['_vsts_task_lib_cert_ca'] = ca;\n  }\n  var clientCert = _getVariable('Agent.ClientCert');\n  if (clientCert) {\n    var clientCertKey = _getVariable('Agent.ClientCertKey');\n    var clientCertArchive = _getVariable('Agent.ClientCertArchive');\n    var clientCertPassword = _getVariable('Agent.ClientCertPassword');\n    global['_vsts_task_lib_cert_clientcert'] = clientCert;\n    global['_vsts_task_lib_cert_key'] = clientCertKey;\n    global['_vsts_task_lib_cert_archive'] = clientCertArchive;\n    global['_vsts_task_lib_cert_passphrase'] = _exposeTaskLibSecret('cert', clientCertPassword || '');\n  }\n  if (ca || clientCert) {\n    _debug('expose agent certificate configuration.');\n    global['_vsts_task_lib_cert'] = true;\n  }\n  var skipCertValidation = _getVariable('Agent.SkipCertValidation') || 'false';\n  if (skipCertValidation) {\n    global['_vsts_task_lib_skip_cert_validation'] = skipCertValidation.toUpperCase() === 'TRUE';\n  }\n}\nexports._exposeCertSettings = _exposeCertSettings;\n// We store the encryption key on disk and hold the encrypted content and key file in memory\n// return base64encoded<keyFilePath>:base64encoded<encryptedContent>\n// downstream vsts-node-api will retrieve the secret later\nfunction _exposeTaskLibSecret(keyFile, secret) {\n  if (secret) {\n    var encryptKey = crypto.randomBytes(256);\n    var cipher = crypto.createCipher(\"aes-256-ctr\", encryptKey);\n    var encryptedContent = cipher.update(secret, \"utf8\", \"hex\");\n    encryptedContent += cipher.final(\"hex\");\n    var storageFile = path.join(_getVariable('Agent.TempDirectory') || _getVariable(\"agent.workFolder\") || process.cwd(), keyFile);\n    fs.writeFileSync(storageFile, encryptKey.toString('base64'), {\n      encoding: 'utf8'\n    });\n    return new Buffer(storageFile).toString('base64') + ':' + new Buffer(encryptedContent).toString('base64');\n  }\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\azure-pipelines-task-lib\\internal.js");

/***/ }),

/***/ "./node_modules/azure-pipelines-task-lib/node_modules/brace-expansion/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/azure-pipelines-task-lib/node_modules/brace-expansion/index.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar concatMap = __webpack_require__(/*! concat-map */ \"./node_modules/concat-map/index.js\");\nvar balanced = __webpack_require__(/*! balanced-match */ \"./node_modules/balanced-match/index.js\");\nmodule.exports = expandTop;\nvar escSlash = '\\0SLASH' + Math.random() + '\\0';\nvar escOpen = '\\0OPEN' + Math.random() + '\\0';\nvar escClose = '\\0CLOSE' + Math.random() + '\\0';\nvar escComma = '\\0COMMA' + Math.random() + '\\0';\nvar escPeriod = '\\0PERIOD' + Math.random() + '\\0';\nfunction numeric(str) {\n  return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);\n}\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash).split('\\\\{').join(escOpen).split('\\\\}').join(escClose).split('\\\\,').join(escComma).split('\\\\.').join(escPeriod);\n}\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\').split(escOpen).join('{').split(escClose).join('}').split(escComma).join(',').split(escPeriod).join('.');\n}\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str) return [''];\n  var parts = [];\n  var m = balanced('{', '}', str);\n  if (!m) return str.split(',');\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n  p[p.length - 1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length - 1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n  parts.push.apply(parts, p);\n  return parts;\n}\nfunction expandTop(str) {\n  if (!str) return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\nfunction identity(e) {\n  return e;\n}\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\nfunction expand(str, isTop) {\n  var expansions = [];\n  var m = balanced('{', '}', str);\n  if (!m || /\\$$/.test(m.pre)) return [str];\n  var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isSequence = isNumericSequence || isAlphaSequence;\n  var isOptions = m.body.indexOf(',') >= 0;\n  if (!isSequence && !isOptions) {\n    // {a},b}\n    if (m.post.match(/,.*\\}/)) {\n      str = m.pre + '{' + m.body + escClose + m.post;\n      return expand(str);\n    }\n    return [str];\n  }\n  var n;\n  if (isSequence) {\n    n = m.body.split(/\\.\\./);\n  } else {\n    n = parseCommaParts(m.body);\n    if (n.length === 1) {\n      // x{{a,b}}y ==> x{a}y x{b}y\n      n = expand(n[0], false).map(embrace);\n      if (n.length === 1) {\n        var post = m.post.length ? expand(m.post, false) : [''];\n        return post.map(function (p) {\n          return m.pre + n[0] + p;\n        });\n      }\n    }\n  }\n\n  // at this point, n is the parts, and we know it's not a comma set\n  // with a single entry.\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length ? expand(m.post, false) : [''];\n  var N;\n  if (isSequence) {\n    var x = numeric(n[0]);\n    var y = numeric(n[1]);\n    var width = Math.max(n[0].length, n[1].length);\n    var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;\n    var test = lte;\n    var reverse = y < x;\n    if (reverse) {\n      incr *= -1;\n      test = gte;\n    }\n    var pad = n.some(isPadded);\n    N = [];\n    for (var i = x; test(i, y); i += incr) {\n      var c;\n      if (isAlphaSequence) {\n        c = String.fromCharCode(i);\n        if (c === '\\\\') c = '';\n      } else {\n        c = String(i);\n        if (pad) {\n          var need = width - c.length;\n          if (need > 0) {\n            var z = new Array(need + 1).join('0');\n            if (i < 0) c = '-' + z + c.slice(1);else c = z + c;\n          }\n        }\n      }\n      N.push(c);\n    }\n  } else {\n    N = concatMap(n, function (el) {\n      return expand(el, false);\n    });\n  }\n  for (var j = 0; j < N.length; j++) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + N[j] + post[k];\n      if (!isTop || isSequence || expansion) expansions.push(expansion);\n    }\n  }\n  return expansions;\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\azure-pipelines-task-lib\\node_modules\\brace-expansion\\index.js");

/***/ }),

/***/ "./node_modules/azure-pipelines-task-lib/node_modules/minimatch/minimatch.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/azure-pipelines-task-lib/node_modules/minimatch/minimatch.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = minimatch;\nminimatch.Minimatch = Minimatch;\nconst path = (() => {\n  try {\n    return __webpack_require__(/*! path */ \"path\");\n  } catch (e) {}\n})() || {\n  sep: '/'\n};\nminimatch.sep = path.sep;\nconst GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};\nconst expand = __webpack_require__(/*! brace-expansion */ \"./node_modules/azure-pipelines-task-lib/node_modules/brace-expansion/index.js\");\nconst plTypes = {\n  '!': {\n    open: '(?:(?!(?:',\n    close: '))[^/]*?)'\n  },\n  '?': {\n    open: '(?:',\n    close: ')?'\n  },\n  '+': {\n    open: '(?:',\n    close: ')+'\n  },\n  '*': {\n    open: '(?:',\n    close: ')*'\n  },\n  '@': {\n    open: '(?:',\n    close: ')'\n  }\n};\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]';\n\n// * => any number of characters\nconst star = qmark + '*?';\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?';\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?';\n\n// characters that need to be escaped in RegExp.\nconst reSpecials = charSet('().*{}+?[]^$\\\\!');\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet(s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true;\n    return set;\n  }, {});\n}\n\n// normalizes slashes.\nconst slashSplit = /\\/+/;\nminimatch.filter = filter;\nfunction filter(pattern, options) {\n  options = options || {};\n  return function (p, i, list) {\n    return minimatch(p, pattern, options);\n  };\n}\nfunction ext(a, b) {\n  a = a || {};\n  b = b || {};\n  const t = {};\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k];\n  });\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k];\n  });\n  return t;\n}\nminimatch.defaults = function (def) {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch;\n  }\n  const orig = minimatch;\n  const m = function minimatch(p, pattern, options) {\n    return orig(p, pattern, ext(def, options));\n  };\n  m.Minimatch = function Minimatch(pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options));\n  };\n  m.Minimatch.defaults = options => {\n    return orig.defaults(ext(def, options)).Minimatch;\n  };\n  m.filter = function filter(pattern, options) {\n    return orig.filter(pattern, ext(def, options));\n  };\n  m.defaults = function defaults(options) {\n    return orig.defaults(ext(def, options));\n  };\n  m.makeRe = function makeRe(pattern, options) {\n    return orig.makeRe(pattern, ext(def, options));\n  };\n  m.braceExpand = function braceExpand(pattern, options) {\n    return orig.braceExpand(pattern, ext(def, options));\n  };\n  m.match = function (list, pattern, options) {\n    return orig.match(list, pattern, ext(def, options));\n  };\n  return m;\n};\nMinimatch.defaults = function (def) {\n  return minimatch.defaults(def).Minimatch;\n};\nfunction minimatch(p, pattern, options) {\n  assertValidPattern(pattern);\n  if (!options) options = {};\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false;\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === '') return p === '';\n  return new Minimatch(pattern, options).match(p);\n}\nfunction Minimatch(pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options);\n  }\n  assertValidPattern(pattern);\n  if (!options) options = {};\n  pattern = pattern.trim();\n\n  // windows support: need to use /, not \\\n  if (path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/');\n  }\n  this.options = options;\n  this.set = [];\n  this.pattern = pattern;\n  this.regexp = null;\n  this.negate = false;\n  this.comment = false;\n  this.empty = false;\n\n  // make the set of regexps etc.\n  this.make();\n}\nMinimatch.prototype.debug = function () {};\nMinimatch.prototype.make = make;\nfunction make() {\n  // don't do it more than once.\n  if (this._made) return;\n  var pattern = this.pattern;\n  var options = this.options;\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true;\n    return;\n  }\n  if (!pattern) {\n    this.empty = true;\n    return;\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate();\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand();\n  if (options.debug) this.debug = console.error;\n  this.debug(this.pattern, set);\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit);\n  });\n  this.debug(this.pattern, set);\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this);\n  }, this);\n  this.debug(this.pattern, set);\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1;\n  });\n  this.debug(this.pattern, set);\n  this.set = set;\n}\nMinimatch.prototype.parseNegate = parseNegate;\nfunction parseNegate() {\n  var pattern = this.pattern;\n  var negate = false;\n  var options = this.options;\n  var negateOffset = 0;\n  if (options.nonegate) return;\n  for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === '!'; i++) {\n    negate = !negate;\n    negateOffset++;\n  }\n  if (negateOffset) this.pattern = pattern.substr(negateOffset);\n  this.negate = negate;\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options);\n};\nMinimatch.prototype.braceExpand = braceExpand;\nfunction braceExpand(pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options;\n    } else {\n      options = {};\n    }\n  }\n  pattern = typeof pattern === 'undefined' ? this.pattern : pattern;\n  assertValidPattern(pattern);\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern];\n  }\n  return expand(pattern);\n}\nconst MAX_PATTERN_LENGTH = 1024 * 64;\nconst assertValidPattern = pattern => {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern');\n  }\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long');\n  }\n};\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse;\nconst SUBPARSE = {};\nfunction parse(pattern, isSub) {\n  assertValidPattern(pattern);\n  var options = this.options;\n\n  // shortcuts\n  if (!options.noglobstar && pattern === '**') return GLOBSTAR;\n  if (pattern === '') return '';\n  var re = '';\n  var hasMagic = false;\n  var escaping = false;\n  // ? => one single character\n  var patternListStack = [];\n  var negativeLists = [];\n  var stateChar;\n  var inClass = false;\n  var reClassStart = -1;\n  var classStart = -1;\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))' : '(?!\\\\.)';\n  var self = this;\n  function clearStateChar() {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star;\n          hasMagic = true;\n          break;\n        case '?':\n          re += qmark;\n          hasMagic = true;\n          break;\n        default:\n          re += '\\\\' + stateChar;\n          break;\n      }\n      self.debug('clearStateChar %j %j', stateChar, re);\n      stateChar = false;\n    }\n  }\n  for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c);\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c;\n      escaping = false;\n      continue;\n    }\n    switch (c) {\n      case '/':\n        /* istanbul ignore next */{\n          // completely not allowed, even escaped.\n          // Should already be path-split by now.\n          return false;\n        }\n      case '\\\\':\n        clearStateChar();\n        escaping = true;\n        continue;\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c);\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class');\n          if (c === '!' && i === classStart + 1) c = '^';\n          re += c;\n          continue;\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar);\n        clearStateChar();\n        stateChar = c;\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar();\n        continue;\n      case '(':\n        if (inClass) {\n          re += '(';\n          continue;\n        }\n        if (!stateChar) {\n          re += '\\\\(';\n          continue;\n        }\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        });\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:';\n        this.debug('plType %j %j', stateChar, re);\n        stateChar = false;\n        continue;\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)';\n          continue;\n        }\n        clearStateChar();\n        hasMagic = true;\n        var pl = patternListStack.pop();\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close;\n        if (pl.type === '!') {\n          negativeLists.push(pl);\n        }\n        pl.reEnd = re.length;\n        continue;\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|';\n          escaping = false;\n          continue;\n        }\n        clearStateChar();\n        re += '|';\n        continue;\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar();\n        if (inClass) {\n          re += '\\\\' + c;\n          continue;\n        }\n        inClass = true;\n        classStart = i;\n        reClassStart = re.length;\n        re += c;\n        continue;\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c;\n          escaping = false;\n          continue;\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        if (inClass) {\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          var cs = pattern.substring(classStart + 1, i);\n          try {\n            RegExp('[' + cs + ']');\n          } catch (er) {\n            // not a valid class!\n            var sp = this.parse(cs, SUBPARSE);\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]';\n            hasMagic = hasMagic || sp[1];\n            inClass = false;\n            continue;\n          }\n        }\n\n        // finish up the class.\n        hasMagic = true;\n        inClass = false;\n        re += c;\n        continue;\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar();\n        if (escaping) {\n          // no need\n          escaping = false;\n        } else if (reSpecials[c] && !(c === '^' && inClass)) {\n          re += '\\\\';\n        }\n        re += c;\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1);\n    sp = this.parse(cs, SUBPARSE);\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0];\n    hasMagic = hasMagic || sp[1];\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length);\n    this.debug('setting tail', re, pl);\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\';\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|';\n    });\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re);\n    var t = pl.type === '*' ? star : pl.type === '?' ? qmark : '\\\\' + pl.type;\n    hasMagic = true;\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail;\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar();\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\';\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false;\n  switch (re.charAt(0)) {\n    case '.':\n    case '[':\n    case '(':\n      addPatternStart = true;\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n];\n    var nlBefore = re.slice(0, nl.reStart);\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);\n    var nlAfter = re.slice(nl.reEnd);\n    nlLast += nlAfter;\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1;\n    var cleanAfter = nlAfter;\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '');\n    }\n    nlAfter = cleanAfter;\n    var dollar = '';\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$';\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;\n    re = newRe;\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re;\n  }\n  if (addPatternStart) {\n    re = patternStart + re;\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic];\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern);\n  }\n  var flags = options.nocase ? 'i' : '';\n  try {\n    var regExp = new RegExp('^' + re + '$', flags);\n  } catch (er) /* istanbul ignore next - should be impossible */{\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.');\n  }\n  regExp._glob = pattern;\n  regExp._src = re;\n  return regExp;\n}\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe();\n};\nMinimatch.prototype.makeRe = makeRe;\nfunction makeRe() {\n  if (this.regexp || this.regexp === false) return this.regexp;\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set;\n  if (!set.length) {\n    this.regexp = false;\n    return this.regexp;\n  }\n  var options = this.options;\n  var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;\n  var flags = options.nocase ? 'i' : '';\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return p === GLOBSTAR ? twoStar : typeof p === 'string' ? regExpEscape(p) : p._src;\n    }).join('\\\\\\/');\n  }).join('|');\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$';\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$';\n  try {\n    this.regexp = new RegExp(re, flags);\n  } catch (ex) /* istanbul ignore next - should be impossible */{\n    this.regexp = false;\n  }\n  return this.regexp;\n}\nminimatch.match = function (list, pattern, options) {\n  options = options || {};\n  const mm = new Minimatch(pattern, options);\n  list = list.filter(function (f) {\n    return mm.match(f);\n  });\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern);\n  }\n  return list;\n};\nMinimatch.prototype.match = match;\nfunction match(f, partial) {\n  this.debug('match', f, this.pattern);\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false;\n  if (this.empty) return f === '';\n  if (f === '/' && partial) return true;\n  var options = this.options;\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/');\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit);\n  this.debug(this.pattern, 'split', f);\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set;\n  this.debug(this.pattern, 'set', set);\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename;\n  var i;\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i];\n    if (filename) break;\n  }\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i];\n    var file = f;\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename];\n    }\n    var hit = this.matchOne(file, pattern, partial);\n    if (hit) {\n      if (options.flipNegate) return true;\n      return !this.negate;\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false;\n  return this.negate;\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options;\n  this.debug('matchOne', {\n    'this': this,\n    file: file,\n    pattern: pattern\n  });\n  this.debug('matchOne', file.length, pattern.length);\n  for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n    this.debug('matchOne loop');\n    var p = pattern[pi];\n    var f = file[fi];\n    this.debug(pattern, p, f);\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    /* istanbul ignore if */\n    if (p === false) return false;\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f]);\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi;\n      var pr = pi + 1;\n      if (pr === pl) {\n        this.debug('** at the end');\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' || !options.dot && file[fi].charAt(0) === '.') return false;\n        }\n        return true;\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr];\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee);\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee);\n          // found a match.\n          return true;\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' || !options.dot && swallowee.charAt(0) === '.') {\n            this.debug('dot detected!', file, fr, pattern, pr);\n            break;\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue');\n          fr++;\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      /* istanbul ignore if */\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n        if (fr === fl) return true;\n      }\n      return false;\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit;\n    if (typeof p === 'string') {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase();\n      } else {\n        hit = f === p;\n      }\n      this.debug('string match', p, f, hit);\n    } else {\n      hit = f.match(p);\n      this.debug('pattern match', p, f, hit);\n    }\n    if (!hit) return false;\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true;\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial;\n  } else /* istanbul ignore else */if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      return fi === fl - 1 && file[fi] === '';\n    }\n\n  // should be unreachable.\n  /* istanbul ignore next */\n  throw new Error('wtf?');\n};\n\n// replace stuff like \\* with *\nfunction globUnescape(s) {\n  return s.replace(/\\\\(.)/g, '$1');\n}\nfunction regExpEscape(s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\azure-pipelines-task-lib\\node_modules\\minimatch\\minimatch.js");

/***/ }),

/***/ "./node_modules/azure-pipelines-task-lib/node_modules/semver/semver.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/azure-pipelines-task-lib/node_modules/semver/semver.js ***!
  \*****************************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\n\nexports = module.exports = SemVer;\nvar debug;\n/* istanbul ignore next */\nif (typeof process === 'object' && process.env && process.env.NODE_DEBUG && /\\bsemver\\b/i.test(process.env.NODE_DEBUG)) {\n  debug = function debug() {\n    var args = Array.prototype.slice.call(arguments, 0);\n    args.unshift('SEMVER');\n    console.log.apply(console, args);\n  };\n} else {\n  debug = function debug() {};\n}\n\n// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nexports.SEMVER_SPEC_VERSION = '2.0.0';\nvar MAX_LENGTH = 256;\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */9007199254740991;\n\n// Max safe segment length for coercion.\nvar MAX_SAFE_COMPONENT_LENGTH = 16;\nvar MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;\n\n// The actual regexps go on exports.re\nvar re = exports.re = [];\nvar safeRe = exports.safeRe = [];\nvar src = exports.src = [];\nvar R = 0;\nvar LETTERDASHNUMBER = '[a-zA-Z0-9-]';\n\n// Replace some greedy regex tokens to prevent regex dos issues. These regex are\n// used internally via the safeRe object since all inputs in this library get\n// normalized first to trim and collapse all extra whitespace. The original\n// regexes are exported for userland consumption and lower level usage. A\n// future breaking change could export the safer regex only with a note that\n// all input should have extra whitespace removed.\nvar safeRegexReplacements = [['\\\\s', 1], ['\\\\d', MAX_LENGTH], [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]];\nfunction makeSafeRe(value) {\n  for (var i = 0; i < safeRegexReplacements.length; i++) {\n    var token = safeRegexReplacements[i][0];\n    var max = safeRegexReplacements[i][1];\n    value = value.split(token + '*').join(token + '{0,' + max + '}').split(token + '+').join(token + '{1,' + max + '}');\n  }\n  return value;\n}\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\nvar NUMERICIDENTIFIER = R++;\nsrc[NUMERICIDENTIFIER] = '0|[1-9]\\\\d*';\nvar NUMERICIDENTIFIERLOOSE = R++;\nsrc[NUMERICIDENTIFIERLOOSE] = '\\\\d+';\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\nvar NONNUMERICIDENTIFIER = R++;\nsrc[NONNUMERICIDENTIFIER] = '\\\\d*[a-zA-Z-]' + LETTERDASHNUMBER + '*';\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\nvar MAINVERSION = R++;\nsrc[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\\\.' + '(' + src[NUMERICIDENTIFIER] + ')\\\\.' + '(' + src[NUMERICIDENTIFIER] + ')';\nvar MAINVERSIONLOOSE = R++;\nsrc[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' + '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' + '(' + src[NUMERICIDENTIFIERLOOSE] + ')';\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\nvar PRERELEASEIDENTIFIER = R++;\nsrc[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] + '|' + src[NONNUMERICIDENTIFIER] + ')';\nvar PRERELEASEIDENTIFIERLOOSE = R++;\nsrc[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] + '|' + src[NONNUMERICIDENTIFIER] + ')';\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\nvar PRERELEASE = R++;\nsrc[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] + '(?:\\\\.' + src[PRERELEASEIDENTIFIER] + ')*))';\nvar PRERELEASELOOSE = R++;\nsrc[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] + '(?:\\\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\nvar BUILDIDENTIFIER = R++;\nsrc[BUILDIDENTIFIER] = LETTERDASHNUMBER + '+';\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\nvar BUILD = R++;\nsrc[BUILD] = '(?:\\\\+(' + src[BUILDIDENTIFIER] + '(?:\\\\.' + src[BUILDIDENTIFIER] + ')*))';\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\nvar FULL = R++;\nvar FULLPLAIN = 'v?' + src[MAINVERSION] + src[PRERELEASE] + '?' + src[BUILD] + '?';\nsrc[FULL] = '^' + FULLPLAIN + '$';\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\nvar LOOSEPLAIN = '[v=\\\\s]*' + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + '?' + src[BUILD] + '?';\nvar LOOSE = R++;\nsrc[LOOSE] = '^' + LOOSEPLAIN + '$';\nvar GTLT = R++;\nsrc[GTLT] = '((?:<|>)?=?)';\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\nvar XRANGEIDENTIFIERLOOSE = R++;\nsrc[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\\\*';\nvar XRANGEIDENTIFIER = R++;\nsrc[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\\\*';\nvar XRANGEPLAIN = R++;\nsrc[XRANGEPLAIN] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIER] + ')' + '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' + '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' + '(?:' + src[PRERELEASE] + ')?' + src[BUILD] + '?' + ')?)?';\nvar XRANGEPLAINLOOSE = R++;\nsrc[XRANGEPLAINLOOSE] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[PRERELEASELOOSE] + ')?' + src[BUILD] + '?' + ')?)?';\nvar XRANGE = R++;\nsrc[XRANGE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAIN] + '$';\nvar XRANGELOOSE = R++;\nsrc[XRANGELOOSE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAINLOOSE] + '$';\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\nvar COERCE = R++;\nsrc[COERCE] = '(?:^|[^\\\\d])' + '(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' + '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:$|[^\\\\d])';\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\nvar LONETILDE = R++;\nsrc[LONETILDE] = '(?:~>?)';\nvar TILDETRIM = R++;\nsrc[TILDETRIM] = '(\\\\s*)' + src[LONETILDE] + '\\\\s+';\nre[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');\nsafeRe[TILDETRIM] = new RegExp(makeSafeRe(src[TILDETRIM]), 'g');\nvar tildeTrimReplace = '$1~';\nvar TILDE = R++;\nsrc[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';\nvar TILDELOOSE = R++;\nsrc[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\nvar LONECARET = R++;\nsrc[LONECARET] = '(?:\\\\^)';\nvar CARETTRIM = R++;\nsrc[CARETTRIM] = '(\\\\s*)' + src[LONECARET] + '\\\\s+';\nre[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');\nsafeRe[CARETTRIM] = new RegExp(makeSafeRe(src[CARETTRIM]), 'g');\nvar caretTrimReplace = '$1^';\nvar CARET = R++;\nsrc[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';\nvar CARETLOOSE = R++;\nsrc[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\nvar COMPARATORLOOSE = R++;\nsrc[COMPARATORLOOSE] = '^' + src[GTLT] + '\\\\s*(' + LOOSEPLAIN + ')$|^$';\nvar COMPARATOR = R++;\nsrc[COMPARATOR] = '^' + src[GTLT] + '\\\\s*(' + FULLPLAIN + ')$|^$';\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\nvar COMPARATORTRIM = R++;\nsrc[COMPARATORTRIM] = '(\\\\s*)' + src[GTLT] + '\\\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';\n\n// this one has to use the /g flag\nre[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');\nsafeRe[COMPARATORTRIM] = new RegExp(makeSafeRe(src[COMPARATORTRIM]), 'g');\nvar comparatorTrimReplace = '$1$2$3';\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\nvar HYPHENRANGE = R++;\nsrc[HYPHENRANGE] = '^\\\\s*(' + src[XRANGEPLAIN] + ')' + '\\\\s+-\\\\s+' + '(' + src[XRANGEPLAIN] + ')' + '\\\\s*$';\nvar HYPHENRANGELOOSE = R++;\nsrc[HYPHENRANGELOOSE] = '^\\\\s*(' + src[XRANGEPLAINLOOSE] + ')' + '\\\\s+-\\\\s+' + '(' + src[XRANGEPLAINLOOSE] + ')' + '\\\\s*$';\n\n// Star ranges basically just allow anything at all.\nvar STAR = R++;\nsrc[STAR] = '(<|>)?=?\\\\s*\\\\*';\n\n// Compile to actual regexp objects.\n// All are flag-free, unless they were created above with a flag.\nfor (var i = 0; i < R; i++) {\n  debug(i, src[i]);\n  if (!re[i]) {\n    re[i] = new RegExp(src[i]);\n\n    // Replace all greedy whitespace to prevent regex dos issues. These regex are\n    // used internally via the safeRe object since all inputs in this library get\n    // normalized first to trim and collapse all extra whitespace. The original\n    // regexes are exported for userland consumption and lower level usage. A\n    // future breaking change could export the safer regex only with a note that\n    // all input should have extra whitespace removed.\n    safeRe[i] = new RegExp(makeSafeRe(src[i]));\n  }\n}\nexports.parse = parse;\nfunction parse(version, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    };\n  }\n  if (version instanceof SemVer) {\n    return version;\n  }\n  if (typeof version !== 'string') {\n    return null;\n  }\n  if (version.length > MAX_LENGTH) {\n    return null;\n  }\n  var r = options.loose ? safeRe[LOOSE] : safeRe[FULL];\n  if (!r.test(version)) {\n    return null;\n  }\n  try {\n    return new SemVer(version, options);\n  } catch (er) {\n    return null;\n  }\n}\nexports.valid = valid;\nfunction valid(version, options) {\n  var v = parse(version, options);\n  return v ? v.version : null;\n}\nexports.clean = clean;\nfunction clean(version, options) {\n  var s = parse(version.trim().replace(/^[=v]+/, ''), options);\n  return s ? s.version : null;\n}\nexports.SemVer = SemVer;\nfunction SemVer(version, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    };\n  }\n  if (version instanceof SemVer) {\n    if (version.loose === options.loose) {\n      return version;\n    } else {\n      version = version.version;\n    }\n  } else if (typeof version !== 'string') {\n    throw new TypeError('Invalid Version: ' + version);\n  }\n  if (version.length > MAX_LENGTH) {\n    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');\n  }\n  if (!(this instanceof SemVer)) {\n    return new SemVer(version, options);\n  }\n  debug('SemVer', version, options);\n  this.options = options;\n  this.loose = !!options.loose;\n  var m = version.trim().match(options.loose ? safeRe[LOOSE] : safeRe[FULL]);\n  if (!m) {\n    throw new TypeError('Invalid Version: ' + version);\n  }\n  this.raw = version;\n\n  // these are actually numbers\n  this.major = +m[1];\n  this.minor = +m[2];\n  this.patch = +m[3];\n  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n    throw new TypeError('Invalid major version');\n  }\n  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n    throw new TypeError('Invalid minor version');\n  }\n  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n    throw new TypeError('Invalid patch version');\n  }\n\n  // numberify any prerelease numeric ids\n  if (!m[4]) {\n    this.prerelease = [];\n  } else {\n    this.prerelease = m[4].split('.').map(function (id) {\n      if (/^[0-9]+$/.test(id)) {\n        var num = +id;\n        if (num >= 0 && num < MAX_SAFE_INTEGER) {\n          return num;\n        }\n      }\n      return id;\n    });\n  }\n  this.build = m[5] ? m[5].split('.') : [];\n  this.format();\n}\nSemVer.prototype.format = function () {\n  this.version = this.major + '.' + this.minor + '.' + this.patch;\n  if (this.prerelease.length) {\n    this.version += '-' + this.prerelease.join('.');\n  }\n  return this.version;\n};\nSemVer.prototype.toString = function () {\n  return this.version;\n};\nSemVer.prototype.compare = function (other) {\n  debug('SemVer.compare', this.version, this.options, other);\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options);\n  }\n  return this.compareMain(other) || this.comparePre(other);\n};\nSemVer.prototype.compareMain = function (other) {\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options);\n  }\n  return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);\n};\nSemVer.prototype.comparePre = function (other) {\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options);\n  }\n\n  // NOT having a prerelease is > having one\n  if (this.prerelease.length && !other.prerelease.length) {\n    return -1;\n  } else if (!this.prerelease.length && other.prerelease.length) {\n    return 1;\n  } else if (!this.prerelease.length && !other.prerelease.length) {\n    return 0;\n  }\n  var i = 0;\n  do {\n    var a = this.prerelease[i];\n    var b = other.prerelease[i];\n    debug('prerelease compare', i, a, b);\n    if (a === undefined && b === undefined) {\n      return 0;\n    } else if (b === undefined) {\n      return 1;\n    } else if (a === undefined) {\n      return -1;\n    } else if (a === b) {\n      continue;\n    } else {\n      return compareIdentifiers(a, b);\n    }\n  } while (++i);\n};\n\n// preminor will bump the version up to the next minor release, and immediately\n// down to pre-release. premajor and prepatch work the same way.\nSemVer.prototype.inc = function (release, identifier) {\n  switch (release) {\n    case 'premajor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor = 0;\n      this.major++;\n      this.inc('pre', identifier);\n      break;\n    case 'preminor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor++;\n      this.inc('pre', identifier);\n      break;\n    case 'prepatch':\n      // If this is already a prerelease, it will bump to the next version\n      // drop any prereleases that might already exist, since they are not\n      // relevant at this point.\n      this.prerelease.length = 0;\n      this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n    // If the input is a non-prerelease version, this acts the same as\n    // prepatch.\n    case 'prerelease':\n      if (this.prerelease.length === 0) {\n        this.inc('patch', identifier);\n      }\n      this.inc('pre', identifier);\n      break;\n    case 'major':\n      // If this is a pre-major version, bump up to the same major version.\n      // Otherwise increment major.\n      // 1.0.0-5 bumps to 1.0.0\n      // 1.1.0 bumps to 2.0.0\n      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {\n        this.major++;\n      }\n      this.minor = 0;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'minor':\n      // If this is a pre-minor version, bump up to the same minor version.\n      // Otherwise increment minor.\n      // 1.2.0-5 bumps to 1.2.0\n      // 1.2.1 bumps to 1.3.0\n      if (this.patch !== 0 || this.prerelease.length === 0) {\n        this.minor++;\n      }\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'patch':\n      // If this is not a pre-release version, it will increment the patch.\n      // If it is a pre-release it will bump up to the same patch version.\n      // 1.2.0-5 patches to 1.2.0\n      // 1.2.0 patches to 1.2.1\n      if (this.prerelease.length === 0) {\n        this.patch++;\n      }\n      this.prerelease = [];\n      break;\n    // This probably shouldn't be used publicly.\n    // 1.0.0 \"pre\" would become 1.0.0-0 which is the wrong direction.\n    case 'pre':\n      if (this.prerelease.length === 0) {\n        this.prerelease = [0];\n      } else {\n        var i = this.prerelease.length;\n        while (--i >= 0) {\n          if (typeof this.prerelease[i] === 'number') {\n            this.prerelease[i]++;\n            i = -2;\n          }\n        }\n        if (i === -1) {\n          // didn't increment anything\n          this.prerelease.push(0);\n        }\n      }\n      if (identifier) {\n        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n        if (this.prerelease[0] === identifier) {\n          if (isNaN(this.prerelease[1])) {\n            this.prerelease = [identifier, 0];\n          }\n        } else {\n          this.prerelease = [identifier, 0];\n        }\n      }\n      break;\n    default:\n      throw new Error('invalid increment argument: ' + release);\n  }\n  this.format();\n  this.raw = this.version;\n  return this;\n};\nexports.inc = inc;\nfunction inc(version, release, loose, identifier) {\n  if (typeof loose === 'string') {\n    identifier = loose;\n    loose = undefined;\n  }\n  try {\n    return new SemVer(version, loose).inc(release, identifier).version;\n  } catch (er) {\n    return null;\n  }\n}\nexports.diff = diff;\nfunction diff(version1, version2) {\n  if (eq(version1, version2)) {\n    return null;\n  } else {\n    var v1 = parse(version1);\n    var v2 = parse(version2);\n    var prefix = '';\n    if (v1.prerelease.length || v2.prerelease.length) {\n      prefix = 'pre';\n      var defaultResult = 'prerelease';\n    }\n    for (var key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return prefix + key;\n        }\n      }\n    }\n    return defaultResult; // may be undefined\n  }\n}\n\nexports.compareIdentifiers = compareIdentifiers;\nvar numeric = /^[0-9]+$/;\nfunction compareIdentifiers(a, b) {\n  var anum = numeric.test(a);\n  var bnum = numeric.test(b);\n  if (anum && bnum) {\n    a = +a;\n    b = +b;\n  }\n  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;\n}\nexports.rcompareIdentifiers = rcompareIdentifiers;\nfunction rcompareIdentifiers(a, b) {\n  return compareIdentifiers(b, a);\n}\nexports.major = major;\nfunction major(a, loose) {\n  return new SemVer(a, loose).major;\n}\nexports.minor = minor;\nfunction minor(a, loose) {\n  return new SemVer(a, loose).minor;\n}\nexports.patch = patch;\nfunction patch(a, loose) {\n  return new SemVer(a, loose).patch;\n}\nexports.compare = compare;\nfunction compare(a, b, loose) {\n  return new SemVer(a, loose).compare(new SemVer(b, loose));\n}\nexports.compareLoose = compareLoose;\nfunction compareLoose(a, b) {\n  return compare(a, b, true);\n}\nexports.rcompare = rcompare;\nfunction rcompare(a, b, loose) {\n  return compare(b, a, loose);\n}\nexports.sort = sort;\nfunction sort(list, loose) {\n  return list.sort(function (a, b) {\n    return exports.compare(a, b, loose);\n  });\n}\nexports.rsort = rsort;\nfunction rsort(list, loose) {\n  return list.sort(function (a, b) {\n    return exports.rcompare(a, b, loose);\n  });\n}\nexports.gt = gt;\nfunction gt(a, b, loose) {\n  return compare(a, b, loose) > 0;\n}\nexports.lt = lt;\nfunction lt(a, b, loose) {\n  return compare(a, b, loose) < 0;\n}\nexports.eq = eq;\nfunction eq(a, b, loose) {\n  return compare(a, b, loose) === 0;\n}\nexports.neq = neq;\nfunction neq(a, b, loose) {\n  return compare(a, b, loose) !== 0;\n}\nexports.gte = gte;\nfunction gte(a, b, loose) {\n  return compare(a, b, loose) >= 0;\n}\nexports.lte = lte;\nfunction lte(a, b, loose) {\n  return compare(a, b, loose) <= 0;\n}\nexports.cmp = cmp;\nfunction cmp(a, op, b, loose) {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      return a === b;\n    case '!==':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      return a !== b;\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose);\n    case '!=':\n      return neq(a, b, loose);\n    case '>':\n      return gt(a, b, loose);\n    case '>=':\n      return gte(a, b, loose);\n    case '<':\n      return lt(a, b, loose);\n    case '<=':\n      return lte(a, b, loose);\n    default:\n      throw new TypeError('Invalid operator: ' + op);\n  }\n}\nexports.Comparator = Comparator;\nfunction Comparator(comp, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    };\n  }\n  if (comp instanceof Comparator) {\n    if (comp.loose === !!options.loose) {\n      return comp;\n    } else {\n      comp = comp.value;\n    }\n  }\n  if (!(this instanceof Comparator)) {\n    return new Comparator(comp, options);\n  }\n  comp = comp.trim().split(/\\s+/).join(' ');\n  debug('comparator', comp, options);\n  this.options = options;\n  this.loose = !!options.loose;\n  this.parse(comp);\n  if (this.semver === ANY) {\n    this.value = '';\n  } else {\n    this.value = this.operator + this.semver.version;\n  }\n  debug('comp', this);\n}\nvar ANY = {};\nComparator.prototype.parse = function (comp) {\n  var r = this.options.loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR];\n  var m = comp.match(r);\n  if (!m) {\n    throw new TypeError('Invalid comparator: ' + comp);\n  }\n  this.operator = m[1];\n  if (this.operator === '=') {\n    this.operator = '';\n  }\n\n  // if it literally is just '>' or '' then allow anything.\n  if (!m[2]) {\n    this.semver = ANY;\n  } else {\n    this.semver = new SemVer(m[2], this.options.loose);\n  }\n};\nComparator.prototype.toString = function () {\n  return this.value;\n};\nComparator.prototype.test = function (version) {\n  debug('Comparator.test', version, this.options.loose);\n  if (this.semver === ANY) {\n    return true;\n  }\n  if (typeof version === 'string') {\n    version = new SemVer(version, this.options);\n  }\n  return cmp(version, this.operator, this.semver, this.options);\n};\nComparator.prototype.intersects = function (comp, options) {\n  if (!(comp instanceof Comparator)) {\n    throw new TypeError('a Comparator is required');\n  }\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    };\n  }\n  var rangeTmp;\n  if (this.operator === '') {\n    rangeTmp = new Range(comp.value, options);\n    return satisfies(this.value, rangeTmp, options);\n  } else if (comp.operator === '') {\n    rangeTmp = new Range(this.value, options);\n    return satisfies(comp.semver, rangeTmp, options);\n  }\n  var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');\n  var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');\n  var sameSemVer = this.semver.version === comp.semver.version;\n  var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');\n  var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');\n  var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');\n  return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;\n};\nexports.Range = Range;\nfunction Range(range, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    };\n  }\n  if (range instanceof Range) {\n    if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {\n      return range;\n    } else {\n      return new Range(range.raw, options);\n    }\n  }\n  if (range instanceof Comparator) {\n    return new Range(range.value, options);\n  }\n  if (!(this instanceof Range)) {\n    return new Range(range, options);\n  }\n  this.options = options;\n  this.loose = !!options.loose;\n  this.includePrerelease = !!options.includePrerelease;\n\n  // First reduce all whitespace as much as possible so we do not have to rely\n  // on potentially slow regexes like \\s*. This is then stored and used for\n  // future error messages as well.\n  this.raw = range.trim().split(/\\s+/).join(' ');\n\n  // First, split based on boolean or ||\n  this.set = this.raw.split('||').map(function (range) {\n    return this.parseRange(range.trim());\n  }, this).filter(function (c) {\n    // throw out any that are not relevant for whatever reason\n    return c.length;\n  });\n  if (!this.set.length) {\n    throw new TypeError('Invalid SemVer Range: ' + this.raw);\n  }\n  this.format();\n}\nRange.prototype.format = function () {\n  this.range = this.set.map(function (comps) {\n    return comps.join(' ').trim();\n  }).join('||').trim();\n  return this.range;\n};\nRange.prototype.toString = function () {\n  return this.range;\n};\nRange.prototype.parseRange = function (range) {\n  var loose = this.options.loose;\n  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n  var hr = loose ? safeRe[HYPHENRANGELOOSE] : safeRe[HYPHENRANGE];\n  range = range.replace(hr, hyphenReplace);\n  debug('hyphen replace', range);\n  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n  range = range.replace(safeRe[COMPARATORTRIM], comparatorTrimReplace);\n  debug('comparator trim', range, safeRe[COMPARATORTRIM]);\n\n  // `~ 1.2.3` => `~1.2.3`\n  range = range.replace(safeRe[TILDETRIM], tildeTrimReplace);\n\n  // `^ 1.2.3` => `^1.2.3`\n  range = range.replace(safeRe[CARETTRIM], caretTrimReplace);\n\n  // At this point, the range is completely trimmed and\n  // ready to be split into comparators.\n  var compRe = loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR];\n  var set = range.split(' ').map(function (comp) {\n    return parseComparator(comp, this.options);\n  }, this).join(' ').split(/\\s+/);\n  if (this.options.loose) {\n    // in loose mode, throw out any that are not valid comparators\n    set = set.filter(function (comp) {\n      return !!comp.match(compRe);\n    });\n  }\n  set = set.map(function (comp) {\n    return new Comparator(comp, this.options);\n  }, this);\n  return set;\n};\nRange.prototype.intersects = function (range, options) {\n  if (!(range instanceof Range)) {\n    throw new TypeError('a Range is required');\n  }\n  return this.set.some(function (thisComparators) {\n    return thisComparators.every(function (thisComparator) {\n      return range.set.some(function (rangeComparators) {\n        return rangeComparators.every(function (rangeComparator) {\n          return thisComparator.intersects(rangeComparator, options);\n        });\n      });\n    });\n  });\n};\n\n// Mostly just for testing and legacy API reasons\nexports.toComparators = toComparators;\nfunction toComparators(range, options) {\n  return new Range(range, options).set.map(function (comp) {\n    return comp.map(function (c) {\n      return c.value;\n    }).join(' ').trim().split(' ');\n  });\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nfunction parseComparator(comp, options) {\n  debug('comp', comp, options);\n  comp = replaceCarets(comp, options);\n  debug('caret', comp);\n  comp = replaceTildes(comp, options);\n  debug('tildes', comp);\n  comp = replaceXRanges(comp, options);\n  debug('xrange', comp);\n  comp = replaceStars(comp, options);\n  debug('stars', comp);\n  return comp;\n}\nfunction isX(id) {\n  return !id || id.toLowerCase() === 'x' || id === '*';\n}\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0\nfunction replaceTildes(comp, options) {\n  return comp.trim().split(/\\s+/).map(function (comp) {\n    return replaceTilde(comp, options);\n  }).join(' ');\n}\nfunction replaceTilde(comp, options) {\n  var r = options.loose ? safeRe[TILDELOOSE] : safeRe[TILDE];\n  return comp.replace(r, function (_, M, m, p, pr) {\n    debug('tilde', comp, _, M, m, p, pr);\n    var ret;\n    if (isX(M)) {\n      ret = '';\n    } else if (isX(m)) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    } else if (pr) {\n      debug('replaceTilde pr', pr);\n      ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0\n      ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';\n    }\n    debug('tilde return', ret);\n    return ret;\n  });\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0\n// ^1.2.3 --> >=1.2.3 <2.0.0\n// ^1.2.0 --> >=1.2.0 <2.0.0\nfunction replaceCarets(comp, options) {\n  return comp.trim().split(/\\s+/).map(function (comp) {\n    return replaceCaret(comp, options);\n  }).join(' ');\n}\nfunction replaceCaret(comp, options) {\n  debug('caret', comp, options);\n  var r = options.loose ? safeRe[CARETLOOSE] : safeRe[CARET];\n  return comp.replace(r, function (_, M, m, p, pr) {\n    debug('caret', comp, _, M, m, p, pr);\n    var ret;\n    if (isX(M)) {\n      ret = '';\n    } else if (isX(m)) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n      } else {\n        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr);\n      if (M === '0') {\n        if (m === '0') {\n          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + m + '.' + (+p + 1);\n        } else {\n          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';\n        }\n      } else {\n        ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + (+M + 1) + '.0.0';\n      }\n    } else {\n      debug('no pr');\n      if (M === '0') {\n        if (m === '0') {\n          ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);\n        } else {\n          ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';\n        }\n      } else {\n        ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';\n      }\n    }\n    debug('caret return', ret);\n    return ret;\n  });\n}\nfunction replaceXRanges(comp, options) {\n  debug('replaceXRanges', comp, options);\n  return comp.split(/\\s+/).map(function (comp) {\n    return replaceXRange(comp, options);\n  }).join(' ');\n}\nfunction replaceXRange(comp, options) {\n  comp = comp.trim();\n  var r = options.loose ? safeRe[XRANGELOOSE] : safeRe[XRANGE];\n  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr);\n    var xM = isX(M);\n    var xm = xM || isX(m);\n    var xp = xm || isX(p);\n    var anyX = xp;\n    if (gtlt === '=' && anyX) {\n      gtlt = '';\n    }\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0';\n      } else {\n        // nothing is forbidden\n        ret = '*';\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0;\n      }\n      p = 0;\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        // >1.2.3 => >= 1.2.4\n        gtlt = '>=';\n        if (xm) {\n          M = +M + 1;\n          m = 0;\n          p = 0;\n        } else {\n          m = +m + 1;\n          p = 0;\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<';\n        if (xm) {\n          M = +M + 1;\n        } else {\n          m = +m + 1;\n        }\n      }\n      ret = gtlt + M + '.' + m + '.' + p;\n    } else if (xm) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    } else if (xp) {\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    }\n    debug('xRange return', ret);\n    return ret;\n  });\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nfunction replaceStars(comp, options) {\n  debug('replaceStars', comp, options);\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(safeRe[STAR], '');\n}\n\n// This function is passed to string.replace(safeRe[HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0\nfunction hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {\n  if (isX(fM)) {\n    from = '';\n  } else if (isX(fm)) {\n    from = '>=' + fM + '.0.0';\n  } else if (isX(fp)) {\n    from = '>=' + fM + '.' + fm + '.0';\n  } else {\n    from = '>=' + from;\n  }\n  if (isX(tM)) {\n    to = '';\n  } else if (isX(tm)) {\n    to = '<' + (+tM + 1) + '.0.0';\n  } else if (isX(tp)) {\n    to = '<' + tM + '.' + (+tm + 1) + '.0';\n  } else if (tpr) {\n    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;\n  } else {\n    to = '<=' + to;\n  }\n  return (from + ' ' + to).trim();\n}\n\n// if ANY of the sets match ALL of its comparators, then pass\nRange.prototype.test = function (version) {\n  if (!version) {\n    return false;\n  }\n  if (typeof version === 'string') {\n    version = new SemVer(version, this.options);\n  }\n  for (var i = 0; i < this.set.length; i++) {\n    if (testSet(this.set[i], version, this.options)) {\n      return true;\n    }\n  }\n  return false;\n};\nfunction testSet(set, version, options) {\n  for (var i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false;\n    }\n  }\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (i = 0; i < set.length; i++) {\n      debug(set[i].semver);\n      if (set[i].semver === ANY) {\n        continue;\n      }\n      if (set[i].semver.prerelease.length > 0) {\n        var allowed = set[i].semver;\n        if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {\n          return true;\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false;\n  }\n  return true;\n}\nexports.satisfies = satisfies;\nfunction satisfies(version, range, options) {\n  try {\n    range = new Range(range, options);\n  } catch (er) {\n    return false;\n  }\n  return range.test(version);\n}\nexports.maxSatisfying = maxSatisfying;\nfunction maxSatisfying(versions, range, options) {\n  var max = null;\n  var maxSV = null;\n  try {\n    var rangeObj = new Range(range, options);\n  } catch (er) {\n    return null;\n  }\n  versions.forEach(function (v) {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v;\n        maxSV = new SemVer(max, options);\n      }\n    }\n  });\n  return max;\n}\nexports.minSatisfying = minSatisfying;\nfunction minSatisfying(versions, range, options) {\n  var min = null;\n  var minSV = null;\n  try {\n    var rangeObj = new Range(range, options);\n  } catch (er) {\n    return null;\n  }\n  versions.forEach(function (v) {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v;\n        minSV = new SemVer(min, options);\n      }\n    }\n  });\n  return min;\n}\nexports.minVersion = minVersion;\nfunction minVersion(range, loose) {\n  range = new Range(range, loose);\n  var minver = new SemVer('0.0.0');\n  if (range.test(minver)) {\n    return minver;\n  }\n  minver = new SemVer('0.0.0-0');\n  if (range.test(minver)) {\n    return minver;\n  }\n  minver = null;\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i];\n    comparators.forEach(function (comparator) {\n      // Clone to avoid manipulating the comparator's semver object.\n      var compver = new SemVer(comparator.semver.version);\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++;\n          } else {\n            compver.prerelease.push(0);\n          }\n          compver.raw = compver.format();\n        /* fallthrough */\n        case '':\n        case '>=':\n          if (!minver || gt(minver, compver)) {\n            minver = compver;\n          }\n          break;\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break;\n        /* istanbul ignore next */\n        default:\n          throw new Error('Unexpected operation: ' + comparator.operator);\n      }\n    });\n  }\n  if (minver && range.test(minver)) {\n    return minver;\n  }\n  return null;\n}\nexports.validRange = validRange;\nfunction validRange(range, options) {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*';\n  } catch (er) {\n    return null;\n  }\n}\n\n// Determine if version is less than all the versions possible in the range\nexports.ltr = ltr;\nfunction ltr(version, range, options) {\n  return outside(version, range, '<', options);\n}\n\n// Determine if version is greater than all the versions possible in the range.\nexports.gtr = gtr;\nfunction gtr(version, range, options) {\n  return outside(version, range, '>', options);\n}\nexports.outside = outside;\nfunction outside(version, range, hilo, options) {\n  version = new SemVer(version, options);\n  range = new Range(range, options);\n  var gtfn, ltefn, ltfn, comp, ecomp;\n  switch (hilo) {\n    case '>':\n      gtfn = gt;\n      ltefn = lte;\n      ltfn = lt;\n      comp = '>';\n      ecomp = '>=';\n      break;\n    case '<':\n      gtfn = lt;\n      ltefn = gte;\n      ltfn = gt;\n      comp = '<';\n      ecomp = '<=';\n      break;\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false;\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i];\n    var high = null;\n    var low = null;\n    comparators.forEach(function (comparator) {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0');\n      }\n      high = high || comparator;\n      low = low || comparator;\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator;\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator;\n      }\n    });\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false;\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {\n      return false;\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false;\n    }\n  }\n  return true;\n}\nexports.prerelease = prerelease;\nfunction prerelease(version, options) {\n  var parsed = parse(version, options);\n  return parsed && parsed.prerelease.length ? parsed.prerelease : null;\n}\nexports.intersects = intersects;\nfunction intersects(r1, r2, options) {\n  r1 = new Range(r1, options);\n  r2 = new Range(r2, options);\n  return r1.intersects(r2);\n}\nexports.coerce = coerce;\nfunction coerce(version) {\n  if (version instanceof SemVer) {\n    return version;\n  }\n  if (typeof version !== 'string') {\n    return null;\n  }\n  var match = version.match(safeRe[COERCE]);\n  if (match == null) {\n    return null;\n  }\n  return parse(match[1] + '.' + (match[2] || '0') + '.' + (match[3] || '0'));\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\azure-pipelines-task-lib\\node_modules\\semver\\semver.js");

/***/ }),

/***/ "./node_modules/azure-pipelines-task-lib/task.js":
/*!*******************************************************!*\
  !*** ./node_modules/azure-pipelines-task-lib/task.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.updateReleaseName = exports.addBuildTag = exports.updateBuildNumber = exports.uploadBuildLog = exports.associateArtifact = exports.uploadArtifact = exports.logIssue = exports.logDetail = exports.setProgress = exports.setEndpoint = exports.addAttachment = exports.uploadSummary = exports.prependPath = exports.uploadFile = exports.CodeCoverageEnabler = exports.CodeCoveragePublisher = exports.TestPublisher = exports.getHttpCertConfiguration = exports.getHttpProxyConfiguration = exports.findMatch = exports.filter = exports.match = exports.tool = exports.execSync = exports.exec = exports.rmRF = exports.legacyFindFiles = exports.find = exports.retry = exports.mv = exports.cp = exports.ls = exports.which = exports.resolve = exports.mkdirP = exports.popd = exports.pushd = exports.cd = exports.checkPath = exports.cwd = exports.getAgentMode = exports.getPlatform = exports.osType = exports.writeFile = exports.exist = exports.stats = exports.debug = exports.error = exports.warning = exports.command = exports.setTaskVariable = exports.getTaskVariable = exports.getSecureFileTicket = exports.getSecureFileName = exports.getEndpointAuthorization = exports.getEndpointAuthorizationParameterRequired = exports.getEndpointAuthorizationParameter = exports.getEndpointAuthorizationSchemeRequired = exports.getEndpointAuthorizationScheme = exports.getEndpointDataParameterRequired = exports.getEndpointDataParameter = exports.getEndpointUrlRequired = exports.getEndpointUrl = exports.getPathInputRequired = exports.getPathInput = exports.filePathSupplied = exports.getDelimitedInput = exports.getBoolFeatureFlag = exports.getBoolInput = exports.getInputRequired = exports.getInput = exports.setSecret = exports.setVariable = exports.getVariables = exports.assertAgent = exports.getVariable = exports.loc = exports.setResourcePath = exports.setResult = exports.setErrStream = exports.setStdStream = exports.AgentHostedMode = exports.Platform = exports.FieldType = exports.ArtifactType = exports.IssueType = exports.TaskState = exports.TaskResult = void 0;\nvar shell = __webpack_require__(/*! shelljs */ \"./node_modules/shelljs/shell.js\");\nvar childProcess = __webpack_require__(/*! child_process */ \"child_process\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar os = __webpack_require__(/*! os */ \"os\");\nvar minimatch = __webpack_require__(/*! minimatch */ \"./node_modules/azure-pipelines-task-lib/node_modules/minimatch/minimatch.js\");\nvar im = __webpack_require__(/*! ./internal */ \"./node_modules/azure-pipelines-task-lib/internal.js\");\nvar tcm = __webpack_require__(/*! ./taskcommand */ \"./node_modules/azure-pipelines-task-lib/taskcommand.js\");\nvar trm = __webpack_require__(/*! ./toolrunner */ \"./node_modules/azure-pipelines-task-lib/toolrunner.js\");\nvar semver = __webpack_require__(/*! semver */ \"./node_modules/azure-pipelines-task-lib/node_modules/semver/semver.js\");\nvar TaskResult;\n(function (TaskResult) {\n  TaskResult[TaskResult[\"Succeeded\"] = 0] = \"Succeeded\";\n  TaskResult[TaskResult[\"SucceededWithIssues\"] = 1] = \"SucceededWithIssues\";\n  TaskResult[TaskResult[\"Failed\"] = 2] = \"Failed\";\n  TaskResult[TaskResult[\"Cancelled\"] = 3] = \"Cancelled\";\n  TaskResult[TaskResult[\"Skipped\"] = 4] = \"Skipped\";\n})(TaskResult = exports.TaskResult || (exports.TaskResult = {}));\nvar TaskState;\n(function (TaskState) {\n  TaskState[TaskState[\"Unknown\"] = 0] = \"Unknown\";\n  TaskState[TaskState[\"Initialized\"] = 1] = \"Initialized\";\n  TaskState[TaskState[\"InProgress\"] = 2] = \"InProgress\";\n  TaskState[TaskState[\"Completed\"] = 3] = \"Completed\";\n})(TaskState = exports.TaskState || (exports.TaskState = {}));\nvar IssueType;\n(function (IssueType) {\n  IssueType[IssueType[\"Error\"] = 0] = \"Error\";\n  IssueType[IssueType[\"Warning\"] = 1] = \"Warning\";\n})(IssueType = exports.IssueType || (exports.IssueType = {}));\nvar ArtifactType;\n(function (ArtifactType) {\n  ArtifactType[ArtifactType[\"Container\"] = 0] = \"Container\";\n  ArtifactType[ArtifactType[\"FilePath\"] = 1] = \"FilePath\";\n  ArtifactType[ArtifactType[\"VersionControl\"] = 2] = \"VersionControl\";\n  ArtifactType[ArtifactType[\"GitRef\"] = 3] = \"GitRef\";\n  ArtifactType[ArtifactType[\"TfvcLabel\"] = 4] = \"TfvcLabel\";\n})(ArtifactType = exports.ArtifactType || (exports.ArtifactType = {}));\nvar FieldType;\n(function (FieldType) {\n  FieldType[FieldType[\"AuthParameter\"] = 0] = \"AuthParameter\";\n  FieldType[FieldType[\"DataParameter\"] = 1] = \"DataParameter\";\n  FieldType[FieldType[\"Url\"] = 2] = \"Url\";\n})(FieldType = exports.FieldType || (exports.FieldType = {}));\n/** Platforms supported by our build agent */\nvar Platform;\n(function (Platform) {\n  Platform[Platform[\"Windows\"] = 0] = \"Windows\";\n  Platform[Platform[\"MacOS\"] = 1] = \"MacOS\";\n  Platform[Platform[\"Linux\"] = 2] = \"Linux\";\n})(Platform = exports.Platform || (exports.Platform = {}));\nvar AgentHostedMode;\n(function (AgentHostedMode) {\n  AgentHostedMode[AgentHostedMode[\"Unknown\"] = 0] = \"Unknown\";\n  AgentHostedMode[AgentHostedMode[\"SelfHosted\"] = 1] = \"SelfHosted\";\n  AgentHostedMode[AgentHostedMode[\"MsHosted\"] = 2] = \"MsHosted\";\n})(AgentHostedMode = exports.AgentHostedMode || (exports.AgentHostedMode = {}));\n//-----------------------------------------------------\n// General Helpers\n//-----------------------------------------------------\nexports.setStdStream = im._setStdStream;\nexports.setErrStream = im._setErrStream;\n//-----------------------------------------------------\n// Results\n//-----------------------------------------------------\n/**\n * Sets the result of the task.\n * Execution will continue.\n * If not set, task will be Succeeded.\n * If multiple calls are made to setResult the most pessimistic call wins (Failed) regardless of the order of calls.\n *\n * @param result    TaskResult enum of Succeeded, SucceededWithIssues, Failed, Cancelled or Skipped.\n * @param message   A message which will be logged as an error issue if the result is Failed.\n * @param done      Optional. Instructs the agent the task is done. This is helpful when child processes\n *                  may still be running and prevent node from fully exiting. This argument is supported\n *                  from agent version 2.142.0 or higher (otherwise will no-op).\n * @returns         void\n */\nfunction setResult(result, message, done) {\n  exports.debug('task result: ' + TaskResult[result]);\n  // add an error issue\n  if (result == TaskResult.Failed && message) {\n    exports.error(message);\n  } else if (result == TaskResult.SucceededWithIssues && message) {\n    exports.warning(message);\n  }\n  // task.complete\n  var properties = {\n    'result': TaskResult[result]\n  };\n  if (done) {\n    properties['done'] = 'true';\n  }\n  exports.command('task.complete', properties, message);\n}\nexports.setResult = setResult;\n//\n// Catching all exceptions\n//\nprocess.on('uncaughtException', function (err) {\n  setResult(TaskResult.Failed, exports.loc('LIB_UnhandledEx', err.message));\n  exports.error(String(err.stack));\n});\n//\n// Catching unhandled rejections from promises and rethrowing them as exceptions\n// For example, a promise that is rejected but not handled by a .catch() handler in node 10 \n// doesn't cause an uncaughtException but causes in Node 16.\n// For types definitions(Error | Any) see https://nodejs.org/docs/latest-v16.x/api/process.html#event-unhandledrejection\n//\nprocess.on('unhandledRejection', function (reason) {\n  if (reason instanceof Error) {\n    throw reason;\n  } else {\n    throw new Error(reason);\n  }\n});\n//-----------------------------------------------------\n// Loc Helpers\n//-----------------------------------------------------\nexports.setResourcePath = im._setResourcePath;\nexports.loc = im._loc;\n//-----------------------------------------------------\n// Input Helpers\n//-----------------------------------------------------\nexports.getVariable = im._getVariable;\n/**\n * Asserts the agent version is at least the specified minimum.\n *\n * @param    minimum    minimum version version - must be 2.104.1 or higher\n */\nfunction assertAgent(minimum) {\n  if (semver.lt(minimum, '2.104.1')) {\n    throw new Error('assertAgent() requires the parameter to be 2.104.1 or higher');\n  }\n  var agent = exports.getVariable('Agent.Version');\n  if (agent && semver.lt(agent, minimum)) {\n    throw new Error(\"Agent version \" + minimum + \" or higher is required\");\n  }\n}\nexports.assertAgent = assertAgent;\n/**\n * Gets a snapshot of the current state of all job variables available to the task.\n * Requires a 2.104.1 agent or higher for full functionality.\n *\n * Limitations on an agent prior to 2.104.1:\n *  1) The return value does not include all public variables. Only public variables\n *     that have been added using setVariable are returned.\n *  2) The name returned for each secret variable is the formatted environment variable\n *     name, not the actual variable name (unless it was set explicitly at runtime using\n *     setVariable).\n *\n * @returns VariableInfo[]\n */\nfunction getVariables() {\n  return Object.keys(im._knownVariableMap).map(function (key) {\n    var info = im._knownVariableMap[key];\n    return {\n      name: info.name,\n      value: exports.getVariable(info.name),\n      secret: info.secret\n    };\n  });\n}\nexports.getVariables = getVariables;\n/**\n * Sets a variable which will be available to subsequent tasks as well.\n *\n * @param     name     name of the variable to set\n * @param     val      value to set\n * @param     secret   whether variable is secret.  Multi-line secrets are not allowed.  Optional, defaults to false\n * @param     isOutput whether variable is an output variable.  Optional, defaults to false\n * @returns   void\n */\nfunction setVariable(name, val, secret, isOutput) {\n  if (secret === void 0) {\n    secret = false;\n  }\n  if (isOutput === void 0) {\n    isOutput = false;\n  }\n  // once a secret always a secret\n  var key = im._getVariableKey(name);\n  if (im._knownVariableMap.hasOwnProperty(key)) {\n    secret = secret || im._knownVariableMap[key].secret;\n  }\n  // store the value\n  var varValue = val || '';\n  exports.debug('set ' + name + '=' + (secret && varValue ? '********' : varValue));\n  if (secret) {\n    if (varValue && varValue.match(/\\r|\\n/) && (\"\" + process.env['SYSTEM_UNSAFEALLOWMULTILINESECRET']).toUpperCase() != 'TRUE') {\n      throw new Error(exports.loc('LIB_MultilineSecret'));\n    }\n    im._vault.storeSecret('SECRET_' + key, varValue);\n    delete process.env[key];\n  } else {\n    process.env[key] = varValue;\n  }\n  // store the metadata\n  im._knownVariableMap[key] = {\n    name: name,\n    secret: secret\n  };\n  // write the setvariable command\n  exports.command('task.setvariable', {\n    'variable': name || '',\n    isOutput: (isOutput || false).toString(),\n    'issecret': (secret || false).toString()\n  }, varValue);\n}\nexports.setVariable = setVariable;\n/**\n * Registers a value with the logger, so the value will be masked from the logs.  Multi-line secrets are not allowed.\n *\n * @param val value to register\n */\nfunction setSecret(val) {\n  if (val) {\n    if (val.match(/\\r|\\n/) && (\"\" + process.env['SYSTEM_UNSAFEALLOWMULTILINESECRET']).toUpperCase() !== 'TRUE') {\n      throw new Error(exports.loc('LIB_MultilineSecret'));\n    }\n    exports.command('task.setsecret', {}, val);\n  }\n}\nexports.setSecret = setSecret;\n/**\n * Gets the value of an input.\n * If required is true and the value is not set, it will throw.\n *\n * @param     name     name of the input to get\n * @param     required whether input is required.  optional, defaults to false\n * @returns   string\n */\nfunction getInput(name, required) {\n  var inval = im._vault.retrieveSecret('INPUT_' + im._getVariableKey(name));\n  if (required && !inval) {\n    throw new Error(exports.loc('LIB_InputRequired', name));\n  }\n  exports.debug(name + '=' + inval);\n  return inval;\n}\nexports.getInput = getInput;\n/**\n * Gets the value of an input.\n * If the value is not set, it will throw.\n *\n * @param     name     name of the input to get\n * @returns   string\n */\nfunction getInputRequired(name) {\n  return getInput(name, true);\n}\nexports.getInputRequired = getInputRequired;\n/**\n * Gets the value of an input and converts to a bool.  Convenience.\n * If required is true and the value is not set, it will throw.\n * If required is false and the value is not set, returns false.\n *\n * @param     name     name of the bool input to get\n * @param     required whether input is required.  optional, defaults to false\n * @returns   boolean\n */\nfunction getBoolInput(name, required) {\n  return (getInput(name, required) || '').toUpperCase() == \"TRUE\";\n}\nexports.getBoolInput = getBoolInput;\n/**\n * Gets the value of an feature flag and converts to a bool.\n *\n * @param     name     name of the feature flag to get.\n * @param     defaultValue default value of the feature flag in case it's not found in env. (optional. Default value = false)\n * @returns   boolean\n */\nfunction getBoolFeatureFlag(ffName, defaultValue) {\n  if (defaultValue === void 0) {\n    defaultValue = false;\n  }\n  var ffValue = process.env[ffName];\n  if (!ffValue) {\n    exports.debug(\"Feature flag \" + ffName + \" not found. Returning \" + defaultValue + \" as default.\");\n    return defaultValue;\n  }\n  exports.debug(\"Feature flag \" + ffName + \" = \" + ffValue);\n  return ffValue.toLowerCase() === \"true\";\n}\nexports.getBoolFeatureFlag = getBoolFeatureFlag;\n/**\n * Gets the value of an input and splits the value using a delimiter (space, comma, etc).\n * Empty values are removed.  This function is useful for splitting an input containing a simple\n * list of items - such as build targets.\n * IMPORTANT: Do not use this function for splitting additional args!  Instead use argString(), which\n * follows normal argument splitting rules and handles values encapsulated by quotes.\n * If required is true and the value is not set, it will throw.\n *\n * @param     name     name of the input to get\n * @param     delim    delimiter to split on\n * @param     required whether input is required.  optional, defaults to false\n * @returns   string[]\n */\nfunction getDelimitedInput(name, delim, required) {\n  var inputVal = getInput(name, required);\n  if (!inputVal) {\n    return [];\n  }\n  var result = [];\n  inputVal.split(delim).forEach(function (x) {\n    if (x) {\n      result.push(x);\n    }\n  });\n  return result;\n}\nexports.getDelimitedInput = getDelimitedInput;\n/**\n * Checks whether a path inputs value was supplied by the user\n * File paths are relative with a picker, so an empty path is the root of the repo.\n * Useful if you need to condition work (like append an arg) if a value was supplied\n *\n * @param     name      name of the path input to check\n * @returns   boolean\n */\nfunction filePathSupplied(name) {\n  // normalize paths\n  var pathValue = this.resolve(this.getPathInput(name) || '');\n  var repoRoot = this.resolve(exports.getVariable('build.sourcesDirectory') || exports.getVariable('system.defaultWorkingDirectory') || '');\n  var supplied = pathValue !== repoRoot;\n  exports.debug(name + 'path supplied :' + supplied);\n  return supplied;\n}\nexports.filePathSupplied = filePathSupplied;\n/**\n * Gets the value of a path input\n * It will be quoted for you if it isn't already and contains spaces\n * If required is true and the value is not set, it will throw.\n * If check is true and the path does not exist, it will throw.\n *\n * @param     name      name of the input to get\n * @param     required  whether input is required.  optional, defaults to false\n * @param     check     whether path is checked.  optional, defaults to false\n * @returns   string\n */\nfunction getPathInput(name, required, check) {\n  var inval = getInput(name, required);\n  if (inval) {\n    if (check) {\n      exports.checkPath(inval, name);\n    }\n  }\n  return inval;\n}\nexports.getPathInput = getPathInput;\n/**\n * Gets the value of a path input\n * It will be quoted for you if it isn't already and contains spaces\n * If the value is not set, it will throw.\n * If check is true and the path does not exist, it will throw.\n *\n * @param     name      name of the input to get\n * @param     check     whether path is checked.  optional, defaults to false\n * @returns   string\n */\nfunction getPathInputRequired(name, check) {\n  return getPathInput(name, true, check);\n}\nexports.getPathInputRequired = getPathInputRequired;\n//-----------------------------------------------------\n// Endpoint Helpers\n//-----------------------------------------------------\n/**\n * Gets the url for a service endpoint\n * If the url was not set and is not optional, it will throw.\n *\n * @param     id        name of the service endpoint\n * @param     optional  whether the url is optional\n * @returns   string\n */\nfunction getEndpointUrl(id, optional) {\n  var urlval = process.env['ENDPOINT_URL_' + id];\n  if (!optional && !urlval) {\n    throw new Error(exports.loc('LIB_EndpointNotExist', id));\n  }\n  exports.debug(id + '=' + urlval);\n  return urlval;\n}\nexports.getEndpointUrl = getEndpointUrl;\n/**\n * Gets the url for a service endpoint\n * If the url was not set, it will throw.\n *\n * @param     id        name of the service endpoint\n * @returns   string\n */\nfunction getEndpointUrlRequired(id) {\n  return getEndpointUrl(id, false);\n}\nexports.getEndpointUrlRequired = getEndpointUrlRequired;\n/*\n * Gets the endpoint data parameter value with specified key for a service endpoint\n * If the endpoint data parameter was not set and is not optional, it will throw.\n *\n * @param id name of the service endpoint\n * @param key of the parameter\n * @param optional whether the endpoint data is optional\n * @returns {string} value of the endpoint data parameter\n */\nfunction getEndpointDataParameter(id, key, optional) {\n  var dataParamVal = process.env['ENDPOINT_DATA_' + id + '_' + key.toUpperCase()];\n  if (!optional && !dataParamVal) {\n    throw new Error(exports.loc('LIB_EndpointDataNotExist', id, key));\n  }\n  exports.debug(id + ' data ' + key + ' = ' + dataParamVal);\n  return dataParamVal;\n}\nexports.getEndpointDataParameter = getEndpointDataParameter;\n/*\n * Gets the endpoint data parameter value with specified key for a service endpoint\n * If the endpoint data parameter was not set, it will throw.\n *\n * @param id name of the service endpoint\n * @param key of the parameter\n * @returns {string} value of the endpoint data parameter\n */\nfunction getEndpointDataParameterRequired(id, key) {\n  return getEndpointDataParameter(id, key, false);\n}\nexports.getEndpointDataParameterRequired = getEndpointDataParameterRequired;\n/**\n * Gets the endpoint authorization scheme for a service endpoint\n * If the endpoint authorization scheme is not set and is not optional, it will throw.\n *\n * @param id name of the service endpoint\n * @param optional whether the endpoint authorization scheme is optional\n * @returns {string} value of the endpoint authorization scheme\n */\nfunction getEndpointAuthorizationScheme(id, optional) {\n  var authScheme = im._vault.retrieveSecret('ENDPOINT_AUTH_SCHEME_' + id);\n  if (!optional && !authScheme) {\n    throw new Error(exports.loc('LIB_EndpointAuthNotExist', id));\n  }\n  exports.debug(id + ' auth scheme = ' + authScheme);\n  return authScheme;\n}\nexports.getEndpointAuthorizationScheme = getEndpointAuthorizationScheme;\n/**\n * Gets the endpoint authorization scheme for a service endpoint\n * If the endpoint authorization scheme is not set, it will throw.\n *\n * @param id name of the service endpoint\n * @returns {string} value of the endpoint authorization scheme\n */\nfunction getEndpointAuthorizationSchemeRequired(id) {\n  return getEndpointAuthorizationScheme(id, false);\n}\nexports.getEndpointAuthorizationSchemeRequired = getEndpointAuthorizationSchemeRequired;\n/**\n * Gets the endpoint authorization parameter value for a service endpoint with specified key\n * If the endpoint authorization parameter is not set and is not optional, it will throw.\n *\n * @param id name of the service endpoint\n * @param key key to find the endpoint authorization parameter\n * @param optional optional whether the endpoint authorization scheme is optional\n * @returns {string} value of the endpoint authorization parameter value\n */\nfunction getEndpointAuthorizationParameter(id, key, optional) {\n  var authParam = im._vault.retrieveSecret('ENDPOINT_AUTH_PARAMETER_' + id + '_' + key.toUpperCase());\n  if (!optional && !authParam) {\n    throw new Error(exports.loc('LIB_EndpointAuthNotExist', id));\n  }\n  exports.debug(id + ' auth param ' + key + ' = ' + authParam);\n  return authParam;\n}\nexports.getEndpointAuthorizationParameter = getEndpointAuthorizationParameter;\n/**\n * Gets the endpoint authorization parameter value for a service endpoint with specified key\n * If the endpoint authorization parameter is not set, it will throw.\n *\n * @param id name of the service endpoint\n * @param key key to find the endpoint authorization parameter\n * @returns {string} value of the endpoint authorization parameter value\n */\nfunction getEndpointAuthorizationParameterRequired(id, key) {\n  return getEndpointAuthorizationParameter(id, key, false);\n}\nexports.getEndpointAuthorizationParameterRequired = getEndpointAuthorizationParameterRequired;\n/**\n * Gets the authorization details for a service endpoint\n * If the authorization was not set and is not optional, it will set the task result to Failed.\n *\n * @param     id        name of the service endpoint\n * @param     optional  whether the url is optional\n * @returns   string\n */\nfunction getEndpointAuthorization(id, optional) {\n  var aval = im._vault.retrieveSecret('ENDPOINT_AUTH_' + id);\n  if (!optional && !aval) {\n    setResult(TaskResult.Failed, exports.loc('LIB_EndpointAuthNotExist', id));\n  }\n  exports.debug(id + ' exists ' + !!aval);\n  var auth;\n  try {\n    if (aval) {\n      auth = JSON.parse(aval);\n    }\n  } catch (err) {\n    throw new Error(exports.loc('LIB_InvalidEndpointAuth', aval));\n  }\n  return auth;\n}\nexports.getEndpointAuthorization = getEndpointAuthorization;\n//-----------------------------------------------------\n// SecureFile Helpers\n//-----------------------------------------------------\n/**\n * Gets the name for a secure file\n *\n * @param     id        secure file id\n * @returns   string\n */\nfunction getSecureFileName(id) {\n  var name = process.env['SECUREFILE_NAME_' + id];\n  exports.debug('secure file name for id ' + id + ' = ' + name);\n  return name;\n}\nexports.getSecureFileName = getSecureFileName;\n/**\n  * Gets the secure file ticket that can be used to download the secure file contents\n  *\n  * @param id name of the secure file\n  * @returns {string} secure file ticket\n  */\nfunction getSecureFileTicket(id) {\n  var ticket = im._vault.retrieveSecret('SECUREFILE_TICKET_' + id);\n  exports.debug('secure file ticket for id ' + id + ' = ' + ticket);\n  return ticket;\n}\nexports.getSecureFileTicket = getSecureFileTicket;\n//-----------------------------------------------------\n// Task Variable Helpers\n//-----------------------------------------------------\n/**\n * Gets a variable value that is set by previous step from the same wrapper task.\n * Requires a 2.115.0 agent or higher.\n *\n * @param     name     name of the variable to get\n * @returns   string\n */\nfunction getTaskVariable(name) {\n  assertAgent('2.115.0');\n  var inval = im._vault.retrieveSecret('VSTS_TASKVARIABLE_' + im._getVariableKey(name));\n  if (inval) {\n    inval = inval.trim();\n  }\n  exports.debug('task variable: ' + name + '=' + inval);\n  return inval;\n}\nexports.getTaskVariable = getTaskVariable;\n/**\n * Sets a task variable which will only be available to subsequent steps belong to the same wrapper task.\n * Requires a 2.115.0 agent or higher.\n *\n * @param     name    name of the variable to set\n * @param     val     value to set\n * @param     secret  whether variable is secret.  optional, defaults to false\n * @returns   void\n */\nfunction setTaskVariable(name, val, secret) {\n  if (secret === void 0) {\n    secret = false;\n  }\n  assertAgent('2.115.0');\n  var key = im._getVariableKey(name);\n  // store the value\n  var varValue = val || '';\n  exports.debug('set task variable: ' + name + '=' + (secret && varValue ? '********' : varValue));\n  im._vault.storeSecret('VSTS_TASKVARIABLE_' + key, varValue);\n  delete process.env[key];\n  // write the command\n  exports.command('task.settaskvariable', {\n    'variable': name || '',\n    'issecret': (secret || false).toString()\n  }, varValue);\n}\nexports.setTaskVariable = setTaskVariable;\n//-----------------------------------------------------\n// Cmd Helpers\n//-----------------------------------------------------\nexports.command = im._command;\nexports.warning = im._warning;\nexports.error = im._error;\nexports.debug = im._debug;\n//-----------------------------------------------------\n// Disk Functions\n//-----------------------------------------------------\nfunction _checkShell(cmd, continueOnError) {\n  var se = shell.error();\n  if (se) {\n    exports.debug(cmd + ' failed');\n    var errMsg = exports.loc('LIB_OperationFailed', cmd, se);\n    exports.debug(errMsg);\n    if (!continueOnError) {\n      throw new Error(errMsg);\n    }\n  }\n}\n/**\n * Get's stat on a path.\n * Useful for checking whether a file or directory.  Also getting created, modified and accessed time.\n * see [fs.stat](https://nodejs.org/api/fs.html#fs_class_fs_stats)\n *\n * @param     path      path to check\n * @returns   fsStat\n */\nfunction stats(path) {\n  return fs.statSync(path);\n}\nexports.stats = stats;\nexports.exist = im._exist;\nfunction writeFile(file, data, options) {\n  if (typeof options === 'string') {\n    fs.writeFileSync(file, data, {\n      encoding: options\n    });\n  } else {\n    fs.writeFileSync(file, data, options);\n  }\n}\nexports.writeFile = writeFile;\n/**\n * @deprecated Use `getPlatform`\n * Useful for determining the host operating system.\n * see [os.type](https://nodejs.org/api/os.html#os_os_type)\n *\n * @return      the name of the operating system\n */\nfunction osType() {\n  return os.type();\n}\nexports.osType = osType;\n/**\n * Determine the operating system the build agent is running on.\n * @returns {Platform}\n * @throws {Error} Platform is not supported by our agent\n */\nfunction getPlatform() {\n  switch (process.platform) {\n    case 'win32':\n      return Platform.Windows;\n    case 'darwin':\n      return Platform.MacOS;\n    case 'linux':\n      return Platform.Linux;\n    default:\n      throw Error(exports.loc('LIB_PlatformNotSupported', process.platform));\n  }\n}\nexports.getPlatform = getPlatform;\n/**\n * Return hosted type of Agent\n * @returns {AgentHostedMode}\n */\nfunction getAgentMode() {\n  var agentCloudId = exports.getVariable('Agent.CloudId');\n  if (agentCloudId === undefined) return AgentHostedMode.Unknown;\n  if (agentCloudId) return AgentHostedMode.MsHosted;\n  return AgentHostedMode.SelfHosted;\n}\nexports.getAgentMode = getAgentMode;\n/**\n * Returns the process's current working directory.\n * see [process.cwd](https://nodejs.org/api/process.html#process_process_cwd)\n *\n * @return      the path to the current working directory of the process\n */\nfunction cwd() {\n  return process.cwd();\n}\nexports.cwd = cwd;\nexports.checkPath = im._checkPath;\n/**\n * Change working directory.\n *\n * @param     path      new working directory path\n * @returns   void\n */\nfunction cd(path) {\n  if (path) {\n    shell.cd(path);\n    _checkShell('cd');\n  }\n}\nexports.cd = cd;\n/**\n * Change working directory and push it on the stack\n *\n * @param     path      new working directory path\n * @returns   void\n */\nfunction pushd(path) {\n  shell.pushd(path);\n  _checkShell('pushd');\n}\nexports.pushd = pushd;\n/**\n * Change working directory back to previously pushed directory\n *\n * @returns   void\n */\nfunction popd() {\n  shell.popd();\n  _checkShell('popd');\n}\nexports.popd = popd;\n/**\n * Make a directory.  Creates the full path with folders in between\n * Will throw if it fails\n *\n * @param     p       path to create\n * @returns   void\n */\nfunction mkdirP(p) {\n  if (!p) {\n    throw new Error(exports.loc('LIB_ParameterIsRequired', 'p'));\n  }\n  // build a stack of directories to create\n  var stack = [];\n  var testDir = p;\n  while (true) {\n    // validate the loop is not out of control\n    if (stack.length >= (process.env['TASKLIB_TEST_MKDIRP_FAILSAFE'] || 1000)) {\n      // let the framework throw\n      exports.debug('loop is out of control');\n      fs.mkdirSync(p);\n      return;\n    }\n    exports.debug(\"testing directory '\" + testDir + \"'\");\n    var stats_1 = void 0;\n    try {\n      stats_1 = fs.statSync(testDir);\n    } catch (err) {\n      if (err.code == 'ENOENT') {\n        // validate the directory is not the drive root\n        var parentDir = path.dirname(testDir);\n        if (testDir == parentDir) {\n          throw new Error(exports.loc('LIB_MkdirFailedInvalidDriveRoot', p, testDir)); // Unable to create directory '{p}'. Root directory does not exist: '{testDir}'\n        }\n        // push the dir and test the parent\n        stack.push(testDir);\n        testDir = parentDir;\n        continue;\n      } else if (err.code == 'UNKNOWN') {\n        throw new Error(exports.loc('LIB_MkdirFailedInvalidShare', p, testDir)); // Unable to create directory '{p}'. Unable to verify the directory exists: '{testDir}'. If directory is a file share, please verify the share name is correct, the share is online, and the current process has permission to access the share.\n      } else {\n        throw err;\n      }\n    }\n    if (!stats_1.isDirectory()) {\n      throw new Error(exports.loc('LIB_MkdirFailedFileExists', p, testDir)); // Unable to create directory '{p}'. Conflicting file exists: '{testDir}'\n    }\n    // testDir exists\n    break;\n  }\n  // create each directory\n  while (stack.length) {\n    var dir = stack.pop(); // non-null because `stack.length` was truthy\n    exports.debug(\"mkdir '\" + dir + \"'\");\n    try {\n      fs.mkdirSync(dir);\n    } catch (err) {\n      throw new Error(exports.loc('LIB_MkdirFailed', p, err.message)); // Unable to create directory '{p}'. {err.message}\n    }\n  }\n}\n\nexports.mkdirP = mkdirP;\n/**\n * Resolves a sequence of paths or path segments into an absolute path.\n * Calls node.js path.resolve()\n * Allows L0 testing with consistent path formats on Mac/Linux and Windows in the mock implementation\n * @param pathSegments\n * @returns {string}\n */\nfunction resolve() {\n  var pathSegments = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    pathSegments[_i] = arguments[_i];\n  }\n  var absolutePath = path.resolve.apply(this, pathSegments);\n  exports.debug('Absolute path for pathSegments: ' + pathSegments + ' = ' + absolutePath);\n  return absolutePath;\n}\nexports.resolve = resolve;\nexports.which = im._which;\n/**\n * Returns array of files in the given path, or in current directory if no path provided.  See shelljs.ls\n * @param  {string}   options  Available options: -R (recursive), -A (all files, include files beginning with ., except for . and ..)\n * @param  {string[]} paths    Paths to search.\n * @return {string[]}          An array of files in the given path(s).\n */\nfunction ls(options, paths) {\n  if (options) {\n    return shell.ls(options, paths);\n  } else {\n    return shell.ls(paths);\n  }\n}\nexports.ls = ls;\n/**\n * Copies a file or folder.\n *\n * @param     source     source path\n * @param     dest       destination path\n * @param     options    string -r, -f or -rf for recursive and force\n * @param     continueOnError optional. whether to continue on error\n * @param     retryCount optional. Retry count to copy the file. It might help to resolve intermittent issues e.g. with UNC target paths on a remote host.\n */\nfunction cp(source, dest, options, continueOnError, retryCount) {\n  if (retryCount === void 0) {\n    retryCount = 0;\n  }\n  while (retryCount >= 0) {\n    try {\n      if (options) {\n        shell.cp(options, source, dest);\n      } else {\n        shell.cp(source, dest);\n      }\n      _checkShell('cp', false);\n      break;\n    } catch (e) {\n      if (retryCount <= 0) {\n        if (continueOnError) {\n          exports.warning(e);\n          break;\n        } else {\n          throw e;\n        }\n      } else {\n        console.log(exports.loc('LIB_CopyFileFailed', retryCount));\n        retryCount--;\n      }\n    }\n  }\n}\nexports.cp = cp;\n/**\n * Moves a path.\n *\n * @param     source     source path\n * @param     dest       destination path\n * @param     options    string -f or -n for force and no clobber\n * @param     continueOnError optional. whether to continue on error\n */\nfunction mv(source, dest, options, continueOnError) {\n  if (options) {\n    shell.mv(options, source, dest);\n  } else {\n    shell.mv(source, dest);\n  }\n  _checkShell('mv', continueOnError);\n}\nexports.mv = mv;\n/**\n * Tries to execute a function a specified number of times.\n *\n * @param   func            a function to be executed.\n * @param   args            executed function arguments array.\n * @param   retryOptions    optional. Defaults to { continueOnError: false, retryCount: 0 }.\n * @returns the same as the usual function.\n */\nfunction retry(func, args, retryOptions) {\n  if (retryOptions === void 0) {\n    retryOptions = {\n      continueOnError: false,\n      retryCount: 0\n    };\n  }\n  while (retryOptions.retryCount >= 0) {\n    try {\n      return func.apply(void 0, args);\n    } catch (e) {\n      if (retryOptions.retryCount <= 0) {\n        if (retryOptions.continueOnError) {\n          exports.warning(e);\n          break;\n        } else {\n          throw e;\n        }\n      } else {\n        exports.debug(\"Attempt to execute function \\\"\" + (func === null || func === void 0 ? void 0 : func.name) + \"\\\" failed, retries left: \" + retryOptions.retryCount);\n        retryOptions.retryCount--;\n      }\n    }\n  }\n}\nexports.retry = retry;\n/**\n * Gets info about item stats.\n *\n * @param path                      a path to the item to be processed.\n * @param followSymbolicLink        indicates whether to traverse descendants of symbolic link directories.\n * @param allowBrokenSymbolicLinks  when true, broken symbolic link will not cause an error.\n * @returns fs.Stats\n */\nfunction _getStats(path, followSymbolicLink, allowBrokenSymbolicLinks) {\n  // stat returns info about the target of a symlink (or symlink chain),\n  // lstat returns info about a symlink itself\n  var stats;\n  if (followSymbolicLink) {\n    try {\n      // use stat (following symlinks)\n      stats = fs.statSync(path);\n    } catch (err) {\n      if (err.code == 'ENOENT' && allowBrokenSymbolicLinks) {\n        // fallback to lstat (broken symlinks allowed)\n        stats = fs.lstatSync(path);\n        exports.debug(\"  \" + path + \" (broken symlink)\");\n      } else {\n        throw err;\n      }\n    }\n  } else {\n    // use lstat (not following symlinks)\n    stats = fs.lstatSync(path);\n  }\n  return stats;\n}\n/**\n * Recursively finds all paths a given path. Returns an array of paths.\n *\n * @param     findPath  path to search\n * @param     options   optional. defaults to { followSymbolicLinks: true }. following soft links is generally appropriate unless deleting files.\n * @returns   string[]\n */\nfunction find(findPath, options) {\n  if (!findPath) {\n    exports.debug('no path specified');\n    return [];\n  }\n  // normalize the path, otherwise the first result is inconsistently formatted from the rest of the results\n  // because path.join() performs normalization.\n  findPath = path.normalize(findPath);\n  // debug trace the parameters\n  exports.debug(\"findPath: '\" + findPath + \"'\");\n  options = options || _getDefaultFindOptions();\n  _debugFindOptions(options);\n  // return empty if not exists\n  try {\n    fs.lstatSync(findPath);\n  } catch (err) {\n    if (err.code == 'ENOENT') {\n      exports.debug('0 results');\n      return [];\n    }\n    throw err;\n  }\n  try {\n    var result = [];\n    // push the first item\n    var stack = [new _FindItem(findPath, 1)];\n    var traversalChain = []; // used to detect cycles\n    var _loop_1 = function _loop_1() {\n      // pop the next item and push to the result array\n      var item = stack.pop(); // non-null because `stack.length` was truthy\n      var stats_2 = void 0;\n      try {\n        // `item.path` equals `findPath` for the first item to be processed, when the `result` array is empty\n        var isPathToSearch = !result.length;\n        // following specified symlinks only if current path equals specified path\n        var followSpecifiedSymbolicLink = options.followSpecifiedSymbolicLink && isPathToSearch;\n        // following all symlinks or following symlink for the specified path\n        var followSymbolicLink = options.followSymbolicLinks || followSpecifiedSymbolicLink;\n        // stat the item. The stat info is used further below to determine whether to traverse deeper\n        stats_2 = _getStats(item.path, followSymbolicLink, options.allowBrokenSymbolicLinks);\n      } catch (err) {\n        if (err.code == 'ENOENT' && options.skipMissingFiles) {\n          exports.warning(\"No such file or directory: \\\"\" + item.path + \"\\\" - skipping.\");\n          return \"continue\";\n        }\n        throw err;\n      }\n      result.push(item.path);\n      // note, isDirectory() returns false for the lstat of a symlink\n      if (stats_2.isDirectory()) {\n        exports.debug(\"  \" + item.path + \" (directory)\");\n        if (options.followSymbolicLinks) {\n          // get the realpath\n          var realPath_1;\n          if (im._isUncPath(item.path)) {\n            // Sometimes there are spontaneous issues when working with unc-paths, so retries have been added for them.\n            realPath_1 = retry(fs.realpathSync, [item.path], {\n              continueOnError: false,\n              retryCount: 5\n            });\n          } else {\n            realPath_1 = fs.realpathSync(item.path);\n          }\n          // fixup the traversal chain to match the item level\n          while (traversalChain.length >= item.level) {\n            traversalChain.pop();\n          }\n          // test for a cycle\n          if (traversalChain.some(function (x) {\n            return x == realPath_1;\n          })) {\n            exports.debug('    cycle detected');\n            return \"continue\";\n          }\n          // update the traversal chain\n          traversalChain.push(realPath_1);\n        }\n        // push the child items in reverse onto the stack\n        var childLevel_1 = item.level + 1;\n        var childItems = fs.readdirSync(item.path).map(function (childName) {\n          return new _FindItem(path.join(item.path, childName), childLevel_1);\n        });\n        for (var i = childItems.length - 1; i >= 0; i--) {\n          stack.push(childItems[i]);\n        }\n      } else {\n        exports.debug(\"  \" + item.path + \" (file)\");\n      }\n    };\n    while (stack.length) {\n      _loop_1();\n    }\n    exports.debug(result.length + \" results\");\n    return result;\n  } catch (err) {\n    throw new Error(exports.loc('LIB_OperationFailed', 'find', err.message));\n  }\n}\nexports.find = find;\nvar _FindItem = /** @class */function () {\n  function _FindItem(path, level) {\n    this.path = path;\n    this.level = level;\n  }\n  return _FindItem;\n}();\nfunction _debugFindOptions(options) {\n  exports.debug(\"findOptions.allowBrokenSymbolicLinks: '\" + options.allowBrokenSymbolicLinks + \"'\");\n  exports.debug(\"findOptions.followSpecifiedSymbolicLink: '\" + options.followSpecifiedSymbolicLink + \"'\");\n  exports.debug(\"findOptions.followSymbolicLinks: '\" + options.followSymbolicLinks + \"'\");\n  exports.debug(\"findOptions.skipMissingFiles: '\" + options.skipMissingFiles + \"'\");\n}\nfunction _getDefaultFindOptions() {\n  return {\n    allowBrokenSymbolicLinks: false,\n    followSpecifiedSymbolicLink: true,\n    followSymbolicLinks: true,\n    skipMissingFiles: false\n  };\n}\n/**\n * Prefer tl.find() and tl.match() instead. This function is for backward compatibility\n * when porting tasks to Node from the PowerShell or PowerShell3 execution handler.\n *\n * @param    rootDirectory      path to root unrooted patterns with\n * @param    pattern            include and exclude patterns\n * @param    includeFiles       whether to include files in the result. defaults to true when includeFiles and includeDirectories are both false\n * @param    includeDirectories whether to include directories in the result\n * @returns  string[]\n */\nfunction legacyFindFiles(rootDirectory, pattern, includeFiles, includeDirectories) {\n  if (!pattern) {\n    throw new Error('pattern parameter cannot be empty');\n  }\n  exports.debug(\"legacyFindFiles rootDirectory: '\" + rootDirectory + \"'\");\n  exports.debug(\"pattern: '\" + pattern + \"'\");\n  exports.debug(\"includeFiles: '\" + includeFiles + \"'\");\n  exports.debug(\"includeDirectories: '\" + includeDirectories + \"'\");\n  if (!includeFiles && !includeDirectories) {\n    includeFiles = true;\n  }\n  // organize the patterns into include patterns and exclude patterns\n  var includePatterns = [];\n  var excludePatterns = [];\n  pattern = pattern.replace(/;;/g, '\\0');\n  for (var _i = 0, _a = pattern.split(';'); _i < _a.length; _i++) {\n    var pat = _a[_i];\n    if (!pat) {\n      continue;\n    }\n    pat = pat.replace(/\\0/g, ';');\n    // determine whether include pattern and remove any include/exclude prefix.\n    // include patterns start with +: or anything other than -:\n    // exclude patterns start with -:\n    var isIncludePattern = void 0;\n    if (im._startsWith(pat, '+:')) {\n      pat = pat.substring(2);\n      isIncludePattern = true;\n    } else if (im._startsWith(pat, '-:')) {\n      pat = pat.substring(2);\n      isIncludePattern = false;\n    } else {\n      isIncludePattern = true;\n    }\n    // validate pattern does not end with a slash\n    if (im._endsWith(pat, '/') || process.platform == 'win32' && im._endsWith(pat, '\\\\')) {\n      throw new Error(exports.loc('LIB_InvalidPattern', pat));\n    }\n    // root the pattern\n    if (rootDirectory && !path.isAbsolute(pat)) {\n      pat = path.join(rootDirectory, pat);\n      // remove trailing slash sometimes added by path.join() on Windows, e.g.\n      //      path.join('\\\\\\\\hello', 'world') => '\\\\\\\\hello\\\\world\\\\'\n      //      path.join('//hello', 'world') => '\\\\\\\\hello\\\\world\\\\'\n      if (im._endsWith(pat, '\\\\')) {\n        pat = pat.substring(0, pat.length - 1);\n      }\n    }\n    if (isIncludePattern) {\n      includePatterns.push(pat);\n    } else {\n      excludePatterns.push(im._legacyFindFiles_convertPatternToRegExp(pat));\n    }\n  }\n  // find and apply patterns\n  var count = 0;\n  var result = _legacyFindFiles_getMatchingItems(includePatterns, excludePatterns, !!includeFiles, !!includeDirectories);\n  exports.debug('all matches:');\n  for (var _b = 0, result_1 = result; _b < result_1.length; _b++) {\n    var resultItem = result_1[_b];\n    exports.debug(' ' + resultItem);\n  }\n  exports.debug('total matched: ' + result.length);\n  return result;\n}\nexports.legacyFindFiles = legacyFindFiles;\nfunction _legacyFindFiles_getMatchingItems(includePatterns, excludePatterns, includeFiles, includeDirectories) {\n  exports.debug('getMatchingItems()');\n  for (var _i = 0, includePatterns_1 = includePatterns; _i < includePatterns_1.length; _i++) {\n    var pattern = includePatterns_1[_i];\n    exports.debug(\"includePattern: '\" + pattern + \"'\");\n  }\n  for (var _a = 0, excludePatterns_1 = excludePatterns; _a < excludePatterns_1.length; _a++) {\n    var pattern = excludePatterns_1[_a];\n    exports.debug(\"excludePattern: \" + pattern);\n  }\n  exports.debug('includeFiles: ' + includeFiles);\n  exports.debug('includeDirectories: ' + includeDirectories);\n  var allFiles = {};\n  var _loop_2 = function _loop_2(pattern) {\n    // determine the directory to search\n    //\n    // note, getDirectoryName removes redundant path separators\n    var findPath = void 0;\n    var starIndex = pattern.indexOf('*');\n    var questionIndex = pattern.indexOf('?');\n    if (starIndex < 0 && questionIndex < 0) {\n      // if no wildcards are found, use the directory name portion of the path.\n      // if there is no directory name (file name only in pattern or drive root),\n      // this will return empty string.\n      findPath = im._getDirectoryName(pattern);\n    } else {\n      // extract the directory prior to the first wildcard\n      var index = Math.min(starIndex >= 0 ? starIndex : questionIndex, questionIndex >= 0 ? questionIndex : starIndex);\n      findPath = im._getDirectoryName(pattern.substring(0, index));\n    }\n    // note, due to this short-circuit and the above usage of getDirectoryName, this\n    // function has the same limitations regarding drive roots as the powershell\n    // implementation.\n    //\n    // also note, since getDirectoryName eliminates slash redundancies, some additional\n    // work may be required if removal of this limitation is attempted.\n    if (!findPath) {\n      return \"continue\";\n    }\n    var patternRegex = im._legacyFindFiles_convertPatternToRegExp(pattern);\n    // find files/directories\n    var items = find(findPath, {\n      followSymbolicLinks: true\n    }).filter(function (item) {\n      if (includeFiles && includeDirectories) {\n        return true;\n      }\n      var isDir = fs.statSync(item).isDirectory();\n      return includeFiles && !isDir || includeDirectories && isDir;\n    }).forEach(function (item) {\n      var normalizedPath = process.platform == 'win32' ? item.replace(/\\\\/g, '/') : item; // normalize separators\n      // **/times/** will not match C:/fun/times because there isn't a trailing slash\n      // so try both if including directories\n      var alternatePath = normalizedPath + \"/\"; // potential bug: it looks like this will result in a false\n      // positive if the item is a regular file and not a directory\n      var isMatch = false;\n      if (patternRegex.test(normalizedPath) || includeDirectories && patternRegex.test(alternatePath)) {\n        isMatch = true;\n        // test whether the path should be excluded\n        for (var _i = 0, excludePatterns_2 = excludePatterns; _i < excludePatterns_2.length; _i++) {\n          var regex = excludePatterns_2[_i];\n          if (regex.test(normalizedPath) || includeDirectories && regex.test(alternatePath)) {\n            isMatch = false;\n            break;\n          }\n        }\n      }\n      if (isMatch) {\n        allFiles[item] = item;\n      }\n    });\n  };\n  for (var _b = 0, includePatterns_2 = includePatterns; _b < includePatterns_2.length; _b++) {\n    var pattern = includePatterns_2[_b];\n    _loop_2(pattern);\n  }\n  return Object.keys(allFiles).sort();\n}\n/**\n * Remove a path recursively with force\n *\n * @param     inputPath path to remove\n * @throws    when the file or directory exists but could not be deleted.\n */\nfunction rmRF(inputPath) {\n  exports.debug('rm -rf ' + inputPath);\n  if (getPlatform() == Platform.Windows) {\n    // Node doesn't provide a delete operation, only an unlink function. This means that if the file is being used by another\n    // program (e.g. antivirus), it won't be deleted. To address this, we shell out the work to rd/del.\n    try {\n      if (fs.statSync(inputPath).isDirectory()) {\n        exports.debug('removing directory ' + inputPath);\n        childProcess.execSync(\"rd /s /q \\\"\" + inputPath + \"\\\"\");\n      } else {\n        exports.debug('removing file ' + inputPath);\n        childProcess.execSync(\"del /f /a \\\"\" + inputPath + \"\\\"\");\n      }\n    } catch (err) {\n      // if you try to delete a file that doesn't exist, desired result is achieved\n      // other errors are valid\n      if (err.code != 'ENOENT') {\n        throw new Error(exports.loc('LIB_OperationFailed', 'rmRF', err.message));\n      }\n    }\n    // Shelling out fails to remove a symlink folder with missing source, this unlink catches that\n    try {\n      fs.unlinkSync(inputPath);\n    } catch (err) {\n      // if you try to delete a file that doesn't exist, desired result is achieved\n      // other errors are valid\n      if (err.code != 'ENOENT') {\n        throw new Error(exports.loc('LIB_OperationFailed', 'rmRF', err.message));\n      }\n    }\n  } else {\n    // get the lstats in order to workaround a bug in shelljs@0.3.0 where symlinks\n    // with missing targets are not handled correctly by \"rm('-rf', path)\"\n    var lstats = void 0;\n    try {\n      lstats = fs.lstatSync(inputPath);\n    } catch (err) {\n      // if you try to delete a file that doesn't exist, desired result is achieved\n      // other errors are valid\n      if (err.code == 'ENOENT') {\n        return;\n      }\n      throw new Error(exports.loc('LIB_OperationFailed', 'rmRF', err.message));\n    }\n    if (lstats.isDirectory()) {\n      exports.debug('removing directory');\n      shell.rm('-rf', inputPath);\n      var errMsg = shell.error();\n      if (errMsg) {\n        throw new Error(exports.loc('LIB_OperationFailed', 'rmRF', errMsg));\n      }\n      return;\n    }\n    exports.debug('removing file');\n    try {\n      fs.unlinkSync(inputPath);\n    } catch (err) {\n      throw new Error(exports.loc('LIB_OperationFailed', 'rmRF', err.message));\n    }\n  }\n}\nexports.rmRF = rmRF;\n/**\n * Exec a tool.  Convenience wrapper over ToolRunner to exec with args in one call.\n * Output will be streamed to the live console.\n * Returns promise with return code\n *\n * @param     tool     path to tool to exec\n * @param     args     an arg string or array of args\n * @param     options  optional exec options.  See IExecOptions\n * @returns   number\n */\nfunction exec(tool, args, options) {\n  var tr = this.tool(tool);\n  tr.on('debug', function (data) {\n    exports.debug(data);\n  });\n  if (args) {\n    if (args instanceof Array) {\n      tr.arg(args);\n    } else if (typeof args === 'string') {\n      tr.line(args);\n    }\n  }\n  return tr.exec(options);\n}\nexports.exec = exec;\n/**\n * Exec a tool synchronously.  Convenience wrapper over ToolRunner to execSync with args in one call.\n * Output will be *not* be streamed to the live console.  It will be returned after execution is complete.\n * Appropriate for short running tools\n * Returns IExecResult with output and return code\n *\n * @param     tool     path to tool to exec\n * @param     args     an arg string or array of args\n * @param     options  optional exec options.  See IExecSyncOptions\n * @returns   IExecSyncResult\n */\nfunction execSync(tool, args, options) {\n  var tr = this.tool(tool);\n  tr.on('debug', function (data) {\n    exports.debug(data);\n  });\n  if (args) {\n    if (args instanceof Array) {\n      tr.arg(args);\n    } else if (typeof args === 'string') {\n      tr.line(args);\n    }\n  }\n  return tr.execSync(options);\n}\nexports.execSync = execSync;\n/**\n * Convenience factory to create a ToolRunner.\n *\n * @param     tool     path to tool to exec\n * @returns   ToolRunner\n */\nfunction tool(tool) {\n  var tr = new trm.ToolRunner(tool);\n  tr.on('debug', function (message) {\n    exports.debug(message);\n  });\n  return tr;\n}\nexports.tool = tool;\n/**\n * Applies glob patterns to a list of paths. Supports interleaved exclude patterns.\n *\n * @param  list         array of paths\n * @param  patterns     patterns to apply. supports interleaved exclude patterns.\n * @param  patternRoot  optional. default root to apply to unrooted patterns. not applied to basename-only patterns when matchBase:true.\n * @param  options      optional. defaults to { dot: true, nobrace: true, nocase: process.platform == 'win32' }.\n */\nfunction match(list, patterns, patternRoot, options) {\n  // trace parameters\n  exports.debug(\"patternRoot: '\" + patternRoot + \"'\");\n  options = options || _getDefaultMatchOptions(); // default match options\n  _debugMatchOptions(options);\n  // convert pattern to an array\n  if (typeof patterns == 'string') {\n    patterns = [patterns];\n  }\n  // hashtable to keep track of matches\n  var map = {};\n  var originalOptions = options;\n  for (var _i = 0, patterns_1 = patterns; _i < patterns_1.length; _i++) {\n    var pattern = patterns_1[_i];\n    exports.debug(\"pattern: '\" + pattern + \"'\");\n    // trim and skip empty\n    pattern = (pattern || '').trim();\n    if (!pattern) {\n      exports.debug('skipping empty pattern');\n      continue;\n    }\n    // clone match options\n    var options_1 = im._cloneMatchOptions(originalOptions);\n    // skip comments\n    if (!options_1.nocomment && im._startsWith(pattern, '#')) {\n      exports.debug('skipping comment');\n      continue;\n    }\n    // set nocomment - brace expansion could result in a leading '#'\n    options_1.nocomment = true;\n    // determine whether pattern is include or exclude\n    var negateCount = 0;\n    if (!options_1.nonegate) {\n      while (pattern.charAt(negateCount) == '!') {\n        negateCount++;\n      }\n      pattern = pattern.substring(negateCount); // trim leading '!'\n      if (negateCount) {\n        exports.debug(\"trimmed leading '!'. pattern: '\" + pattern + \"'\");\n      }\n    }\n    var isIncludePattern = negateCount == 0 || negateCount % 2 == 0 && !options_1.flipNegate || negateCount % 2 == 1 && options_1.flipNegate;\n    // set nonegate - brace expansion could result in a leading '!'\n    options_1.nonegate = true;\n    options_1.flipNegate = false;\n    // expand braces - required to accurately root patterns\n    var expanded = void 0;\n    var preExpanded = pattern;\n    if (options_1.nobrace) {\n      expanded = [pattern];\n    } else {\n      // convert slashes on Windows before calling braceExpand(). unfortunately this means braces cannot\n      // be escaped on Windows, this limitation is consistent with current limitations of minimatch (3.0.3).\n      exports.debug('expanding braces');\n      var convertedPattern = process.platform == 'win32' ? pattern.replace(/\\\\/g, '/') : pattern;\n      expanded = minimatch.braceExpand(convertedPattern);\n    }\n    // set nobrace\n    options_1.nobrace = true;\n    for (var _a = 0, expanded_1 = expanded; _a < expanded_1.length; _a++) {\n      var pattern_1 = expanded_1[_a];\n      if (expanded.length != 1 || pattern_1 != preExpanded) {\n        exports.debug(\"pattern: '\" + pattern_1 + \"'\");\n      }\n      // trim and skip empty\n      pattern_1 = (pattern_1 || '').trim();\n      if (!pattern_1) {\n        exports.debug('skipping empty pattern');\n        continue;\n      }\n      // root the pattern when all of the following conditions are true:\n      if (patternRoot &&\n      // patternRoot supplied\n      !im._isRooted(pattern_1) && (\n      // AND pattern not rooted\n      // AND matchBase:false or not basename only\n      !options_1.matchBase || (process.platform == 'win32' ? pattern_1.replace(/\\\\/g, '/') : pattern_1).indexOf('/') >= 0)) {\n        pattern_1 = im._ensureRooted(patternRoot, pattern_1);\n        exports.debug(\"rooted pattern: '\" + pattern_1 + \"'\");\n      }\n      if (isIncludePattern) {\n        // apply the pattern\n        exports.debug('applying include pattern against original list');\n        var matchResults = minimatch.match(list, pattern_1, options_1);\n        exports.debug(matchResults.length + ' matches');\n        // union the results\n        for (var _b = 0, matchResults_1 = matchResults; _b < matchResults_1.length; _b++) {\n          var matchResult = matchResults_1[_b];\n          map[matchResult] = true;\n        }\n      } else {\n        // apply the pattern\n        exports.debug('applying exclude pattern against original list');\n        var matchResults = minimatch.match(list, pattern_1, options_1);\n        exports.debug(matchResults.length + ' matches');\n        // substract the results\n        for (var _c = 0, matchResults_2 = matchResults; _c < matchResults_2.length; _c++) {\n          var matchResult = matchResults_2[_c];\n          delete map[matchResult];\n        }\n      }\n    }\n  }\n  // return a filtered version of the original list (preserves order and prevents duplication)\n  var result = list.filter(function (item) {\n    return map.hasOwnProperty(item);\n  });\n  exports.debug(result.length + ' final results');\n  return result;\n}\nexports.match = match;\n/**\n * Filter to apply glob patterns\n *\n * @param  pattern  pattern to apply\n * @param  options  optional. defaults to { dot: true, nobrace: true, nocase: process.platform == 'win32' }.\n */\nfunction filter(pattern, options) {\n  options = options || _getDefaultMatchOptions();\n  return minimatch.filter(pattern, options);\n}\nexports.filter = filter;\nfunction _debugMatchOptions(options) {\n  exports.debug(\"matchOptions.debug: '\" + options.debug + \"'\");\n  exports.debug(\"matchOptions.nobrace: '\" + options.nobrace + \"'\");\n  exports.debug(\"matchOptions.noglobstar: '\" + options.noglobstar + \"'\");\n  exports.debug(\"matchOptions.dot: '\" + options.dot + \"'\");\n  exports.debug(\"matchOptions.noext: '\" + options.noext + \"'\");\n  exports.debug(\"matchOptions.nocase: '\" + options.nocase + \"'\");\n  exports.debug(\"matchOptions.nonull: '\" + options.nonull + \"'\");\n  exports.debug(\"matchOptions.matchBase: '\" + options.matchBase + \"'\");\n  exports.debug(\"matchOptions.nocomment: '\" + options.nocomment + \"'\");\n  exports.debug(\"matchOptions.nonegate: '\" + options.nonegate + \"'\");\n  exports.debug(\"matchOptions.flipNegate: '\" + options.flipNegate + \"'\");\n}\nfunction _getDefaultMatchOptions() {\n  return {\n    debug: false,\n    nobrace: true,\n    noglobstar: false,\n    dot: true,\n    noext: false,\n    nocase: process.platform == 'win32',\n    nonull: false,\n    matchBase: false,\n    nocomment: false,\n    nonegate: false,\n    flipNegate: false\n  };\n}\n/**\n * Determines the find root from a list of patterns. Performs the find and then applies the glob patterns.\n * Supports interleaved exclude patterns. Unrooted patterns are rooted using defaultRoot, unless\n * matchOptions.matchBase is specified and the pattern is a basename only. For matchBase cases, the\n * defaultRoot is used as the find root.\n *\n * @param  defaultRoot   default path to root unrooted patterns. falls back to System.DefaultWorkingDirectory or process.cwd().\n * @param  patterns      pattern or array of patterns to apply\n * @param  findOptions   defaults to { followSymbolicLinks: true }. following soft links is generally appropriate unless deleting files.\n * @param  matchOptions  defaults to { dot: true, nobrace: true, nocase: process.platform == 'win32' }\n */\nfunction findMatch(defaultRoot, patterns, findOptions, matchOptions) {\n  // apply defaults for parameters and trace\n  defaultRoot = defaultRoot || this.getVariable('system.defaultWorkingDirectory') || process.cwd();\n  exports.debug(\"defaultRoot: '\" + defaultRoot + \"'\");\n  patterns = patterns || [];\n  patterns = typeof patterns == 'string' ? [patterns] : patterns;\n  findOptions = findOptions || _getDefaultFindOptions();\n  _debugFindOptions(findOptions);\n  matchOptions = matchOptions || _getDefaultMatchOptions();\n  _debugMatchOptions(matchOptions);\n  // normalize slashes for root dir\n  defaultRoot = im._normalizeSeparators(defaultRoot);\n  var results = {};\n  var originalMatchOptions = matchOptions;\n  for (var _i = 0, _a = patterns || []; _i < _a.length; _i++) {\n    var pattern = _a[_i];\n    exports.debug(\"pattern: '\" + pattern + \"'\");\n    // trim and skip empty\n    pattern = (pattern || '').trim();\n    if (!pattern) {\n      exports.debug('skipping empty pattern');\n      continue;\n    }\n    // clone match options\n    var matchOptions_1 = im._cloneMatchOptions(originalMatchOptions);\n    // skip comments\n    if (!matchOptions_1.nocomment && im._startsWith(pattern, '#')) {\n      exports.debug('skipping comment');\n      continue;\n    }\n    // set nocomment - brace expansion could result in a leading '#'\n    matchOptions_1.nocomment = true;\n    // determine whether pattern is include or exclude\n    var negateCount = 0;\n    if (!matchOptions_1.nonegate) {\n      while (pattern.charAt(negateCount) == '!') {\n        negateCount++;\n      }\n      pattern = pattern.substring(negateCount); // trim leading '!'\n      if (negateCount) {\n        exports.debug(\"trimmed leading '!'. pattern: '\" + pattern + \"'\");\n      }\n    }\n    var isIncludePattern = negateCount == 0 || negateCount % 2 == 0 && !matchOptions_1.flipNegate || negateCount % 2 == 1 && matchOptions_1.flipNegate;\n    // set nonegate - brace expansion could result in a leading '!'\n    matchOptions_1.nonegate = true;\n    matchOptions_1.flipNegate = false;\n    // expand braces - required to accurately interpret findPath\n    var expanded = void 0;\n    var preExpanded = pattern;\n    if (matchOptions_1.nobrace) {\n      expanded = [pattern];\n    } else {\n      // convert slashes on Windows before calling braceExpand(). unfortunately this means braces cannot\n      // be escaped on Windows, this limitation is consistent with current limitations of minimatch (3.0.3).\n      exports.debug('expanding braces');\n      var convertedPattern = process.platform == 'win32' ? pattern.replace(/\\\\/g, '/') : pattern;\n      expanded = minimatch.braceExpand(convertedPattern);\n    }\n    // set nobrace\n    matchOptions_1.nobrace = true;\n    for (var _b = 0, expanded_2 = expanded; _b < expanded_2.length; _b++) {\n      var pattern_2 = expanded_2[_b];\n      if (expanded.length != 1 || pattern_2 != preExpanded) {\n        exports.debug(\"pattern: '\" + pattern_2 + \"'\");\n      }\n      // trim and skip empty\n      pattern_2 = (pattern_2 || '').trim();\n      if (!pattern_2) {\n        exports.debug('skipping empty pattern');\n        continue;\n      }\n      if (isIncludePattern) {\n        // determine the findPath\n        var findInfo = im._getFindInfoFromPattern(defaultRoot, pattern_2, matchOptions_1);\n        var findPath = findInfo.findPath;\n        exports.debug(\"findPath: '\" + findPath + \"'\");\n        if (!findPath) {\n          exports.debug('skipping empty path');\n          continue;\n        }\n        // perform the find\n        exports.debug(\"statOnly: '\" + findInfo.statOnly + \"'\");\n        var findResults = [];\n        if (findInfo.statOnly) {\n          // simply stat the path - all path segments were used to build the path\n          try {\n            fs.statSync(findPath);\n            findResults.push(findPath);\n          } catch (err) {\n            if (err.code != 'ENOENT') {\n              throw err;\n            }\n            exports.debug('ENOENT');\n          }\n        } else {\n          findResults = find(findPath, findOptions);\n        }\n        exports.debug(\"found \" + findResults.length + \" paths\");\n        // apply the pattern\n        exports.debug('applying include pattern');\n        if (findInfo.adjustedPattern != pattern_2) {\n          exports.debug(\"adjustedPattern: '\" + findInfo.adjustedPattern + \"'\");\n          pattern_2 = findInfo.adjustedPattern;\n        }\n        var matchResults = minimatch.match(findResults, pattern_2, matchOptions_1);\n        exports.debug(matchResults.length + ' matches');\n        // union the results\n        for (var _c = 0, matchResults_3 = matchResults; _c < matchResults_3.length; _c++) {\n          var matchResult = matchResults_3[_c];\n          var key = process.platform == 'win32' ? matchResult.toUpperCase() : matchResult;\n          results[key] = matchResult;\n        }\n      } else {\n        // check if basename only and matchBase=true\n        if (matchOptions_1.matchBase && !im._isRooted(pattern_2) && (process.platform == 'win32' ? pattern_2.replace(/\\\\/g, '/') : pattern_2).indexOf('/') < 0) {\n          // do not root the pattern\n          exports.debug('matchBase and basename only');\n        } else {\n          // root the exclude pattern\n          pattern_2 = im._ensurePatternRooted(defaultRoot, pattern_2);\n          exports.debug(\"after ensurePatternRooted, pattern: '\" + pattern_2 + \"'\");\n        }\n        // apply the pattern\n        exports.debug('applying exclude pattern');\n        var matchResults = minimatch.match(Object.keys(results).map(function (key) {\n          return results[key];\n        }), pattern_2, matchOptions_1);\n        exports.debug(matchResults.length + ' matches');\n        // substract the results\n        for (var _d = 0, matchResults_4 = matchResults; _d < matchResults_4.length; _d++) {\n          var matchResult = matchResults_4[_d];\n          var key = process.platform == 'win32' ? matchResult.toUpperCase() : matchResult;\n          delete results[key];\n        }\n      }\n    }\n  }\n  var finalResult = Object.keys(results).map(function (key) {\n    return results[key];\n  }).sort();\n  exports.debug(finalResult.length + ' final results');\n  return finalResult;\n}\nexports.findMatch = findMatch;\n/**\n * Build Proxy URL in the following format: protocol://username:password@hostname:port\n * @param proxyUrl Url address of the proxy server (eg: http://example.com)\n * @param proxyUsername Proxy username (optional)\n * @param proxyPassword Proxy password (optional)\n * @returns string\n */\nfunction getProxyFormattedUrl(proxyUrl, proxyUsername, proxyPassword) {\n  var parsedUrl = new URL(proxyUrl);\n  var proxyAddress = parsedUrl.protocol + \"//\" + parsedUrl.host;\n  if (proxyUsername) {\n    proxyAddress = parsedUrl.protocol + \"//\" + proxyUsername + \":\" + proxyPassword + \"@\" + parsedUrl.host;\n  }\n  return proxyAddress;\n}\n/**\n * Gets http proxy configuration used by Build/Release agent\n *\n * @return  ProxyConfiguration\n */\nfunction getHttpProxyConfiguration(requestUrl) {\n  var proxyUrl = exports.getVariable('Agent.ProxyUrl');\n  if (proxyUrl && proxyUrl.length > 0) {\n    var proxyUsername = exports.getVariable('Agent.ProxyUsername');\n    var proxyPassword = exports.getVariable('Agent.ProxyPassword');\n    var proxyBypassHosts = JSON.parse(exports.getVariable('Agent.ProxyBypassList') || '[]');\n    var bypass_1 = false;\n    if (requestUrl) {\n      proxyBypassHosts.forEach(function (bypassHost) {\n        if (new RegExp(bypassHost, 'i').test(requestUrl)) {\n          bypass_1 = true;\n        }\n      });\n    }\n    if (bypass_1) {\n      return null;\n    } else {\n      var proxyAddress = getProxyFormattedUrl(proxyUrl, proxyUsername, proxyPassword);\n      return {\n        proxyUrl: proxyUrl,\n        proxyUsername: proxyUsername,\n        proxyPassword: proxyPassword,\n        proxyBypassHosts: proxyBypassHosts,\n        proxyFormattedUrl: proxyAddress\n      };\n    }\n  } else {\n    return null;\n  }\n}\nexports.getHttpProxyConfiguration = getHttpProxyConfiguration;\n/**\n * Gets http certificate configuration used by Build/Release agent\n *\n * @return  CertConfiguration\n */\nfunction getHttpCertConfiguration() {\n  var ca = exports.getVariable('Agent.CAInfo');\n  var clientCert = exports.getVariable('Agent.ClientCert');\n  if (ca || clientCert) {\n    var certConfig = {};\n    certConfig.caFile = ca;\n    certConfig.certFile = clientCert;\n    if (clientCert) {\n      var clientCertKey = exports.getVariable('Agent.ClientCertKey');\n      var clientCertArchive = exports.getVariable('Agent.ClientCertArchive');\n      var clientCertPassword = exports.getVariable('Agent.ClientCertPassword');\n      certConfig.keyFile = clientCertKey;\n      certConfig.certArchiveFile = clientCertArchive;\n      certConfig.passphrase = clientCertPassword;\n    }\n    return certConfig;\n  } else {\n    return null;\n  }\n}\nexports.getHttpCertConfiguration = getHttpCertConfiguration;\n//-----------------------------------------------------\n// Test Publisher\n//-----------------------------------------------------\nvar TestPublisher = /** @class */function () {\n  function TestPublisher(testRunner) {\n    this.testRunner = testRunner;\n  }\n  TestPublisher.prototype.publish = function (resultFiles, mergeResults, platform, config, runTitle, publishRunAttachments, testRunSystem) {\n    // Could have used an initializer, but wanted to avoid reordering parameters when converting to strict null checks\n    // (A parameter cannot both be optional and have an initializer)\n    testRunSystem = testRunSystem || \"VSTSTask\";\n    var properties = {};\n    properties['type'] = this.testRunner;\n    if (mergeResults) {\n      properties['mergeResults'] = mergeResults;\n    }\n    if (platform) {\n      properties['platform'] = platform;\n    }\n    if (config) {\n      properties['config'] = config;\n    }\n    if (runTitle) {\n      properties['runTitle'] = runTitle;\n    }\n    if (publishRunAttachments) {\n      properties['publishRunAttachments'] = publishRunAttachments;\n    }\n    if (resultFiles) {\n      properties['resultFiles'] = Array.isArray(resultFiles) ? resultFiles.join() : resultFiles;\n    }\n    properties['testRunSystem'] = testRunSystem;\n    exports.command('results.publish', properties, '');\n  };\n  return TestPublisher;\n}();\nexports.TestPublisher = TestPublisher;\n//-----------------------------------------------------\n// Code coverage Publisher\n//-----------------------------------------------------\nvar CodeCoveragePublisher = /** @class */function () {\n  function CodeCoveragePublisher() {}\n  CodeCoveragePublisher.prototype.publish = function (codeCoverageTool, summaryFileLocation, reportDirectory, additionalCodeCoverageFiles) {\n    var properties = {};\n    if (codeCoverageTool) {\n      properties['codecoveragetool'] = codeCoverageTool;\n    }\n    if (summaryFileLocation) {\n      properties['summaryfile'] = summaryFileLocation;\n    }\n    if (reportDirectory) {\n      properties['reportdirectory'] = reportDirectory;\n    }\n    if (additionalCodeCoverageFiles) {\n      properties['additionalcodecoveragefiles'] = Array.isArray(additionalCodeCoverageFiles) ? additionalCodeCoverageFiles.join() : additionalCodeCoverageFiles;\n    }\n    exports.command('codecoverage.publish', properties, \"\");\n  };\n  return CodeCoveragePublisher;\n}();\nexports.CodeCoveragePublisher = CodeCoveragePublisher;\n//-----------------------------------------------------\n// Code coverage Publisher\n//-----------------------------------------------------\nvar CodeCoverageEnabler = /** @class */function () {\n  function CodeCoverageEnabler(buildTool, ccTool) {\n    this.buildTool = buildTool;\n    this.ccTool = ccTool;\n  }\n  CodeCoverageEnabler.prototype.enableCodeCoverage = function (buildProps) {\n    buildProps['buildtool'] = this.buildTool;\n    buildProps['codecoveragetool'] = this.ccTool;\n    exports.command('codecoverage.enable', buildProps, \"\");\n  };\n  return CodeCoverageEnabler;\n}();\nexports.CodeCoverageEnabler = CodeCoverageEnabler;\n//-----------------------------------------------------\n// Task Logging Commands\n//-----------------------------------------------------\n/**\n * Upload user interested file as additional log information\n * to the current timeline record.\n *\n * The file shall be available for download along with task logs.\n *\n * @param path      Path to the file that should be uploaded.\n * @returns         void\n */\nfunction uploadFile(path) {\n  exports.command(\"task.uploadfile\", null, path);\n}\nexports.uploadFile = uploadFile;\n/**\n * Instruction for the agent to update the PATH environment variable.\n * The specified directory is prepended to the PATH.\n * The updated environment variable will be reflected in subsequent tasks.\n *\n * @param path      Local directory path.\n * @returns         void\n */\nfunction prependPath(path) {\n  assertAgent(\"2.115.0\");\n  exports.command(\"task.prependpath\", null, path);\n}\nexports.prependPath = prependPath;\n/**\n * Upload and attach summary markdown to current timeline record.\n * This summary shall be added to the build/release summary and\n * not available for download with logs.\n *\n * @param path      Local directory path.\n * @returns         void\n */\nfunction uploadSummary(path) {\n  exports.command(\"task.uploadsummary\", null, path);\n}\nexports.uploadSummary = uploadSummary;\n/**\n * Upload and attach attachment to current timeline record.\n * These files are not available for download with logs.\n * These can only be referred to by extensions using the type or name values.\n *\n * @param type      Attachment type.\n * @param name      Attachment name.\n * @param path      Attachment path.\n * @returns         void\n */\nfunction addAttachment(type, name, path) {\n  exports.command(\"task.addattachment\", {\n    \"type\": type,\n    \"name\": name\n  }, path);\n}\nexports.addAttachment = addAttachment;\n/**\n * Set an endpoint field with given value.\n * Value updated will be retained in the endpoint for\n * the subsequent tasks that execute within the same job.\n *\n * @param id      Endpoint id.\n * @param field   FieldType enum of AuthParameter, DataParameter or Url.\n * @param key     Key.\n * @param value   Value for key or url.\n * @returns       void\n */\nfunction setEndpoint(id, field, key, value) {\n  exports.command(\"task.setendpoint\", {\n    \"id\": id,\n    \"field\": FieldType[field].toLowerCase(),\n    \"key\": key\n  }, value);\n}\nexports.setEndpoint = setEndpoint;\n/**\n * Set progress and current operation for current task.\n *\n * @param percent           Percentage of completion.\n * @param currentOperation  Current pperation.\n * @returns                 void\n */\nfunction setProgress(percent, currentOperation) {\n  exports.command(\"task.setprogress\", {\n    \"value\": \"\" + percent\n  }, currentOperation);\n}\nexports.setProgress = setProgress;\n/**\n * Indicates whether to write the logging command directly to the host or to the output pipeline.\n *\n * @param id            Timeline record Guid.\n * @param parentId      Parent timeline record Guid.\n * @param recordType    Record type.\n * @param recordName    Record name.\n * @param order         Order of timeline record.\n * @param startTime     Start time.\n * @param finishTime    End time.\n * @param progress      Percentage of completion.\n * @param state         TaskState enum of Unknown, Initialized, InProgress or Completed.\n * @param result        TaskResult enum of Succeeded, SucceededWithIssues, Failed, Cancelled or Skipped.\n * @param message       current operation\n * @returns             void\n */\nfunction logDetail(id, message, parentId, recordType, recordName, order, startTime, finishTime, progress, state, result) {\n  var properties = {\n    \"id\": id,\n    \"parentid\": parentId,\n    \"type\": recordType,\n    \"name\": recordName,\n    \"order\": order ? order.toString() : undefined,\n    \"starttime\": startTime,\n    \"finishtime\": finishTime,\n    \"progress\": progress ? progress.toString() : undefined,\n    \"state\": state ? TaskState[state] : undefined,\n    \"result\": result ? TaskResult[result] : undefined\n  };\n  exports.command(\"task.logdetail\", properties, message);\n}\nexports.logDetail = logDetail;\n/**\n * Log error or warning issue to timeline record of current task.\n *\n * @param type          IssueType enum of Error or Warning.\n * @param sourcePath    Source file location.\n * @param lineNumber    Line number.\n * @param columnNumber  Column number.\n * @param code          Error or warning code.\n * @param message       Error or warning message.\n * @returns             void\n */\nfunction logIssue(type, message, sourcePath, lineNumber, columnNumber, errorCode) {\n  var properties = {\n    \"type\": IssueType[type].toLowerCase(),\n    \"code\": errorCode,\n    \"sourcepath\": sourcePath,\n    \"linenumber\": lineNumber ? lineNumber.toString() : undefined,\n    \"columnnumber\": columnNumber ? columnNumber.toString() : undefined\n  };\n  exports.command(\"task.logissue\", properties, message);\n}\nexports.logIssue = logIssue;\n//-----------------------------------------------------\n// Artifact Logging Commands\n//-----------------------------------------------------\n/**\n * Upload user interested file as additional log information\n * to the current timeline record.\n *\n * The file shall be available for download along with task logs.\n *\n * @param containerFolder   Folder that the file will upload to, folder will be created if needed.\n * @param path              Path to the file that should be uploaded.\n * @param name              Artifact name.\n * @returns                 void\n */\nfunction uploadArtifact(containerFolder, path, name) {\n  exports.command(\"artifact.upload\", {\n    \"containerfolder\": containerFolder,\n    \"artifactname\": name\n  }, path);\n}\nexports.uploadArtifact = uploadArtifact;\n/**\n * Create an artifact link, artifact location is required to be\n * a file container path, VC path or UNC share path.\n *\n * The file shall be available for download along with task logs.\n *\n * @param name              Artifact name.\n * @param path              Path to the file that should be associated.\n * @param artifactType      ArtifactType enum of Container, FilePath, VersionControl, GitRef or TfvcLabel.\n * @returns                 void\n */\nfunction associateArtifact(name, path, artifactType) {\n  exports.command(\"artifact.associate\", {\n    \"type\": ArtifactType[artifactType].toLowerCase(),\n    \"artifactname\": name\n  }, path);\n}\nexports.associateArtifact = associateArtifact;\n//-----------------------------------------------------\n// Build Logging Commands\n//-----------------------------------------------------\n/**\n * Upload user interested log to build’s container “logs\\tool” folder.\n *\n * @param path      Path to the file that should be uploaded.\n * @returns         void\n */\nfunction uploadBuildLog(path) {\n  exports.command(\"build.uploadlog\", null, path);\n}\nexports.uploadBuildLog = uploadBuildLog;\n/**\n * Update build number for current build.\n *\n * @param value     Value to be assigned as the build number.\n * @returns         void\n */\nfunction updateBuildNumber(value) {\n  exports.command(\"build.updatebuildnumber\", null, value);\n}\nexports.updateBuildNumber = updateBuildNumber;\n/**\n * Add a tag for current build.\n *\n * @param value     Tag value.\n * @returns         void\n */\nfunction addBuildTag(value) {\n  exports.command(\"build.addbuildtag\", null, value);\n}\nexports.addBuildTag = addBuildTag;\n//-----------------------------------------------------\n// Release Logging Commands\n//-----------------------------------------------------\n/**\n * Update release name for current release.\n *\n * @param value     Value to be assigned as the release name.\n * @returns         void\n */\nfunction updateReleaseName(name) {\n  assertAgent(\"2.132.0\");\n  exports.command(\"release.updatereleasename\", null, name);\n}\nexports.updateReleaseName = updateReleaseName;\n//-----------------------------------------------------\n// Tools\n//-----------------------------------------------------\nexports.TaskCommand = tcm.TaskCommand;\nexports.commandFromString = tcm.commandFromString;\nexports.ToolRunner = trm.ToolRunner;\n//-----------------------------------------------------\n// Validation Checks\n//-----------------------------------------------------\n// async await needs generators in node 4.x+\nif (semver.lt(process.versions.node, '4.2.0')) {\n  exports.warning('Tasks require a new agent.  Upgrade your agent or node to 4.2.0 or later');\n}\n//-------------------------------------------------------------------\n// Populate the vault with sensitive data.  Inputs and Endpoints\n//-------------------------------------------------------------------\n// avoid loading twice (overwrites .taskkey)\nif (!global['_vsts_task_lib_loaded']) {\n  im._loadData();\n  im._exposeProxySettings();\n  im._exposeCertSettings();\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\azure-pipelines-task-lib\\task.js");

/***/ }),

/***/ "./node_modules/azure-pipelines-task-lib/taskcommand.js":
/*!**************************************************************!*\
  !*** ./node_modules/azure-pipelines-task-lib/taskcommand.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.commandFromString = exports.TaskCommand = void 0;\n//\n// Command Format:\n//    ##vso[artifact.command key=value;key=value]user message\n//    \n// Examples:\n//    ##vso[task.progress value=58]\n//    ##vso[task.issue type=warning;]This is the user warning message\n//\nvar CMD_PREFIX = '##vso[';\nvar TaskCommand = /** @class */function () {\n  function TaskCommand(command, properties, message) {\n    if (!command) {\n      command = 'missing.command';\n    }\n    this.command = command;\n    this.properties = properties;\n    this.message = message;\n  }\n  TaskCommand.prototype.toString = function () {\n    var cmdStr = CMD_PREFIX + this.command;\n    if (this.properties && Object.keys(this.properties).length > 0) {\n      cmdStr += ' ';\n      for (var key in this.properties) {\n        if (this.properties.hasOwnProperty(key)) {\n          var val = this.properties[key];\n          if (val) {\n            // safely append the val - avoid blowing up when attempting to\n            // call .replace() if message is not a string for some reason\n            cmdStr += key + '=' + escape('' + (val || '')) + ';';\n          }\n        }\n      }\n    }\n    cmdStr += ']';\n    // safely append the message - avoid blowing up when attempting to\n    // call .replace() if message is not a string for some reason\n    var message = '' + (this.message || '');\n    cmdStr += escapedata(message);\n    return cmdStr;\n  };\n  return TaskCommand;\n}();\nexports.TaskCommand = TaskCommand;\nfunction commandFromString(commandLine) {\n  var preLen = CMD_PREFIX.length;\n  var lbPos = commandLine.indexOf('[');\n  var rbPos = commandLine.indexOf(']');\n  if (lbPos == -1 || rbPos == -1 || rbPos - lbPos < 3) {\n    throw new Error('Invalid command brackets');\n  }\n  var cmdInfo = commandLine.substring(lbPos + 1, rbPos);\n  var spaceIdx = cmdInfo.indexOf(' ');\n  var command = cmdInfo;\n  var properties = {};\n  if (spaceIdx > 0) {\n    command = cmdInfo.trim().substring(0, spaceIdx);\n    var propSection = cmdInfo.trim().substring(spaceIdx + 1);\n    var propLines = propSection.split(';');\n    propLines.forEach(function (propLine) {\n      propLine = propLine.trim();\n      if (propLine.length > 0) {\n        var eqIndex = propLine.indexOf('=');\n        if (eqIndex == -1) {\n          throw new Error('Invalid property: ' + propLine);\n        }\n        var key = propLine.substring(0, eqIndex);\n        var val = propLine.substring(eqIndex + 1);\n        properties[key] = unescape(val);\n      }\n    });\n  }\n  var msg = unescapedata(commandLine.substring(rbPos + 1));\n  var cmd = new TaskCommand(command, properties, msg);\n  return cmd;\n}\nexports.commandFromString = commandFromString;\nfunction escapedata(s) {\n  return s.replace(/%/g, '%AZP25').replace(/\\r/g, '%0D').replace(/\\n/g, '%0A');\n}\nfunction unescapedata(s) {\n  return s.replace(/%0D/g, '\\r').replace(/%0A/g, '\\n').replace(/%AZP25/g, '%');\n}\nfunction escape(s) {\n  return s.replace(/%/g, '%AZP25').replace(/\\r/g, '%0D').replace(/\\n/g, '%0A').replace(/]/g, '%5D').replace(/;/g, '%3B');\n}\nfunction unescape(s) {\n  return s.replace(/%0D/g, '\\r').replace(/%0A/g, '\\n').replace(/%5D/g, ']').replace(/%3B/g, ';').replace(/%AZP25/g, '%');\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\azure-pipelines-task-lib\\taskcommand.js");

/***/ }),

/***/ "./node_modules/azure-pipelines-task-lib/toolrunner.js":
/*!*************************************************************!*\
  !*** ./node_modules/azure-pipelines-task-lib/toolrunner.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar __extends = void 0 && (void 0).__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.ToolRunner = void 0;\nvar Q = __webpack_require__(/*! q */ \"./node_modules/q/q.js\");\nvar os = __webpack_require__(/*! os */ \"os\");\nvar events = __webpack_require__(/*! events */ \"events\");\nvar child = __webpack_require__(/*! child_process */ \"child_process\");\nvar im = __webpack_require__(/*! ./internal */ \"./node_modules/azure-pipelines-task-lib/internal.js\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar ToolRunner = /** @class */function (_super) {\n  __extends(ToolRunner, _super);\n  function ToolRunner(toolPath) {\n    var _this = _super.call(this) || this;\n    _this.cmdSpecialChars = [' ', '\\t', '&', '(', ')', '[', ']', '{', '}', '^', '=', ';', '!', '\\'', '+', ',', '`', '~', '|', '<', '>', '\"'];\n    if (!toolPath) {\n      throw new Error('Parameter \\'toolPath\\' cannot be null or empty.');\n    }\n    _this.toolPath = im._which(toolPath, true);\n    _this.args = [];\n    _this._debug('toolRunner toolPath: ' + toolPath);\n    return _this;\n  }\n  ToolRunner.prototype._debug = function (message) {\n    this.emit('debug', message);\n  };\n  ToolRunner.prototype._argStringToArray = function (argString) {\n    var args = [];\n    var inQuotes = false;\n    var escaped = false;\n    var lastCharWasSpace = true;\n    var arg = '';\n    var append = function append(c) {\n      // we only escape double quotes.\n      if (escaped) {\n        if (c !== '\"') {\n          arg += '\\\\';\n        } else {\n          arg.slice(0, -1);\n        }\n      }\n      arg += c;\n      escaped = false;\n    };\n    for (var i = 0; i < argString.length; i++) {\n      var c = argString.charAt(i);\n      if (c === ' ' && !inQuotes) {\n        if (!lastCharWasSpace) {\n          args.push(arg);\n          arg = '';\n        }\n        lastCharWasSpace = true;\n        continue;\n      } else {\n        lastCharWasSpace = false;\n      }\n      if (c === '\"') {\n        if (!escaped) {\n          inQuotes = !inQuotes;\n        } else {\n          append(c);\n        }\n        continue;\n      }\n      if (c === \"\\\\\" && escaped) {\n        append(c);\n        continue;\n      }\n      if (c === \"\\\\\" && inQuotes) {\n        escaped = true;\n        continue;\n      }\n      append(c);\n      lastCharWasSpace = false;\n    }\n    if (!lastCharWasSpace) {\n      args.push(arg.trim());\n    }\n    return args;\n  };\n  ToolRunner.prototype._getCommandString = function (options, noPrefix) {\n    var _this = this;\n    var toolPath = this._getSpawnFileName();\n    var args = this._getSpawnArgs(options);\n    var cmd = noPrefix ? '' : '[command]'; // omit prefix when piped to a second tool\n    var commandParts = [];\n    if (process.platform == 'win32') {\n      // Windows + cmd file\n      if (this._isCmdFile()) {\n        commandParts.push(toolPath);\n        commandParts = commandParts.concat(args);\n      }\n      // Windows + verbatim\n      else if (options.windowsVerbatimArguments) {\n        commandParts.push(\"\\\"\" + toolPath + \"\\\"\");\n        commandParts = commandParts.concat(args);\n      } else if (options.shell) {\n        commandParts.push(this._windowsQuoteCmdArg(toolPath));\n        commandParts = commandParts.concat(args);\n      }\n      // Windows (regular)\n      else {\n        commandParts.push(this._windowsQuoteCmdArg(toolPath));\n        commandParts = commandParts.concat(args.map(function (arg) {\n          return _this._windowsQuoteCmdArg(arg);\n        }));\n      }\n    } else {\n      // OSX/Linux - this can likely be improved with some form of quoting.\n      // creating processes on Unix is fundamentally different than Windows.\n      // on Unix, execvp() takes an arg array.\n      commandParts.push(toolPath);\n      commandParts = commandParts.concat(args);\n    }\n    cmd += commandParts.join(' ');\n    // append second tool\n    if (this.pipeOutputToTool) {\n      cmd += ' | ' + this.pipeOutputToTool._getCommandString(options, /*noPrefix:*/true);\n    }\n    return cmd;\n  };\n  ToolRunner.prototype._processLineBuffer = function (data, strBuffer, onLine) {\n    try {\n      var s = strBuffer + data.toString();\n      var n = s.indexOf(os.EOL);\n      while (n > -1) {\n        var line = s.substring(0, n);\n        onLine(line);\n        // the rest of the string ...\n        s = s.substring(n + os.EOL.length);\n        n = s.indexOf(os.EOL);\n      }\n      strBuffer = s;\n    } catch (err) {\n      // streaming lines to console is best effort.  Don't fail a build.\n      this._debug('error processing line');\n    }\n  };\n  /**\n   * Wraps an arg string with specified char if it's not already wrapped\n   * @returns {string} Arg wrapped with specified char\n   * @param {string} arg Input argument string\n   * @param {string} wrapChar A char input string should be wrapped with\n   */\n  ToolRunner.prototype._wrapArg = function (arg, wrapChar) {\n    if (!this._isWrapped(arg, wrapChar)) {\n      return \"\" + wrapChar + arg + wrapChar;\n    }\n    return arg;\n  };\n  /**\n   * Unwraps an arg string wrapped with specified char\n   * @param arg Arg wrapped with specified char\n   * @param wrapChar A char to be removed\n   */\n  ToolRunner.prototype._unwrapArg = function (arg, wrapChar) {\n    if (this._isWrapped(arg, wrapChar)) {\n      var pattern = new RegExp(\"(^\\\\\\\\?\" + wrapChar + \")|(\\\\\\\\?\" + wrapChar + \"$)\", 'g');\n      return arg.trim().replace(pattern, '');\n    }\n    return arg;\n  };\n  /**\n   * Determine if arg string is wrapped with specified char\n   * @param arg Input arg string\n   */\n  ToolRunner.prototype._isWrapped = function (arg, wrapChar) {\n    var pattern = new RegExp(\"^\\\\\\\\?\" + wrapChar + \".+\\\\\\\\?\" + wrapChar + \"$\");\n    return pattern.test(arg.trim());\n  };\n  ToolRunner.prototype._getSpawnFileName = function (options) {\n    if (process.platform == 'win32') {\n      if (this._isCmdFile()) {\n        return process.env['COMSPEC'] || 'cmd.exe';\n      }\n    }\n    if (options && options.shell) {\n      return this._wrapArg(this.toolPath, '\"');\n    }\n    return this.toolPath;\n  };\n  ToolRunner.prototype._getSpawnArgs = function (options) {\n    var _this = this;\n    if (process.platform == 'win32') {\n      if (this._isCmdFile()) {\n        var argline = \"/D /S /C \\\"\" + this._windowsQuoteCmdArg(this.toolPath);\n        for (var i = 0; i < this.args.length; i++) {\n          argline += ' ';\n          argline += options.windowsVerbatimArguments ? this.args[i] : this._windowsQuoteCmdArg(this.args[i]);\n        }\n        argline += '\"';\n        return [argline];\n      }\n      if (options.windowsVerbatimArguments) {\n        // note, in Node 6.x options.argv0 can be used instead of overriding args.slice and args.unshift.\n        // for more details, refer to https://github.com/nodejs/node/blob/v6.x/lib/child_process.js\n        var args_1 = this.args.slice(0); // copy the array\n        // override slice to prevent Node from creating a copy of the arg array.\n        // we need Node to use the \"unshift\" override below.\n        args_1.slice = function () {\n          if (arguments.length != 1 || arguments[0] != 0) {\n            throw new Error('Unexpected arguments passed to args.slice when windowsVerbatimArguments flag is set.');\n          }\n          return args_1;\n        };\n        // override unshift\n        //\n        // when using the windowsVerbatimArguments option, Node does not quote the tool path when building\n        // the cmdline parameter for the win32 function CreateProcess(). an unquoted space in the tool path\n        // causes problems for tools when attempting to parse their own command line args. tools typically\n        // assume their arguments begin after arg 0.\n        //\n        // by hijacking unshift, we can quote the tool path when it pushed onto the args array. Node builds\n        // the cmdline parameter from the args array.\n        //\n        // note, we can't simply pass a quoted tool path to Node for multiple reasons:\n        //   1) Node verifies the file exists (calls win32 function GetFileAttributesW) and the check returns\n        //      false if the path is quoted.\n        //   2) Node passes the tool path as the application parameter to CreateProcess, which expects the\n        //      path to be unquoted.\n        //\n        // also note, in addition to the tool path being embedded within the cmdline parameter, Node also\n        // passes the tool path to CreateProcess via the application parameter (optional parameter). when\n        // present, Windows uses the application parameter to determine which file to run, instead of\n        // interpreting the file from the cmdline parameter.\n        args_1.unshift = function () {\n          if (arguments.length != 1) {\n            throw new Error('Unexpected arguments passed to args.unshift when windowsVerbatimArguments flag is set.');\n          }\n          return Array.prototype.unshift.call(args_1, \"\\\"\" + arguments[0] + \"\\\"\"); // quote the file name\n        };\n\n        return args_1;\n      } else if (options.shell) {\n        var args = [];\n        for (var _i = 0, _a = this.args; _i < _a.length; _i++) {\n          var arg = _a[_i];\n          if (this._needQuotesForCmd(arg, '%')) {\n            args.push(this._wrapArg(arg, '\"'));\n          } else {\n            args.push(arg);\n          }\n        }\n        return args;\n      }\n    } else if (options.shell) {\n      return this.args.map(function (arg) {\n        if (_this._isWrapped(arg, \"'\")) {\n          return arg;\n        }\n        // remove wrapping double quotes to avoid escaping\n        arg = _this._unwrapArg(arg, '\"');\n        arg = _this._escapeChar(arg, '\"');\n        return _this._wrapArg(arg, '\"');\n      });\n    }\n    return this.args;\n  };\n  /**\n   * Escape specified character.\n   * @param arg String to escape char in\n   * @param charToEscape Char should be escaped\n   */\n  ToolRunner.prototype._escapeChar = function (arg, charToEscape) {\n    var escChar = \"\\\\\";\n    var output = '';\n    var charIsEscaped = false;\n    for (var _i = 0, arg_1 = arg; _i < arg_1.length; _i++) {\n      var char = arg_1[_i];\n      if (char === charToEscape && !charIsEscaped) {\n        output += escChar + char;\n      } else {\n        output += char;\n      }\n      charIsEscaped = char === escChar && !charIsEscaped;\n    }\n    return output;\n  };\n  ToolRunner.prototype._isCmdFile = function () {\n    var upperToolPath = this.toolPath.toUpperCase();\n    return im._endsWith(upperToolPath, '.CMD') || im._endsWith(upperToolPath, '.BAT');\n  };\n  /**\n   * Determine whether the cmd arg needs to be quoted. Returns true if arg contains any of special chars array.\n   * @param arg The cmd command arg.\n   * @param additionalChars Additional chars which should be also checked.\n   */\n  ToolRunner.prototype._needQuotesForCmd = function (arg, additionalChars) {\n    var specialChars = this.cmdSpecialChars;\n    if (additionalChars) {\n      specialChars = this.cmdSpecialChars.concat(additionalChars);\n    }\n    var _loop_1 = function _loop_1(char) {\n      if (specialChars.some(function (x) {\n        return x === char;\n      })) {\n        return {\n          value: true\n        };\n      }\n    };\n    for (var _i = 0, arg_2 = arg; _i < arg_2.length; _i++) {\n      var char = arg_2[_i];\n      var state_1 = _loop_1(char);\n      if (typeof state_1 === \"object\") return state_1.value;\n    }\n    return false;\n  };\n  ToolRunner.prototype._windowsQuoteCmdArg = function (arg) {\n    // for .exe, apply the normal quoting rules that libuv applies\n    if (!this._isCmdFile()) {\n      return this._uv_quote_cmd_arg(arg);\n    }\n    // otherwise apply quoting rules specific to the cmd.exe command line parser.\n    // the libuv rules are generic and are not designed specifically for cmd.exe\n    // command line parser.\n    //\n    // for a detailed description of the cmd.exe command line parser, refer to\n    // http://stackoverflow.com/questions/4094699/how-does-the-windows-command-interpreter-cmd-exe-parse-scripts/7970912#7970912\n    // need quotes for empty arg\n    if (!arg) {\n      return '\"\"';\n    }\n    // determine whether the arg needs to be quoted\n    var needsQuotes = this._needQuotesForCmd(arg);\n    // short-circuit if quotes not needed\n    if (!needsQuotes) {\n      return arg;\n    }\n    // the following quoting rules are very similar to the rules that by libuv applies.\n    //\n    // 1) wrap the string in quotes\n    //\n    // 2) double-up quotes - i.e. \" => \"\"\n    //\n    //    this is different from the libuv quoting rules. libuv replaces \" with \\\", which unfortunately\n    //    doesn't work well with a cmd.exe command line.\n    //\n    //    note, replacing \" with \"\" also works well if the arg is passed to a downstream .NET console app.\n    //    for example, the command line:\n    //          foo.exe \"myarg:\"\"my val\"\"\"\n    //    is parsed by a .NET console app into an arg array:\n    //          [ \"myarg:\\\"my val\\\"\" ]\n    //    which is the same end result when applying libuv quoting rules. although the actual\n    //    command line from libuv quoting rules would look like:\n    //          foo.exe \"myarg:\\\"my val\\\"\"\n    //\n    // 3) double-up slashes that preceed a quote,\n    //    e.g.  hello \\world    => \"hello \\world\"\n    //          hello\\\"world    => \"hello\\\\\"\"world\"\n    //          hello\\\\\"world   => \"hello\\\\\\\\\"\"world\"\n    //          hello world\\    => \"hello world\\\\\"\n    //\n    //    technically this is not required for a cmd.exe command line, or the batch argument parser.\n    //    the reasons for including this as a .cmd quoting rule are:\n    //\n    //    a) this is optimized for the scenario where the argument is passed from the .cmd file to an\n    //       external program. many programs (e.g. .NET console apps) rely on the slash-doubling rule.\n    //\n    //    b) it's what we've been doing previously (by deferring to node default behavior) and we\n    //       haven't heard any complaints about that aspect.\n    //\n    // note, a weakness of the quoting rules chosen here, is that % is not escaped. in fact, % cannot be\n    // escaped when used on the command line directly - even though within a .cmd file % can be escaped\n    // by using %%.\n    //\n    // the saving grace is, on the command line, %var% is left as-is if var is not defined. this contrasts\n    // the line parsing rules within a .cmd file, where if var is not defined it is replaced with nothing.\n    //\n    // one option that was explored was replacing % with ^% - i.e. %var% => ^%var^%. this hack would\n    // often work, since it is unlikely that var^ would exist, and the ^ character is removed when the\n    // variable is used. the problem, however, is that ^ is not removed when %* is used to pass the args\n    // to an external program.\n    //\n    // an unexplored potential solution for the % escaping problem, is to create a wrapper .cmd file.\n    // % can be escaped within a .cmd file.\n    var reverse = '\"';\n    var quote_hit = true;\n    for (var i = arg.length; i > 0; i--) {\n      // walk the string in reverse\n      reverse += arg[i - 1];\n      if (quote_hit && arg[i - 1] == '\\\\') {\n        reverse += '\\\\'; // double the slash\n      } else if (arg[i - 1] == '\"') {\n        quote_hit = true;\n        reverse += '\"'; // double the quote\n      } else {\n        quote_hit = false;\n      }\n    }\n    reverse += '\"';\n    return reverse.split('').reverse().join('');\n  };\n  ToolRunner.prototype._uv_quote_cmd_arg = function (arg) {\n    // Tool runner wraps child_process.spawn() and needs to apply the same quoting as\n    // Node in certain cases where the undocumented spawn option windowsVerbatimArguments\n    // is used.\n    //\n    // Since this function is a port of quote_cmd_arg from Node 4.x (technically, lib UV,\n    // see https://github.com/nodejs/node/blob/v4.x/deps/uv/src/win/process.c for details),\n    // pasting copyright notice from Node within this function:\n    //\n    //      Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n    //\n    //      Permission is hereby granted, free of charge, to any person obtaining a copy\n    //      of this software and associated documentation files (the \"Software\"), to\n    //      deal in the Software without restriction, including without limitation the\n    //      rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n    //      sell copies of the Software, and to permit persons to whom the Software is\n    //      furnished to do so, subject to the following conditions:\n    //\n    //      The above copyright notice and this permission notice shall be included in\n    //      all copies or substantial portions of the Software.\n    //\n    //      THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    //      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    //      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    //      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    //      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    //      FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n    //      IN THE SOFTWARE.\n    if (!arg) {\n      // Need double quotation for empty argument\n      return '\"\"';\n    }\n    if (arg.indexOf(' ') < 0 && arg.indexOf('\\t') < 0 && arg.indexOf('\"') < 0) {\n      // No quotation needed\n      return arg;\n    }\n    if (arg.indexOf('\"') < 0 && arg.indexOf('\\\\') < 0) {\n      // No embedded double quotes or backslashes, so I can just wrap\n      // quote marks around the whole thing.\n      return \"\\\"\" + arg + \"\\\"\";\n    }\n    // Expected input/output:\n    //   input : hello\"world\n    //   output: \"hello\\\"world\"\n    //   input : hello\"\"world\n    //   output: \"hello\\\"\\\"world\"\n    //   input : hello\\world\n    //   output: hello\\world\n    //   input : hello\\\\world\n    //   output: hello\\\\world\n    //   input : hello\\\"world\n    //   output: \"hello\\\\\\\"world\"\n    //   input : hello\\\\\"world\n    //   output: \"hello\\\\\\\\\\\"world\"\n    //   input : hello world\\\n    //   output: \"hello world\\\\\" - note the comment in libuv actually reads \"hello world\\\"\n    //                             but it appears the comment is wrong, it should be \"hello world\\\\\"\n    var reverse = '\"';\n    var quote_hit = true;\n    for (var i = arg.length; i > 0; i--) {\n      // walk the string in reverse\n      reverse += arg[i - 1];\n      if (quote_hit && arg[i - 1] == '\\\\') {\n        reverse += '\\\\';\n      } else if (arg[i - 1] == '\"') {\n        quote_hit = true;\n        reverse += '\\\\';\n      } else {\n        quote_hit = false;\n      }\n    }\n    reverse += '\"';\n    return reverse.split('').reverse().join('');\n  };\n  ToolRunner.prototype._cloneExecOptions = function (options) {\n    options = options || {};\n    var result = {\n      cwd: options.cwd || process.cwd(),\n      env: options.env || process.env,\n      silent: options.silent || false,\n      failOnStdErr: options.failOnStdErr || false,\n      ignoreReturnCode: options.ignoreReturnCode || false,\n      windowsVerbatimArguments: options.windowsVerbatimArguments || false,\n      shell: options.shell || false\n    };\n    result.outStream = options.outStream || process.stdout;\n    result.errStream = options.errStream || process.stderr;\n    return result;\n  };\n  ToolRunner.prototype._getSpawnOptions = function (options) {\n    options = options || {};\n    var result = {};\n    result.cwd = options.cwd;\n    result.env = options.env;\n    result.shell = options.shell;\n    result['windowsVerbatimArguments'] = options.windowsVerbatimArguments || this._isCmdFile();\n    return result;\n  };\n  ToolRunner.prototype._getSpawnSyncOptions = function (options) {\n    var result = {};\n    result.maxBuffer = 1024 * 1024 * 1024;\n    result.cwd = options.cwd;\n    result.env = options.env;\n    result.shell = options.shell;\n    result['windowsVerbatimArguments'] = options.windowsVerbatimArguments || this._isCmdFile();\n    return result;\n  };\n  ToolRunner.prototype.execWithPiping = function (pipeOutputToTool, options) {\n    var _this = this;\n    var _a, _b, _c, _d;\n    var defer = Q.defer();\n    this._debug('exec tool: ' + this.toolPath);\n    this._debug('arguments:');\n    this.args.forEach(function (arg) {\n      _this._debug('   ' + arg);\n    });\n    var success = true;\n    var optionsNonNull = this._cloneExecOptions(options);\n    if (!optionsNonNull.silent) {\n      optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os.EOL);\n    }\n    var cp;\n    var toolPath = pipeOutputToTool.toolPath;\n    var toolPathFirst;\n    var successFirst = true;\n    var returnCodeFirst;\n    var fileStream;\n    var waitingEvents = 0; // number of process or stream events we are waiting on to complete\n    var returnCode = 0;\n    var error;\n    toolPathFirst = this.toolPath;\n    // Following node documentation example from this link on how to pipe output of one process to another\n    // https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options\n    //start the child process for both tools\n    waitingEvents++;\n    var cpFirst = child.spawn(this._getSpawnFileName(optionsNonNull), this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(optionsNonNull));\n    waitingEvents++;\n    cp = child.spawn(pipeOutputToTool._getSpawnFileName(optionsNonNull), pipeOutputToTool._getSpawnArgs(optionsNonNull), pipeOutputToTool._getSpawnOptions(optionsNonNull));\n    fileStream = this.pipeOutputToFile ? fs.createWriteStream(this.pipeOutputToFile) : null;\n    if (fileStream) {\n      waitingEvents++;\n      fileStream.on('finish', function () {\n        waitingEvents--; //file write is complete\n        fileStream = null;\n        if (waitingEvents == 0) {\n          if (error) {\n            defer.reject(error);\n          } else {\n            defer.resolve(returnCode);\n          }\n        }\n      });\n      fileStream.on('error', function (err) {\n        waitingEvents--; //there were errors writing to the file, write is done\n        _this._debug(\"Failed to pipe output of \" + toolPathFirst + \" to file \" + _this.pipeOutputToFile + \". Error = \" + err);\n        fileStream = null;\n        if (waitingEvents == 0) {\n          if (error) {\n            defer.reject(error);\n          } else {\n            defer.resolve(returnCode);\n          }\n        }\n      });\n    }\n    //pipe stdout of first tool to stdin of second tool\n    (_a = cpFirst.stdout) === null || _a === void 0 ? void 0 : _a.on('data', function (data) {\n      var _a;\n      try {\n        if (fileStream) {\n          fileStream.write(data);\n        }\n        (_a = cp.stdin) === null || _a === void 0 ? void 0 : _a.write(data);\n      } catch (err) {\n        _this._debug('Failed to pipe output of ' + toolPathFirst + ' to ' + toolPath);\n        _this._debug(toolPath + ' might have exited due to errors prematurely. Verify the arguments passed are valid.');\n      }\n    });\n    (_b = cpFirst.stderr) === null || _b === void 0 ? void 0 : _b.on('data', function (data) {\n      if (fileStream) {\n        fileStream.write(data);\n      }\n      successFirst = !optionsNonNull.failOnStdErr;\n      if (!optionsNonNull.silent) {\n        var s = optionsNonNull.failOnStdErr ? optionsNonNull.errStream : optionsNonNull.outStream;\n        s.write(data);\n      }\n    });\n    cpFirst.on('error', function (err) {\n      var _a;\n      waitingEvents--; //first process is complete with errors\n      if (fileStream) {\n        fileStream.end();\n      }\n      (_a = cp.stdin) === null || _a === void 0 ? void 0 : _a.end();\n      error = new Error(toolPathFirst + ' failed. ' + err.message);\n      if (waitingEvents == 0) {\n        defer.reject(error);\n      }\n    });\n    cpFirst.on('close', function (code, signal) {\n      var _a;\n      waitingEvents--; //first process is complete\n      if (code != 0 && !optionsNonNull.ignoreReturnCode) {\n        successFirst = false;\n        returnCodeFirst = code;\n        returnCode = returnCodeFirst;\n      }\n      _this._debug('success of first tool:' + successFirst);\n      if (fileStream) {\n        fileStream.end();\n      }\n      (_a = cp.stdin) === null || _a === void 0 ? void 0 : _a.end();\n      if (waitingEvents == 0) {\n        if (error) {\n          defer.reject(error);\n        } else {\n          defer.resolve(returnCode);\n        }\n      }\n    });\n    var stdbuffer = '';\n    (_c = cp.stdout) === null || _c === void 0 ? void 0 : _c.on('data', function (data) {\n      _this.emit('stdout', data);\n      if (!optionsNonNull.silent) {\n        optionsNonNull.outStream.write(data);\n      }\n      _this._processLineBuffer(data, stdbuffer, function (line) {\n        _this.emit('stdline', line);\n      });\n    });\n    var errbuffer = '';\n    (_d = cp.stderr) === null || _d === void 0 ? void 0 : _d.on('data', function (data) {\n      _this.emit('stderr', data);\n      success = !optionsNonNull.failOnStdErr;\n      if (!optionsNonNull.silent) {\n        var s = optionsNonNull.failOnStdErr ? optionsNonNull.errStream : optionsNonNull.outStream;\n        s.write(data);\n      }\n      _this._processLineBuffer(data, errbuffer, function (line) {\n        _this.emit('errline', line);\n      });\n    });\n    cp.on('error', function (err) {\n      waitingEvents--; //process is done with errors\n      error = new Error(toolPath + ' failed. ' + err.message);\n      if (waitingEvents == 0) {\n        defer.reject(error);\n      }\n    });\n    cp.on('close', function (code, signal) {\n      waitingEvents--; //process is complete\n      _this._debug('rc:' + code);\n      returnCode = code;\n      if (stdbuffer.length > 0) {\n        _this.emit('stdline', stdbuffer);\n      }\n      if (errbuffer.length > 0) {\n        _this.emit('errline', errbuffer);\n      }\n      if (code != 0 && !optionsNonNull.ignoreReturnCode) {\n        success = false;\n      }\n      _this._debug('success:' + success);\n      if (!successFirst) {\n        //in the case output is piped to another tool, check exit code of both tools\n        error = new Error(toolPathFirst + ' failed with return code: ' + returnCodeFirst);\n      } else if (!success) {\n        error = new Error(toolPath + ' failed with return code: ' + code);\n      }\n      if (waitingEvents == 0) {\n        if (error) {\n          defer.reject(error);\n        } else {\n          defer.resolve(returnCode);\n        }\n      }\n    });\n    return defer.promise;\n  };\n  /**\n   * Add argument\n   * Append an argument or an array of arguments\n   * returns ToolRunner for chaining\n   *\n   * @param     val        string cmdline or array of strings\n   * @returns   ToolRunner\n   */\n  ToolRunner.prototype.arg = function (val) {\n    if (!val) {\n      return this;\n    }\n    if (val instanceof Array) {\n      this._debug(this.toolPath + ' arg: ' + JSON.stringify(val));\n      this.args = this.args.concat(val);\n    } else if (typeof val === 'string') {\n      this._debug(this.toolPath + ' arg: ' + val);\n      this.args = this.args.concat(val.trim());\n    }\n    return this;\n  };\n  /**\n   * Parses an argument line into one or more arguments\n   * e.g. .line('\"arg one\" two -z') is equivalent to .arg(['arg one', 'two', '-z'])\n   * returns ToolRunner for chaining\n   *\n   * @param     val        string argument line\n   * @returns   ToolRunner\n   */\n  ToolRunner.prototype.line = function (val) {\n    if (!val) {\n      return this;\n    }\n    this._debug(this.toolPath + ' arg: ' + val);\n    this.args = this.args.concat(this._argStringToArray(val));\n    return this;\n  };\n  /**\n   * Add argument(s) if a condition is met\n   * Wraps arg().  See arg for details\n   * returns ToolRunner for chaining\n   *\n   * @param     condition     boolean condition\n   * @param     val     string cmdline or array of strings\n   * @returns   ToolRunner\n   */\n  ToolRunner.prototype.argIf = function (condition, val) {\n    if (condition) {\n      this.arg(val);\n    }\n    return this;\n  };\n  /**\n   * Pipe output of exec() to another tool\n   * @param tool\n   * @param file  optional filename to additionally stream the output to.\n   * @returns {ToolRunner}\n   */\n  ToolRunner.prototype.pipeExecOutputToTool = function (tool, file) {\n    this.pipeOutputToTool = tool;\n    this.pipeOutputToFile = file;\n    return this;\n  };\n  /**\n   * Exec a tool.\n   * Output will be streamed to the live console.\n   * Returns promise with return code\n   *\n   * @param     tool     path to tool to exec\n   * @param     options  optional exec options.  See IExecOptions\n   * @returns   number\n   */\n  ToolRunner.prototype.exec = function (options) {\n    var _this = this;\n    var _a, _b, _c;\n    if (this.pipeOutputToTool) {\n      return this.execWithPiping(this.pipeOutputToTool, options);\n    }\n    var defer = Q.defer();\n    this._debug('exec tool: ' + this.toolPath);\n    this._debug('arguments:');\n    this.args.forEach(function (arg) {\n      _this._debug('   ' + arg);\n    });\n    var optionsNonNull = this._cloneExecOptions(options);\n    if (!optionsNonNull.silent) {\n      optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os.EOL);\n    }\n    var state = new ExecState(optionsNonNull, this.toolPath);\n    state.on('debug', function (message) {\n      _this._debug(message);\n    });\n    var cp = child.spawn(this._getSpawnFileName(options), this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(options));\n    this.childProcess = cp;\n    // it is possible for the child process to end its last line without a new line.\n    // because stdout is buffered, this causes the last line to not get sent to the parent\n    // stream. Adding this event forces a flush before the child streams are closed.\n    (_a = cp.stdout) === null || _a === void 0 ? void 0 : _a.on('finish', function () {\n      if (!optionsNonNull.silent) {\n        optionsNonNull.outStream.write(os.EOL);\n      }\n    });\n    var stdbuffer = '';\n    (_b = cp.stdout) === null || _b === void 0 ? void 0 : _b.on('data', function (data) {\n      _this.emit('stdout', data);\n      if (!optionsNonNull.silent) {\n        optionsNonNull.outStream.write(data);\n      }\n      _this._processLineBuffer(data, stdbuffer, function (line) {\n        _this.emit('stdline', line);\n      });\n    });\n    var errbuffer = '';\n    (_c = cp.stderr) === null || _c === void 0 ? void 0 : _c.on('data', function (data) {\n      state.processStderr = true;\n      _this.emit('stderr', data);\n      if (!optionsNonNull.silent) {\n        var s = optionsNonNull.failOnStdErr ? optionsNonNull.errStream : optionsNonNull.outStream;\n        s.write(data);\n      }\n      _this._processLineBuffer(data, errbuffer, function (line) {\n        _this.emit('errline', line);\n      });\n    });\n    cp.on('error', function (err) {\n      state.processError = err.message;\n      state.processExited = true;\n      state.processClosed = true;\n      state.CheckComplete();\n    });\n    cp.on('exit', function (code, signal) {\n      state.processExitCode = code;\n      state.processExited = true;\n      _this._debug(\"Exit code \" + code + \" received from tool '\" + _this.toolPath + \"'\");\n      state.CheckComplete();\n    });\n    cp.on('close', function (code, signal) {\n      state.processExitCode = code;\n      state.processExited = true;\n      state.processClosed = true;\n      _this._debug(\"STDIO streams have closed for tool '\" + _this.toolPath + \"'\");\n      state.CheckComplete();\n    });\n    state.on('done', function (error, exitCode) {\n      if (stdbuffer.length > 0) {\n        _this.emit('stdline', stdbuffer);\n      }\n      if (errbuffer.length > 0) {\n        _this.emit('errline', errbuffer);\n      }\n      cp.removeAllListeners();\n      if (error) {\n        defer.reject(error);\n      } else {\n        defer.resolve(exitCode);\n      }\n    });\n    return defer.promise;\n  };\n  /**\n   * Exec a tool synchronously.\n   * Output will be *not* be streamed to the live console.  It will be returned after execution is complete.\n   * Appropriate for short running tools\n   * Returns IExecSyncResult with output and return code\n   *\n   * @param     tool     path to tool to exec\n   * @param     options  optional exec options.  See IExecSyncOptions\n   * @returns   IExecSyncResult\n   */\n  ToolRunner.prototype.execSync = function (options) {\n    var _this = this;\n    this._debug('exec tool: ' + this.toolPath);\n    this._debug('arguments:');\n    this.args.forEach(function (arg) {\n      _this._debug('   ' + arg);\n    });\n    var success = true;\n    options = this._cloneExecOptions(options);\n    if (!options.silent) {\n      options.outStream.write(this._getCommandString(options) + os.EOL);\n    }\n    var r = child.spawnSync(this._getSpawnFileName(options), this._getSpawnArgs(options), this._getSpawnSyncOptions(options));\n    if (!options.silent && r.stdout && r.stdout.length > 0) {\n      options.outStream.write(r.stdout);\n    }\n    if (!options.silent && r.stderr && r.stderr.length > 0) {\n      options.errStream.write(r.stderr);\n    }\n    var res = {\n      code: r.status,\n      error: r.error\n    };\n    res.stdout = r.stdout ? r.stdout.toString() : '';\n    res.stderr = r.stderr ? r.stderr.toString() : '';\n    return res;\n  };\n  /**\n   * Used to close child process by sending SIGNINT signal.\n   * It allows executed script to have some additional logic on SIGINT, before exiting.\n   */\n  ToolRunner.prototype.killChildProcess = function () {\n    if (this.childProcess) {\n      this.childProcess.kill();\n    }\n  };\n  return ToolRunner;\n}(events.EventEmitter);\nexports.ToolRunner = ToolRunner;\nvar ExecState = /** @class */function (_super) {\n  __extends(ExecState, _super);\n  function ExecState(options, toolPath) {\n    var _this = _super.call(this) || this;\n    _this.delay = 10000; // 10 seconds\n    _this.timeout = null;\n    if (!toolPath) {\n      throw new Error('toolPath must not be empty');\n    }\n    _this.options = options;\n    _this.toolPath = toolPath;\n    var delay = process.env['TASKLIB_TEST_TOOLRUNNER_EXITDELAY'];\n    if (delay) {\n      _this.delay = parseInt(delay);\n    }\n    return _this;\n  }\n  ExecState.prototype.CheckComplete = function () {\n    if (this.done) {\n      return;\n    }\n    if (this.processClosed) {\n      this._setResult();\n    } else if (this.processExited) {\n      this.timeout = setTimeout(ExecState.HandleTimeout, this.delay, this);\n    }\n  };\n  ExecState.prototype._debug = function (message) {\n    this.emit('debug', message);\n  };\n  ExecState.prototype._setResult = function () {\n    // determine whether there is an error\n    var error;\n    if (this.processExited) {\n      if (this.processError) {\n        error = new Error(im._loc('LIB_ProcessError', this.toolPath, this.processError));\n      } else if (this.processExitCode != 0 && !this.options.ignoreReturnCode) {\n        error = new Error(im._loc('LIB_ProcessExitCode', this.toolPath, this.processExitCode));\n      } else if (this.processStderr && this.options.failOnStdErr) {\n        error = new Error(im._loc('LIB_ProcessStderr', this.toolPath));\n      }\n    }\n    // clear the timeout\n    if (this.timeout) {\n      clearTimeout(this.timeout);\n      this.timeout = null;\n    }\n    this.done = true;\n    this.emit('done', error, this.processExitCode);\n  };\n  ExecState.HandleTimeout = function (state) {\n    if (state.done) {\n      return;\n    }\n    if (!state.processClosed && state.processExited) {\n      console.log(im._loc('LIB_StdioNotClosed', state.delay / 1000, state.toolPath));\n      state._debug(im._loc('LIB_StdioNotClosed', state.delay / 1000, state.toolPath));\n    }\n    state._setResult();\n  };\n  return ExecState;\n}(events.EventEmitter);\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\azure-pipelines-task-lib\\toolrunner.js");

/***/ }),

/***/ "./node_modules/azure-pipelines-task-lib/vault.js":
/*!********************************************************!*\
  !*** ./node_modules/azure-pipelines-task-lib/vault.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.Vault = void 0;\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar uuidV4 = __webpack_require__(/*! uuid/v4 */ \"./node_modules/uuid/v4.js\");\nvar algorithm = \"aes-256-ctr\";\nvar encryptEncoding = 'hex';\nvar unencryptedEncoding = 'utf8';\n//\n// Store sensitive data in proc.\n// Main goal: Protects tasks which would dump envvars from leaking secrets inadvertently\n//            the task lib clears after storing.\n// Also protects against a dump of a process getting the secrets\n// The secret is generated and stored externally for the lifetime of the task.\n//\nvar Vault = /** @class */function () {\n  function Vault(keyPath) {\n    this._keyFile = path.join(keyPath, '.taskkey');\n    this._store = {};\n    this.genKey();\n  }\n  Vault.prototype.initialize = function () {};\n  Vault.prototype.storeSecret = function (name, data) {\n    if (!name || name.length == 0) {\n      return false;\n    }\n    name = name.toLowerCase();\n    if (!data || data.length == 0) {\n      if (this._store.hasOwnProperty(name)) {\n        delete this._store[name];\n      }\n      return false;\n    }\n    var key = this.getKey();\n    var iv = crypto.randomBytes(16);\n    var cipher = crypto.createCipheriv(algorithm, key, iv);\n    var crypted = cipher.update(data, unencryptedEncoding, encryptEncoding);\n    var cryptedFinal = cipher.final(encryptEncoding);\n    this._store[name] = iv.toString(encryptEncoding) + crypted + cryptedFinal;\n    return true;\n  };\n  Vault.prototype.retrieveSecret = function (name) {\n    var secret;\n    name = (name || '').toLowerCase();\n    if (this._store.hasOwnProperty(name)) {\n      var key = this.getKey();\n      var data = this._store[name];\n      var ivDataBuffer = Buffer.from(data, encryptEncoding);\n      var iv = ivDataBuffer.slice(0, 16);\n      var encryptedText = ivDataBuffer.slice(16);\n      var decipher = crypto.createDecipheriv(algorithm, key, iv);\n      var dec = decipher.update(encryptedText);\n      var decFinal = decipher.final(unencryptedEncoding);\n      secret = dec + decFinal;\n    }\n    return secret;\n  };\n  Vault.prototype.getKey = function () {\n    var key = fs.readFileSync(this._keyFile).toString('utf8');\n    // Key needs to be hashed to correct length to match algorithm (aes-256-ctr)\n    return crypto.createHash('sha256').update(key).digest();\n  };\n  Vault.prototype.genKey = function () {\n    fs.writeFileSync(this._keyFile, uuidV4(), {\n      encoding: 'utf8'\n    });\n  };\n  return Vault;\n}();\nexports.Vault = Vault;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\azure-pipelines-task-lib\\vault.js");

/***/ }),

/***/ "./node_modules/balanced-match/index.js":
/*!**********************************************!*\
  !*** ./node_modules/balanced-match/index.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n  var r = range(a, b, str);\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n  if (ai >= 0 && bi > 0) {\n    if (a === b) {\n      return [ai, bi];\n    }\n    begs = [];\n    left = str.length;\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [begs.pop(), bi];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n        bi = str.indexOf(b, i + 1);\n      }\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n    if (begs.length) {\n      result = [left, right];\n    }\n  }\n  return result;\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\balanced-match\\index.js");

/***/ }),

/***/ "./node_modules/brace-expansion/index.js":
/*!***********************************************!*\
  !*** ./node_modules/brace-expansion/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar balanced = __webpack_require__(/*! balanced-match */ \"./node_modules/balanced-match/index.js\");\nmodule.exports = expandTop;\nvar escSlash = '\\0SLASH' + Math.random() + '\\0';\nvar escOpen = '\\0OPEN' + Math.random() + '\\0';\nvar escClose = '\\0CLOSE' + Math.random() + '\\0';\nvar escComma = '\\0COMMA' + Math.random() + '\\0';\nvar escPeriod = '\\0PERIOD' + Math.random() + '\\0';\nfunction numeric(str) {\n  return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);\n}\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash).split('\\\\{').join(escOpen).split('\\\\}').join(escClose).split('\\\\,').join(escComma).split('\\\\.').join(escPeriod);\n}\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\').split(escOpen).join('{').split(escClose).join('}').split(escComma).join(',').split(escPeriod).join('.');\n}\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str) return [''];\n  var parts = [];\n  var m = balanced('{', '}', str);\n  if (!m) return str.split(',');\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n  p[p.length - 1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length - 1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n  parts.push.apply(parts, p);\n  return parts;\n}\nfunction expandTop(str) {\n  if (!str) return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\nfunction expand(str, isTop) {\n  var expansions = [];\n  var m = balanced('{', '}', str);\n  if (!m) return [str];\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length ? expand(m.post, false) : [''];\n  if (/\\$$/.test(m.pre)) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + '{' + m.body + '}' + post[k];\n      expansions.push(expansion);\n    }\n  } else {\n    var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isSequence = isNumericSequence || isAlphaSequence;\n    var isOptions = m.body.indexOf(',') >= 0;\n    if (!isSequence && !isOptions) {\n      // {a},b}\n      if (m.post.match(/,.*\\}/)) {\n        str = m.pre + '{' + m.body + escClose + m.post;\n        return expand(str);\n      }\n      return [str];\n    }\n    var n;\n    if (isSequence) {\n      n = m.body.split(/\\.\\./);\n    } else {\n      n = parseCommaParts(m.body);\n      if (n.length === 1) {\n        // x{{a,b}}y ==> x{a}y x{b}y\n        n = expand(n[0], false).map(embrace);\n        if (n.length === 1) {\n          return post.map(function (p) {\n            return m.pre + n[0] + p;\n          });\n        }\n      }\n    }\n\n    // at this point, n is the parts, and we know it's not a comma set\n    // with a single entry.\n    var N;\n    if (isSequence) {\n      var x = numeric(n[0]);\n      var y = numeric(n[1]);\n      var width = Math.max(n[0].length, n[1].length);\n      var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;\n      var test = lte;\n      var reverse = y < x;\n      if (reverse) {\n        incr *= -1;\n        test = gte;\n      }\n      var pad = n.some(isPadded);\n      N = [];\n      for (var i = x; test(i, y); i += incr) {\n        var c;\n        if (isAlphaSequence) {\n          c = String.fromCharCode(i);\n          if (c === '\\\\') c = '';\n        } else {\n          c = String(i);\n          if (pad) {\n            var need = width - c.length;\n            if (need > 0) {\n              var z = new Array(need + 1).join('0');\n              if (i < 0) c = '-' + z + c.slice(1);else c = z + c;\n            }\n          }\n        }\n        N.push(c);\n      }\n    } else {\n      N = [];\n      for (var j = 0; j < n.length; j++) {\n        N.push.apply(N, expand(n[j], false));\n      }\n    }\n    for (var j = 0; j < N.length; j++) {\n      for (var k = 0; k < post.length; k++) {\n        var expansion = pre + N[j] + post[k];\n        if (!isTop || isSequence || expansion) expansions.push(expansion);\n      }\n    }\n  }\n  return expansions;\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\brace-expansion\\index.js");

/***/ }),

/***/ "./node_modules/color-support/index.js":
/*!*********************************************!*\
  !*** ./node_modules/color-support/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// call it on itself so we can test the export val for basic stuff\nmodule.exports = colorSupport({\n  alwaysReturn: true\n}, colorSupport);\nfunction hasNone(obj, options) {\n  obj.level = 0;\n  obj.hasBasic = false;\n  obj.has256 = false;\n  obj.has16m = false;\n  if (!options.alwaysReturn) {\n    return false;\n  }\n  return obj;\n}\nfunction hasBasic(obj) {\n  obj.hasBasic = true;\n  obj.has256 = false;\n  obj.has16m = false;\n  obj.level = 1;\n  return obj;\n}\nfunction has256(obj) {\n  obj.hasBasic = true;\n  obj.has256 = true;\n  obj.has16m = false;\n  obj.level = 2;\n  return obj;\n}\nfunction has16m(obj) {\n  obj.hasBasic = true;\n  obj.has256 = true;\n  obj.has16m = true;\n  obj.level = 3;\n  return obj;\n}\nfunction colorSupport(options, obj) {\n  options = options || {};\n  obj = obj || {};\n\n  // if just requesting a specific level, then return that.\n  if (typeof options.level === 'number') {\n    switch (options.level) {\n      case 0:\n        return hasNone(obj, options);\n      case 1:\n        return hasBasic(obj);\n      case 2:\n        return has256(obj);\n      case 3:\n        return has16m(obj);\n    }\n  }\n  obj.level = 0;\n  obj.hasBasic = false;\n  obj.has256 = false;\n  obj.has16m = false;\n  if (typeof process === 'undefined' || !process || !process.stdout || !process.env || !process.platform) {\n    return hasNone(obj, options);\n  }\n  var env = options.env || process.env;\n  var stream = options.stream || process.stdout;\n  var term = options.term || env.TERM || '';\n  var platform = options.platform || process.platform;\n  if (!options.ignoreTTY && !stream.isTTY) {\n    return hasNone(obj, options);\n  }\n  if (!options.ignoreDumb && term === 'dumb' && !env.COLORTERM) {\n    return hasNone(obj, options);\n  }\n  if (platform === 'win32') {\n    return hasBasic(obj);\n  }\n  if (env.TMUX) {\n    return has256(obj);\n  }\n  if (!options.ignoreCI && (env.CI || env.TEAMCITY_VERSION)) {\n    if (env.TRAVIS) {\n      return has256(obj);\n    } else {\n      return hasNone(obj, options);\n    }\n  }\n\n  // TODO: add more term programs\n  switch (env.TERM_PROGRAM) {\n    case 'iTerm.app':\n      var ver = env.TERM_PROGRAM_VERSION || '0.';\n      if (/^[0-2]\\./.test(ver)) {\n        return has256(obj);\n      } else {\n        return has16m(obj);\n      }\n    case 'HyperTerm':\n    case 'Hyper':\n      return has16m(obj);\n    case 'MacTerm':\n      return has16m(obj);\n    case 'Apple_Terminal':\n      return has256(obj);\n  }\n  if (/^xterm-256/.test(term)) {\n    return has256(obj);\n  }\n  if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(term)) {\n    return hasBasic(obj);\n  }\n  if (env.COLORTERM) {\n    return hasBasic(obj);\n  }\n  return hasNone(obj, options);\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\color-support\\index.js");

/***/ }),

/***/ "./node_modules/concat-map/index.js":
/*!******************************************!*\
  !*** ./node_modules/concat-map/index.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (xs, fn) {\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    var x = fn(xs[i], i);\n    if (isArray(x)) res.push.apply(res, x);else res.push(x);\n  }\n  return res;\n};\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\concat-map\\index.js");

/***/ }),

/***/ "./node_modules/fancy-log/index.js":
/*!*****************************************!*\
  !*** ./node_modules/fancy-log/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar util = __webpack_require__(/*! util */ \"util\");\nvar Console = (__webpack_require__(/*! console */ \"console\").Console);\nvar supportsColor = __webpack_require__(/*! color-support */ \"./node_modules/color-support/index.js\");\nvar console = new Console({\n  stdout: process.stdout,\n  stderr: process.stderr,\n  colorMode: false\n});\nfunction hasFlag(flag) {\n  return process.argv.indexOf('--' + flag) !== -1;\n}\nfunction hasColors() {\n  if (hasFlag('no-color')) {\n    return false;\n  }\n  if (hasFlag('color')) {\n    return true;\n  }\n  if (supportsColor()) {\n    return true;\n  }\n  return false;\n}\nfunction Timestamp() {\n  this.now = new Date();\n}\nTimestamp.prototype[util.inspect.custom] = function (depth, opts) {\n  var timestamp = this.now.toLocaleTimeString('en', {\n    hour12: false\n  });\n  return '[' + opts.stylize(timestamp, 'date') + ']';\n};\nfunction getTimestamp() {\n  return util.inspect(new Timestamp(), {\n    colors: hasColors()\n  });\n}\nfunction log() {\n  var time = getTimestamp();\n  process.stdout.write(time + ' ');\n  console.log.apply(console, arguments);\n  return this;\n}\nfunction info() {\n  var time = getTimestamp();\n  process.stdout.write(time + ' ');\n  console.info.apply(console, arguments);\n  return this;\n}\nfunction dir() {\n  var time = getTimestamp();\n  process.stdout.write(time + ' ');\n  console.dir.apply(console, arguments);\n  return this;\n}\nfunction warn() {\n  var time = getTimestamp();\n  process.stderr.write(time + ' ');\n  console.warn.apply(console, arguments);\n  return this;\n}\nfunction error() {\n  var time = getTimestamp();\n  process.stderr.write(time + ' ');\n  console.error.apply(console, arguments);\n  return this;\n}\nmodule.exports = log;\nmodule.exports.info = info;\nmodule.exports.dir = dir;\nmodule.exports.warn = warn;\nmodule.exports.error = error;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fancy-log\\index.js");

/***/ }),

/***/ "./node_modules/fast-glob/node_modules/glob-parent/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/fast-glob/node_modules/glob-parent/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar isGlob = __webpack_require__(/*! is-glob */ \"./node_modules/is-glob/index.js\");\nvar pathPosixDirname = (__webpack_require__(/*! path */ \"path\").posix.dirname);\nvar isWin32 = (__webpack_require__(/*! os */ \"os\").platform)() === 'win32';\nvar slash = '/';\nvar backslash = /\\\\/g;\nvar enclosure = /[\\{\\[].*[\\}\\]]$/;\nvar globby = /(^|[^\\\\])([\\{\\[]|\\([^\\)]+$)/;\nvar escaped = /\\\\([\\!\\*\\?\\|\\[\\]\\(\\)\\{\\}])/g;\n\n/**\n * @param {string} str\n * @param {Object} opts\n * @param {boolean} [opts.flipBackslashes=true]\n * @returns {string}\n */\nmodule.exports = function globParent(str, opts) {\n  var options = Object.assign({\n    flipBackslashes: true\n  }, opts);\n\n  // flip windows path separators\n  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {\n    str = str.replace(backslash, slash);\n  }\n\n  // special case for strings ending in enclosure containing path separator\n  if (enclosure.test(str)) {\n    str += slash;\n  }\n\n  // preserves full path in case of trailing path separator\n  str += 'a';\n\n  // remove path parts that are globby\n  do {\n    str = pathPosixDirname(str);\n  } while (isGlob(str) || globby.test(str));\n\n  // remove escape chars and return result\n  return str.replace(escaped, '$1');\n};\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fast-glob\\node_modules\\glob-parent\\index.js");

/***/ }),

/***/ "./node_modules/fast-glob/out/index.js":
/*!*********************************************!*\
  !*** ./node_modules/fast-glob/out/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nconst taskManager = __webpack_require__(/*! ./managers/tasks */ \"./node_modules/fast-glob/out/managers/tasks.js\");\nconst async_1 = __webpack_require__(/*! ./providers/async */ \"./node_modules/fast-glob/out/providers/async.js\");\nconst stream_1 = __webpack_require__(/*! ./providers/stream */ \"./node_modules/fast-glob/out/providers/stream.js\");\nconst sync_1 = __webpack_require__(/*! ./providers/sync */ \"./node_modules/fast-glob/out/providers/sync.js\");\nconst settings_1 = __webpack_require__(/*! ./settings */ \"./node_modules/fast-glob/out/settings.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/fast-glob/out/utils/index.js\");\nfunction FastGlob(_x, _x2) {\n  return _FastGlob.apply(this, arguments);\n} // https://github.com/typescript-eslint/typescript-eslint/issues/60\n// eslint-disable-next-line no-redeclare\nfunction _FastGlob() {\n  _FastGlob = _asyncToGenerator(function* (source, options) {\n    assertPatternsInput(source);\n    const works = getWorks(source, async_1.default, options);\n    const result = yield Promise.all(works);\n    return utils.array.flatten(result);\n  });\n  return _FastGlob.apply(this, arguments);\n}\n(function (FastGlob) {\n  FastGlob.glob = FastGlob;\n  FastGlob.globSync = sync;\n  FastGlob.globStream = stream;\n  FastGlob.async = FastGlob;\n  function sync(source, options) {\n    assertPatternsInput(source);\n    const works = getWorks(source, sync_1.default, options);\n    return utils.array.flatten(works);\n  }\n  FastGlob.sync = sync;\n  function stream(source, options) {\n    assertPatternsInput(source);\n    const works = getWorks(source, stream_1.default, options);\n    /**\n     * The stream returned by the provider cannot work with an asynchronous iterator.\n     * To support asynchronous iterators, regardless of the number of tasks, we always multiplex streams.\n     * This affects performance (+25%). I don't see best solution right now.\n     */\n    return utils.stream.merge(works);\n  }\n  FastGlob.stream = stream;\n  function generateTasks(source, options) {\n    assertPatternsInput(source);\n    const patterns = [].concat(source);\n    const settings = new settings_1.default(options);\n    return taskManager.generate(patterns, settings);\n  }\n  FastGlob.generateTasks = generateTasks;\n  function isDynamicPattern(source, options) {\n    assertPatternsInput(source);\n    const settings = new settings_1.default(options);\n    return utils.pattern.isDynamicPattern(source, settings);\n  }\n  FastGlob.isDynamicPattern = isDynamicPattern;\n  function escapePath(source) {\n    assertPatternsInput(source);\n    return utils.path.escape(source);\n  }\n  FastGlob.escapePath = escapePath;\n  function convertPathToPattern(source) {\n    assertPatternsInput(source);\n    return utils.path.convertPathToPattern(source);\n  }\n  FastGlob.convertPathToPattern = convertPathToPattern;\n  let posix;\n  (function (posix) {\n    function escapePath(source) {\n      assertPatternsInput(source);\n      return utils.path.escapePosixPath(source);\n    }\n    posix.escapePath = escapePath;\n    function convertPathToPattern(source) {\n      assertPatternsInput(source);\n      return utils.path.convertPosixPathToPattern(source);\n    }\n    posix.convertPathToPattern = convertPathToPattern;\n  })(posix = FastGlob.posix || (FastGlob.posix = {}));\n  let win32;\n  (function (win32) {\n    function escapePath(source) {\n      assertPatternsInput(source);\n      return utils.path.escapeWindowsPath(source);\n    }\n    win32.escapePath = escapePath;\n    function convertPathToPattern(source) {\n      assertPatternsInput(source);\n      return utils.path.convertWindowsPathToPattern(source);\n    }\n    win32.convertPathToPattern = convertPathToPattern;\n  })(win32 = FastGlob.win32 || (FastGlob.win32 = {}));\n})(FastGlob || (FastGlob = {}));\nfunction getWorks(source, _Provider, options) {\n  const patterns = [].concat(source);\n  const settings = new settings_1.default(options);\n  const tasks = taskManager.generate(patterns, settings);\n  const provider = new _Provider(settings);\n  return tasks.map(provider.read, provider);\n}\nfunction assertPatternsInput(input) {\n  const source = [].concat(input);\n  const isValidSource = source.every(item => utils.string.isString(item) && !utils.string.isEmpty(item));\n  if (!isValidSource) {\n    throw new TypeError('Patterns must be a string (non empty) or an array of strings');\n  }\n}\nmodule.exports = FastGlob;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fast-glob\\out\\index.js");

/***/ }),

/***/ "./node_modules/fast-glob/out/managers/tasks.js":
/*!******************************************************!*\
  !*** ./node_modules/fast-glob/out/managers/tasks.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.convertPatternGroupToTask = exports.convertPatternGroupsToTasks = exports.groupPatternsByBaseDirectory = exports.getNegativePatternsAsPositive = exports.getPositivePatterns = exports.convertPatternsToTasks = exports.generate = void 0;\nconst utils = __webpack_require__(/*! ../utils */ \"./node_modules/fast-glob/out/utils/index.js\");\nfunction generate(input, settings) {\n  const patterns = processPatterns(input, settings);\n  const ignore = processPatterns(settings.ignore, settings);\n  const positivePatterns = getPositivePatterns(patterns);\n  const negativePatterns = getNegativePatternsAsPositive(patterns, ignore);\n  const staticPatterns = positivePatterns.filter(pattern => utils.pattern.isStaticPattern(pattern, settings));\n  const dynamicPatterns = positivePatterns.filter(pattern => utils.pattern.isDynamicPattern(pattern, settings));\n  const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, /* dynamic */false);\n  const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, /* dynamic */true);\n  return staticTasks.concat(dynamicTasks);\n}\nexports.generate = generate;\nfunction processPatterns(input, settings) {\n  let patterns = input;\n  /**\n   * The original pattern like `{,*,**,a/*}` can lead to problems checking the depth when matching entry\n   * and some problems with the micromatch package (see fast-glob issues: #365, #394).\n   *\n   * To solve this problem, we expand all patterns containing brace expansion. This can lead to a slight slowdown\n   * in matching in the case of a large set of patterns after expansion.\n   */\n  if (settings.braceExpansion) {\n    patterns = utils.pattern.expandPatternsWithBraceExpansion(patterns);\n  }\n  /**\n   * If the `baseNameMatch` option is enabled, we must add globstar to patterns, so that they can be used\n   * at any nesting level.\n   *\n   * We do this here, because otherwise we have to complicate the filtering logic. For example, we need to change\n   * the pattern in the filter before creating a regular expression. There is no need to change the patterns\n   * in the application. Only on the input.\n   */\n  if (settings.baseNameMatch) {\n    patterns = patterns.map(pattern => pattern.includes('/') ? pattern : `**/${pattern}`);\n  }\n  /**\n   * This method also removes duplicate slashes that may have been in the pattern or formed as a result of expansion.\n   */\n  return patterns.map(pattern => utils.pattern.removeDuplicateSlashes(pattern));\n}\n/**\n * Returns tasks grouped by basic pattern directories.\n *\n * Patterns that can be found inside (`./`) and outside (`../`) the current directory are handled separately.\n * This is necessary because directory traversal starts at the base directory and goes deeper.\n */\nfunction convertPatternsToTasks(positive, negative, dynamic) {\n  const tasks = [];\n  const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);\n  const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);\n  const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);\n  const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);\n  tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));\n  /*\n   * For the sake of reducing future accesses to the file system, we merge all tasks within the current directory\n   * into a global task, if at least one pattern refers to the root (`.`). In this case, the global task covers the rest.\n   */\n  if ('.' in insideCurrentDirectoryGroup) {\n    tasks.push(convertPatternGroupToTask('.', patternsInsideCurrentDirectory, negative, dynamic));\n  } else {\n    tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));\n  }\n  return tasks;\n}\nexports.convertPatternsToTasks = convertPatternsToTasks;\nfunction getPositivePatterns(patterns) {\n  return utils.pattern.getPositivePatterns(patterns);\n}\nexports.getPositivePatterns = getPositivePatterns;\nfunction getNegativePatternsAsPositive(patterns, ignore) {\n  const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);\n  const positive = negative.map(utils.pattern.convertToPositivePattern);\n  return positive;\n}\nexports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;\nfunction groupPatternsByBaseDirectory(patterns) {\n  const group = {};\n  return patterns.reduce((collection, pattern) => {\n    const base = utils.pattern.getBaseDirectory(pattern);\n    if (base in collection) {\n      collection[base].push(pattern);\n    } else {\n      collection[base] = [pattern];\n    }\n    return collection;\n  }, group);\n}\nexports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;\nfunction convertPatternGroupsToTasks(positive, negative, dynamic) {\n  return Object.keys(positive).map(base => {\n    return convertPatternGroupToTask(base, positive[base], negative, dynamic);\n  });\n}\nexports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;\nfunction convertPatternGroupToTask(base, positive, negative, dynamic) {\n  return {\n    dynamic,\n    positive,\n    negative,\n    base,\n    patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))\n  };\n}\nexports.convertPatternGroupToTask = convertPatternGroupToTask;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fast-glob\\out\\managers\\tasks.js");

/***/ }),

/***/ "./node_modules/fast-glob/out/providers/async.js":
/*!*******************************************************!*\
  !*** ./node_modules/fast-glob/out/providers/async.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nconst async_1 = __webpack_require__(/*! ../readers/async */ \"./node_modules/fast-glob/out/readers/async.js\");\nconst provider_1 = __webpack_require__(/*! ./provider */ \"./node_modules/fast-glob/out/providers/provider.js\");\nclass ProviderAsync extends provider_1.default {\n  constructor() {\n    super(...arguments);\n    this._reader = new async_1.default(this._settings);\n  }\n  read(task) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const root = _this._getRootDirectory(task);\n      const options = _this._getReaderOptions(task);\n      const entries = yield _this.api(root, task, options);\n      return entries.map(entry => options.transform(entry));\n    })();\n  }\n  api(root, task, options) {\n    if (task.dynamic) {\n      return this._reader.dynamic(root, options);\n    }\n    return this._reader.static(task.patterns, options);\n  }\n}\nexports[\"default\"] = ProviderAsync;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fast-glob\\out\\providers\\async.js");

/***/ }),

/***/ "./node_modules/fast-glob/out/providers/filters/deep.js":
/*!**************************************************************!*\
  !*** ./node_modules/fast-glob/out/providers/filters/deep.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nconst utils = __webpack_require__(/*! ../../utils */ \"./node_modules/fast-glob/out/utils/index.js\");\nconst partial_1 = __webpack_require__(/*! ../matchers/partial */ \"./node_modules/fast-glob/out/providers/matchers/partial.js\");\nclass DeepFilter {\n  constructor(_settings, _micromatchOptions) {\n    this._settings = _settings;\n    this._micromatchOptions = _micromatchOptions;\n  }\n  getFilter(basePath, positive, negative) {\n    const matcher = this._getMatcher(positive);\n    const negativeRe = this._getNegativePatternsRe(negative);\n    return entry => this._filter(basePath, entry, matcher, negativeRe);\n  }\n  _getMatcher(patterns) {\n    return new partial_1.default(patterns, this._settings, this._micromatchOptions);\n  }\n  _getNegativePatternsRe(patterns) {\n    const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);\n    return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);\n  }\n  _filter(basePath, entry, matcher, negativeRe) {\n    if (this._isSkippedByDeep(basePath, entry.path)) {\n      return false;\n    }\n    if (this._isSkippedSymbolicLink(entry)) {\n      return false;\n    }\n    const filepath = utils.path.removeLeadingDotSegment(entry.path);\n    if (this._isSkippedByPositivePatterns(filepath, matcher)) {\n      return false;\n    }\n    return this._isSkippedByNegativePatterns(filepath, negativeRe);\n  }\n  _isSkippedByDeep(basePath, entryPath) {\n    /**\n     * Avoid unnecessary depth calculations when it doesn't matter.\n     */\n    if (this._settings.deep === Infinity) {\n      return false;\n    }\n    return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;\n  }\n  _getEntryLevel(basePath, entryPath) {\n    const entryPathDepth = entryPath.split('/').length;\n    if (basePath === '') {\n      return entryPathDepth;\n    }\n    const basePathDepth = basePath.split('/').length;\n    return entryPathDepth - basePathDepth;\n  }\n  _isSkippedSymbolicLink(entry) {\n    return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();\n  }\n  _isSkippedByPositivePatterns(entryPath, matcher) {\n    return !this._settings.baseNameMatch && !matcher.match(entryPath);\n  }\n  _isSkippedByNegativePatterns(entryPath, patternsRe) {\n    return !utils.pattern.matchAny(entryPath, patternsRe);\n  }\n}\nexports[\"default\"] = DeepFilter;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fast-glob\\out\\providers\\filters\\deep.js");

/***/ }),

/***/ "./node_modules/fast-glob/out/providers/filters/entry.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-glob/out/providers/filters/entry.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nconst utils = __webpack_require__(/*! ../../utils */ \"./node_modules/fast-glob/out/utils/index.js\");\nclass EntryFilter {\n  constructor(_settings, _micromatchOptions) {\n    this._settings = _settings;\n    this._micromatchOptions = _micromatchOptions;\n    this.index = new Map();\n  }\n  getFilter(positive, negative) {\n    const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);\n    const negativeRe = utils.pattern.convertPatternsToRe(negative, Object.assign(Object.assign({}, this._micromatchOptions), {\n      dot: true\n    }));\n    return entry => this._filter(entry, positiveRe, negativeRe);\n  }\n  _filter(entry, positiveRe, negativeRe) {\n    const filepath = utils.path.removeLeadingDotSegment(entry.path);\n    if (this._settings.unique && this._isDuplicateEntry(filepath)) {\n      return false;\n    }\n    if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {\n      return false;\n    }\n    if (this._isSkippedByAbsoluteNegativePatterns(filepath, negativeRe)) {\n      return false;\n    }\n    const isDirectory = entry.dirent.isDirectory();\n    const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory) && !this._isMatchToPatterns(filepath, negativeRe, isDirectory);\n    if (this._settings.unique && isMatched) {\n      this._createIndexRecord(filepath);\n    }\n    return isMatched;\n  }\n  _isDuplicateEntry(filepath) {\n    return this.index.has(filepath);\n  }\n  _createIndexRecord(filepath) {\n    this.index.set(filepath, undefined);\n  }\n  _onlyFileFilter(entry) {\n    return this._settings.onlyFiles && !entry.dirent.isFile();\n  }\n  _onlyDirectoryFilter(entry) {\n    return this._settings.onlyDirectories && !entry.dirent.isDirectory();\n  }\n  _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {\n    if (!this._settings.absolute) {\n      return false;\n    }\n    const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);\n    return utils.pattern.matchAny(fullpath, patternsRe);\n  }\n  _isMatchToPatterns(filepath, patternsRe, isDirectory) {\n    // Trying to match files and directories by patterns.\n    const isMatched = utils.pattern.matchAny(filepath, patternsRe);\n    // A pattern with a trailling slash can be used for directory matching.\n    // To apply such pattern, we need to add a tralling slash to the path.\n    if (!isMatched && isDirectory) {\n      return utils.pattern.matchAny(filepath + '/', patternsRe);\n    }\n    return isMatched;\n  }\n}\nexports[\"default\"] = EntryFilter;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fast-glob\\out\\providers\\filters\\entry.js");

/***/ }),

/***/ "./node_modules/fast-glob/out/providers/filters/error.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-glob/out/providers/filters/error.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nconst utils = __webpack_require__(/*! ../../utils */ \"./node_modules/fast-glob/out/utils/index.js\");\nclass ErrorFilter {\n  constructor(_settings) {\n    this._settings = _settings;\n  }\n  getFilter() {\n    return error => this._isNonFatalError(error);\n  }\n  _isNonFatalError(error) {\n    return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;\n  }\n}\nexports[\"default\"] = ErrorFilter;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fast-glob\\out\\providers\\filters\\error.js");

/***/ }),

/***/ "./node_modules/fast-glob/out/providers/matchers/matcher.js":
/*!******************************************************************!*\
  !*** ./node_modules/fast-glob/out/providers/matchers/matcher.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nconst utils = __webpack_require__(/*! ../../utils */ \"./node_modules/fast-glob/out/utils/index.js\");\nclass Matcher {\n  constructor(_patterns, _settings, _micromatchOptions) {\n    this._patterns = _patterns;\n    this._settings = _settings;\n    this._micromatchOptions = _micromatchOptions;\n    this._storage = [];\n    this._fillStorage();\n  }\n  _fillStorage() {\n    var _iterator = _createForOfIteratorHelper(this._patterns),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        const pattern = _step.value;\n        const segments = this._getPatternSegments(pattern);\n        const sections = this._splitSegmentsIntoSections(segments);\n        this._storage.push({\n          complete: sections.length <= 1,\n          pattern,\n          segments,\n          sections\n        });\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  _getPatternSegments(pattern) {\n    const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);\n    return parts.map(part => {\n      const dynamic = utils.pattern.isDynamicPattern(part, this._settings);\n      if (!dynamic) {\n        return {\n          dynamic: false,\n          pattern: part\n        };\n      }\n      return {\n        dynamic: true,\n        pattern: part,\n        patternRe: utils.pattern.makeRe(part, this._micromatchOptions)\n      };\n    });\n  }\n  _splitSegmentsIntoSections(segments) {\n    return utils.array.splitWhen(segments, segment => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));\n  }\n}\nexports[\"default\"] = Matcher;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fast-glob\\out\\providers\\matchers\\matcher.js");

/***/ }),

/***/ "./node_modules/fast-glob/out/providers/matchers/partial.js":
/*!******************************************************************!*\
  !*** ./node_modules/fast-glob/out/providers/matchers/partial.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nconst matcher_1 = __webpack_require__(/*! ./matcher */ \"./node_modules/fast-glob/out/providers/matchers/matcher.js\");\nclass PartialMatcher extends matcher_1.default {\n  match(filepath) {\n    const parts = filepath.split('/');\n    const levels = parts.length;\n    const patterns = this._storage.filter(info => !info.complete || info.segments.length > levels);\n    var _iterator = _createForOfIteratorHelper(patterns),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        const pattern = _step.value;\n        const section = pattern.sections[0];\n        /**\n         * In this case, the pattern has a globstar and we must read all directories unconditionally,\n         * but only if the level has reached the end of the first group.\n         *\n         * fixtures/{a,b}/**\n         *  ^ true/false  ^ always true\n        */\n        if (!pattern.complete && levels > section.length) {\n          return true;\n        }\n        const match = parts.every((part, index) => {\n          const segment = pattern.segments[index];\n          if (segment.dynamic && segment.patternRe.test(part)) {\n            return true;\n          }\n          if (!segment.dynamic && segment.pattern === part) {\n            return true;\n          }\n          return false;\n        });\n        if (match) {\n          return true;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return false;\n  }\n}\nexports[\"default\"] = PartialMatcher;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fast-glob\\out\\providers\\matchers\\partial.js");

/***/ }),

/***/ "./node_modules/fast-glob/out/providers/provider.js":
/*!**********************************************************!*\
  !*** ./node_modules/fast-glob/out/providers/provider.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nconst path = __webpack_require__(/*! path */ \"path\");\nconst deep_1 = __webpack_require__(/*! ./filters/deep */ \"./node_modules/fast-glob/out/providers/filters/deep.js\");\nconst entry_1 = __webpack_require__(/*! ./filters/entry */ \"./node_modules/fast-glob/out/providers/filters/entry.js\");\nconst error_1 = __webpack_require__(/*! ./filters/error */ \"./node_modules/fast-glob/out/providers/filters/error.js\");\nconst entry_2 = __webpack_require__(/*! ./transformers/entry */ \"./node_modules/fast-glob/out/providers/transformers/entry.js\");\nclass Provider {\n  constructor(_settings) {\n    this._settings = _settings;\n    this.errorFilter = new error_1.default(this._settings);\n    this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());\n    this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());\n    this.entryTransformer = new entry_2.default(this._settings);\n  }\n  _getRootDirectory(task) {\n    return path.resolve(this._settings.cwd, task.base);\n  }\n  _getReaderOptions(task) {\n    const basePath = task.base === '.' ? '' : task.base;\n    return {\n      basePath,\n      pathSegmentSeparator: '/',\n      concurrency: this._settings.concurrency,\n      deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),\n      entryFilter: this.entryFilter.getFilter(task.positive, task.negative),\n      errorFilter: this.errorFilter.getFilter(),\n      followSymbolicLinks: this._settings.followSymbolicLinks,\n      fs: this._settings.fs,\n      stats: this._settings.stats,\n      throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,\n      transform: this.entryTransformer.getTransformer()\n    };\n  }\n  _getMicromatchOptions() {\n    return {\n      dot: this._settings.dot,\n      matchBase: this._settings.baseNameMatch,\n      nobrace: !this._settings.braceExpansion,\n      nocase: !this._settings.caseSensitiveMatch,\n      noext: !this._settings.extglob,\n      noglobstar: !this._settings.globstar,\n      posix: true,\n      strictSlashes: false\n    };\n  }\n}\nexports[\"default\"] = Provider;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fast-glob\\out\\providers\\provider.js");

/***/ }),

/***/ "./node_modules/fast-glob/out/providers/stream.js":
/*!********************************************************!*\
  !*** ./node_modules/fast-glob/out/providers/stream.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst stream_2 = __webpack_require__(/*! ../readers/stream */ \"./node_modules/fast-glob/out/readers/stream.js\");\nconst provider_1 = __webpack_require__(/*! ./provider */ \"./node_modules/fast-glob/out/providers/provider.js\");\nclass ProviderStream extends provider_1.default {\n  constructor() {\n    super(...arguments);\n    this._reader = new stream_2.default(this._settings);\n  }\n  read(task) {\n    const root = this._getRootDirectory(task);\n    const options = this._getReaderOptions(task);\n    const source = this.api(root, task, options);\n    const destination = new stream_1.Readable({\n      objectMode: true,\n      read: () => {}\n    });\n    source.once('error', error => destination.emit('error', error)).on('data', entry => destination.emit('data', options.transform(entry))).once('end', () => destination.emit('end'));\n    destination.once('close', () => source.destroy());\n    return destination;\n  }\n  api(root, task, options) {\n    if (task.dynamic) {\n      return this._reader.dynamic(root, options);\n    }\n    return this._reader.static(task.patterns, options);\n  }\n}\nexports[\"default\"] = ProviderStream;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fast-glob\\out\\providers\\stream.js");

/***/ }),

/***/ "./node_modules/fast-glob/out/providers/sync.js":
/*!******************************************************!*\
  !*** ./node_modules/fast-glob/out/providers/sync.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nconst sync_1 = __webpack_require__(/*! ../readers/sync */ \"./node_modules/fast-glob/out/readers/sync.js\");\nconst provider_1 = __webpack_require__(/*! ./provider */ \"./node_modules/fast-glob/out/providers/provider.js\");\nclass ProviderSync extends provider_1.default {\n  constructor() {\n    super(...arguments);\n    this._reader = new sync_1.default(this._settings);\n  }\n  read(task) {\n    const root = this._getRootDirectory(task);\n    const options = this._getReaderOptions(task);\n    const entries = this.api(root, task, options);\n    return entries.map(options.transform);\n  }\n  api(root, task, options) {\n    if (task.dynamic) {\n      return this._reader.dynamic(root, options);\n    }\n    return this._reader.static(task.patterns, options);\n  }\n}\nexports[\"default\"] = ProviderSync;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fast-glob\\out\\providers\\sync.js");

/***/ }),

/***/ "./node_modules/fast-glob/out/providers/transformers/entry.js":
/*!********************************************************************!*\
  !*** ./node_modules/fast-glob/out/providers/transformers/entry.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nconst utils = __webpack_require__(/*! ../../utils */ \"./node_modules/fast-glob/out/utils/index.js\");\nclass EntryTransformer {\n  constructor(_settings) {\n    this._settings = _settings;\n  }\n  getTransformer() {\n    return entry => this._transform(entry);\n  }\n  _transform(entry) {\n    let filepath = entry.path;\n    if (this._settings.absolute) {\n      filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);\n      filepath = utils.path.unixify(filepath);\n    }\n    if (this._settings.markDirectories && entry.dirent.isDirectory()) {\n      filepath += '/';\n    }\n    if (!this._settings.objectMode) {\n      return filepath;\n    }\n    return Object.assign(Object.assign({}, entry), {\n      path: filepath\n    });\n  }\n}\nexports[\"default\"] = EntryTransformer;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fast-glob\\out\\providers\\transformers\\entry.js");

/***/ }),

/***/ "./node_modules/fast-glob/out/readers/async.js":
/*!*****************************************************!*\
  !*** ./node_modules/fast-glob/out/readers/async.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nconst fsWalk = __webpack_require__(/*! @nodelib/fs.walk */ \"./node_modules/@nodelib/fs.walk/out/index.js\");\nconst reader_1 = __webpack_require__(/*! ./reader */ \"./node_modules/fast-glob/out/readers/reader.js\");\nconst stream_1 = __webpack_require__(/*! ./stream */ \"./node_modules/fast-glob/out/readers/stream.js\");\nclass ReaderAsync extends reader_1.default {\n  constructor() {\n    super(...arguments);\n    this._walkAsync = fsWalk.walk;\n    this._readerStream = new stream_1.default(this._settings);\n  }\n  dynamic(root, options) {\n    return new Promise((resolve, reject) => {\n      this._walkAsync(root, options, (error, entries) => {\n        if (error === null) {\n          resolve(entries);\n        } else {\n          reject(error);\n        }\n      });\n    });\n  }\n  static(patterns, options) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const entries = [];\n      const stream = _this._readerStream.static(patterns, options);\n      // After #235, replace it with an asynchronous iterator.\n      return new Promise((resolve, reject) => {\n        stream.once('error', reject);\n        stream.on('data', entry => entries.push(entry));\n        stream.once('end', () => resolve(entries));\n      });\n    })();\n  }\n}\nexports[\"default\"] = ReaderAsync;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fast-glob\\out\\readers\\async.js");

/***/ }),

/***/ "./node_modules/fast-glob/out/readers/reader.js":
/*!******************************************************!*\
  !*** ./node_modules/fast-glob/out/readers/reader.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nconst path = __webpack_require__(/*! path */ \"path\");\nconst fsStat = __webpack_require__(/*! @nodelib/fs.stat */ \"./node_modules/@nodelib/fs.stat/out/index.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"./node_modules/fast-glob/out/utils/index.js\");\nclass Reader {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._fsStatSettings = new fsStat.Settings({\n      followSymbolicLink: this._settings.followSymbolicLinks,\n      fs: this._settings.fs,\n      throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks\n    });\n  }\n  _getFullEntryPath(filepath) {\n    return path.resolve(this._settings.cwd, filepath);\n  }\n  _makeEntry(stats, pattern) {\n    const entry = {\n      name: pattern,\n      path: pattern,\n      dirent: utils.fs.createDirentFromStats(pattern, stats)\n    };\n    if (this._settings.stats) {\n      entry.stats = stats;\n    }\n    return entry;\n  }\n  _isFatalError(error) {\n    return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;\n  }\n}\nexports[\"default\"] = Reader;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fast-glob\\out\\readers\\reader.js");

/***/ }),

/***/ "./node_modules/fast-glob/out/readers/stream.js":
/*!******************************************************!*\
  !*** ./node_modules/fast-glob/out/readers/stream.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst fsStat = __webpack_require__(/*! @nodelib/fs.stat */ \"./node_modules/@nodelib/fs.stat/out/index.js\");\nconst fsWalk = __webpack_require__(/*! @nodelib/fs.walk */ \"./node_modules/@nodelib/fs.walk/out/index.js\");\nconst reader_1 = __webpack_require__(/*! ./reader */ \"./node_modules/fast-glob/out/readers/reader.js\");\nclass ReaderStream extends reader_1.default {\n  constructor() {\n    super(...arguments);\n    this._walkStream = fsWalk.walkStream;\n    this._stat = fsStat.stat;\n  }\n  dynamic(root, options) {\n    return this._walkStream(root, options);\n  }\n  static(patterns, options) {\n    const filepaths = patterns.map(this._getFullEntryPath, this);\n    const stream = new stream_1.PassThrough({\n      objectMode: true\n    });\n    stream._write = (index, _enc, done) => {\n      return this._getEntry(filepaths[index], patterns[index], options).then(entry => {\n        if (entry !== null && options.entryFilter(entry)) {\n          stream.push(entry);\n        }\n        if (index === filepaths.length - 1) {\n          stream.end();\n        }\n        done();\n      }).catch(done);\n    };\n    for (let i = 0; i < filepaths.length; i++) {\n      stream.write(i);\n    }\n    return stream;\n  }\n  _getEntry(filepath, pattern, options) {\n    return this._getStat(filepath).then(stats => this._makeEntry(stats, pattern)).catch(error => {\n      if (options.errorFilter(error)) {\n        return null;\n      }\n      throw error;\n    });\n  }\n  _getStat(filepath) {\n    return new Promise((resolve, reject) => {\n      this._stat(filepath, this._fsStatSettings, (error, stats) => {\n        return error === null ? resolve(stats) : reject(error);\n      });\n    });\n  }\n}\nexports[\"default\"] = ReaderStream;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fast-glob\\out\\readers\\stream.js");

/***/ }),

/***/ "./node_modules/fast-glob/out/readers/sync.js":
/*!****************************************************!*\
  !*** ./node_modules/fast-glob/out/readers/sync.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nconst fsStat = __webpack_require__(/*! @nodelib/fs.stat */ \"./node_modules/@nodelib/fs.stat/out/index.js\");\nconst fsWalk = __webpack_require__(/*! @nodelib/fs.walk */ \"./node_modules/@nodelib/fs.walk/out/index.js\");\nconst reader_1 = __webpack_require__(/*! ./reader */ \"./node_modules/fast-glob/out/readers/reader.js\");\nclass ReaderSync extends reader_1.default {\n  constructor() {\n    super(...arguments);\n    this._walkSync = fsWalk.walkSync;\n    this._statSync = fsStat.statSync;\n  }\n  dynamic(root, options) {\n    return this._walkSync(root, options);\n  }\n  static(patterns, options) {\n    const entries = [];\n    var _iterator = _createForOfIteratorHelper(patterns),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        const pattern = _step.value;\n        const filepath = this._getFullEntryPath(pattern);\n        const entry = this._getEntry(filepath, pattern, options);\n        if (entry === null || !options.entryFilter(entry)) {\n          continue;\n        }\n        entries.push(entry);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return entries;\n  }\n  _getEntry(filepath, pattern, options) {\n    try {\n      const stats = this._getStat(filepath);\n      return this._makeEntry(stats, pattern);\n    } catch (error) {\n      if (options.errorFilter(error)) {\n        return null;\n      }\n      throw error;\n    }\n  }\n  _getStat(filepath) {\n    return this._statSync(filepath, this._fsStatSettings);\n  }\n}\nexports[\"default\"] = ReaderSync;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fast-glob\\out\\readers\\sync.js");

/***/ }),

/***/ "./node_modules/fast-glob/out/settings.js":
/*!************************************************!*\
  !*** ./node_modules/fast-glob/out/settings.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst os = __webpack_require__(/*! os */ \"os\");\n/**\n * The `os.cpus` method can return zero. We expect the number of cores to be greater than zero.\n * https://github.com/nodejs/node/blob/7faeddf23a98c53896f8b574a6e66589e8fb1eb8/lib/os.js#L106-L107\n */\nconst CPU_COUNT = Math.max(os.cpus().length, 1);\nexports.DEFAULT_FILE_SYSTEM_ADAPTER = {\n  lstat: fs.lstat,\n  lstatSync: fs.lstatSync,\n  stat: fs.stat,\n  statSync: fs.statSync,\n  readdir: fs.readdir,\n  readdirSync: fs.readdirSync\n};\nclass Settings {\n  constructor(_options = {}) {\n    this._options = _options;\n    this.absolute = this._getValue(this._options.absolute, false);\n    this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);\n    this.braceExpansion = this._getValue(this._options.braceExpansion, true);\n    this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);\n    this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);\n    this.cwd = this._getValue(this._options.cwd, process.cwd());\n    this.deep = this._getValue(this._options.deep, Infinity);\n    this.dot = this._getValue(this._options.dot, false);\n    this.extglob = this._getValue(this._options.extglob, true);\n    this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);\n    this.fs = this._getFileSystemMethods(this._options.fs);\n    this.globstar = this._getValue(this._options.globstar, true);\n    this.ignore = this._getValue(this._options.ignore, []);\n    this.markDirectories = this._getValue(this._options.markDirectories, false);\n    this.objectMode = this._getValue(this._options.objectMode, false);\n    this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);\n    this.onlyFiles = this._getValue(this._options.onlyFiles, true);\n    this.stats = this._getValue(this._options.stats, false);\n    this.suppressErrors = this._getValue(this._options.suppressErrors, false);\n    this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);\n    this.unique = this._getValue(this._options.unique, true);\n    if (this.onlyDirectories) {\n      this.onlyFiles = false;\n    }\n    if (this.stats) {\n      this.objectMode = true;\n    }\n    // Remove the cast to the array in the next major (#404).\n    this.ignore = [].concat(this.ignore);\n  }\n  _getValue(option, value) {\n    return option === undefined ? value : option;\n  }\n  _getFileSystemMethods(methods = {}) {\n    return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);\n  }\n}\nexports[\"default\"] = Settings;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fast-glob\\out\\settings.js");

/***/ }),

/***/ "./node_modules/fast-glob/out/utils/array.js":
/*!***************************************************!*\
  !*** ./node_modules/fast-glob/out/utils/array.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.splitWhen = exports.flatten = void 0;\nfunction flatten(items) {\n  return items.reduce((collection, item) => [].concat(collection, item), []);\n}\nexports.flatten = flatten;\nfunction splitWhen(items, predicate) {\n  const result = [[]];\n  let groupIndex = 0;\n  var _iterator = _createForOfIteratorHelper(items),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      const item = _step.value;\n      if (predicate(item)) {\n        groupIndex++;\n        result[groupIndex] = [];\n      } else {\n        result[groupIndex].push(item);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return result;\n}\nexports.splitWhen = splitWhen;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fast-glob\\out\\utils\\array.js");

/***/ }),

/***/ "./node_modules/fast-glob/out/utils/errno.js":
/*!***************************************************!*\
  !*** ./node_modules/fast-glob/out/utils/errno.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.isEnoentCodeError = void 0;\nfunction isEnoentCodeError(error) {\n  return error.code === 'ENOENT';\n}\nexports.isEnoentCodeError = isEnoentCodeError;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fast-glob\\out\\utils\\errno.js");

/***/ }),

/***/ "./node_modules/fast-glob/out/utils/fs.js":
/*!************************************************!*\
  !*** ./node_modules/fast-glob/out/utils/fs.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.createDirentFromStats = void 0;\nclass DirentFromStats {\n  constructor(name, stats) {\n    this.name = name;\n    this.isBlockDevice = stats.isBlockDevice.bind(stats);\n    this.isCharacterDevice = stats.isCharacterDevice.bind(stats);\n    this.isDirectory = stats.isDirectory.bind(stats);\n    this.isFIFO = stats.isFIFO.bind(stats);\n    this.isFile = stats.isFile.bind(stats);\n    this.isSocket = stats.isSocket.bind(stats);\n    this.isSymbolicLink = stats.isSymbolicLink.bind(stats);\n  }\n}\nfunction createDirentFromStats(name, stats) {\n  return new DirentFromStats(name, stats);\n}\nexports.createDirentFromStats = createDirentFromStats;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fast-glob\\out\\utils\\fs.js");

/***/ }),

/***/ "./node_modules/fast-glob/out/utils/index.js":
/*!***************************************************!*\
  !*** ./node_modules/fast-glob/out/utils/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.string = exports.stream = exports.pattern = exports.path = exports.fs = exports.errno = exports.array = void 0;\nconst array = __webpack_require__(/*! ./array */ \"./node_modules/fast-glob/out/utils/array.js\");\nexports.array = array;\nconst errno = __webpack_require__(/*! ./errno */ \"./node_modules/fast-glob/out/utils/errno.js\");\nexports.errno = errno;\nconst fs = __webpack_require__(/*! ./fs */ \"./node_modules/fast-glob/out/utils/fs.js\");\nexports.fs = fs;\nconst path = __webpack_require__(/*! ./path */ \"./node_modules/fast-glob/out/utils/path.js\");\nexports.path = path;\nconst pattern = __webpack_require__(/*! ./pattern */ \"./node_modules/fast-glob/out/utils/pattern.js\");\nexports.pattern = pattern;\nconst stream = __webpack_require__(/*! ./stream */ \"./node_modules/fast-glob/out/utils/stream.js\");\nexports.stream = stream;\nconst string = __webpack_require__(/*! ./string */ \"./node_modules/fast-glob/out/utils/string.js\");\nexports.string = string;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fast-glob\\out\\utils\\index.js");

/***/ }),

/***/ "./node_modules/fast-glob/out/utils/path.js":
/*!**************************************************!*\
  !*** ./node_modules/fast-glob/out/utils/path.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.convertPosixPathToPattern = exports.convertWindowsPathToPattern = exports.convertPathToPattern = exports.escapePosixPath = exports.escapeWindowsPath = exports.escape = exports.removeLeadingDotSegment = exports.makeAbsolute = exports.unixify = void 0;\nconst os = __webpack_require__(/*! os */ \"os\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst IS_WINDOWS_PLATFORM = os.platform() === 'win32';\nconst LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2; // ./ or .\\\\\n/**\n * All non-escaped special characters.\n * Posix: ()*?[\\]{|}, !+@ before (, ! at the beginning, \\\\ before non-special characters.\n * Windows: (){}, !+@ before (, ! at the beginning.\n */\nconst POSIX_UNESCAPED_GLOB_SYMBOLS_RE = /(\\\\?)([()*?[\\]{|}]|^!|[!+@](?=\\()|\\\\(?![!()*+?@[\\]{|}]))/g;\nconst WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE = /(\\\\?)([(){}]|^!|[!+@](?=\\())/g;\n/**\n * The device path (\\\\.\\ or \\\\?\\).\n * https://learn.microsoft.com/en-us/dotnet/standard/io/file-path-formats#dos-device-paths\n */\nconst DOS_DEVICE_PATH_RE = /^\\\\\\\\([.?])/;\n/**\n * All backslashes except those escaping special characters.\n * Windows: !()+@{}\n * https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#naming-conventions\n */\nconst WINDOWS_BACKSLASHES_RE = /\\\\(?![!()+@{}])/g;\n/**\n * Designed to work only with simple paths: `dir\\\\file`.\n */\nfunction unixify(filepath) {\n  return filepath.replace(/\\\\/g, '/');\n}\nexports.unixify = unixify;\nfunction makeAbsolute(cwd, filepath) {\n  return path.resolve(cwd, filepath);\n}\nexports.makeAbsolute = makeAbsolute;\nfunction removeLeadingDotSegment(entry) {\n  // We do not use `startsWith` because this is 10x slower than current implementation for some cases.\n  // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with\n  if (entry.charAt(0) === '.') {\n    const secondCharactery = entry.charAt(1);\n    if (secondCharactery === '/' || secondCharactery === '\\\\') {\n      return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);\n    }\n  }\n  return entry;\n}\nexports.removeLeadingDotSegment = removeLeadingDotSegment;\nexports.escape = IS_WINDOWS_PLATFORM ? escapeWindowsPath : escapePosixPath;\nfunction escapeWindowsPath(pattern) {\n  return pattern.replace(WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE, '\\\\$2');\n}\nexports.escapeWindowsPath = escapeWindowsPath;\nfunction escapePosixPath(pattern) {\n  return pattern.replace(POSIX_UNESCAPED_GLOB_SYMBOLS_RE, '\\\\$2');\n}\nexports.escapePosixPath = escapePosixPath;\nexports.convertPathToPattern = IS_WINDOWS_PLATFORM ? convertWindowsPathToPattern : convertPosixPathToPattern;\nfunction convertWindowsPathToPattern(filepath) {\n  return escapeWindowsPath(filepath).replace(DOS_DEVICE_PATH_RE, '//$1').replace(WINDOWS_BACKSLASHES_RE, '/');\n}\nexports.convertWindowsPathToPattern = convertWindowsPathToPattern;\nfunction convertPosixPathToPattern(filepath) {\n  return escapePosixPath(filepath);\n}\nexports.convertPosixPathToPattern = convertPosixPathToPattern;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fast-glob\\out\\utils\\path.js");

/***/ }),

/***/ "./node_modules/fast-glob/out/utils/pattern.js":
/*!*****************************************************!*\
  !*** ./node_modules/fast-glob/out/utils/pattern.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.removeDuplicateSlashes = exports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;\nconst path = __webpack_require__(/*! path */ \"path\");\nconst globParent = __webpack_require__(/*! glob-parent */ \"./node_modules/fast-glob/node_modules/glob-parent/index.js\");\nconst micromatch = __webpack_require__(/*! micromatch */ \"./node_modules/micromatch/index.js\");\nconst GLOBSTAR = '**';\nconst ESCAPE_SYMBOL = '\\\\';\nconst COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;\nconst REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\\[[^[]*]/;\nconst REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\\([^(]*\\|[^|]*\\)/;\nconst GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\\([^(]*\\)/;\nconst BRACE_EXPANSION_SEPARATORS_RE = /,|\\.\\./;\n/**\n * Matches a sequence of two or more consecutive slashes, excluding the first two slashes at the beginning of the string.\n * The latter is due to the presence of the device path at the beginning of the UNC path.\n */\nconst DOUBLE_SLASH_RE = /(?!^)\\/{2,}/g;\nfunction isStaticPattern(pattern, options = {}) {\n  return !isDynamicPattern(pattern, options);\n}\nexports.isStaticPattern = isStaticPattern;\nfunction isDynamicPattern(pattern, options = {}) {\n  /**\n   * A special case with an empty string is necessary for matching patterns that start with a forward slash.\n   * An empty string cannot be a dynamic pattern.\n   * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.\n   */\n  if (pattern === '') {\n    return false;\n  }\n  /**\n   * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check\n   * filepath directly (without read directory).\n   */\n  if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {\n    return true;\n  }\n  if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {\n    return true;\n  }\n  if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {\n    return true;\n  }\n  if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {\n    return true;\n  }\n  return false;\n}\nexports.isDynamicPattern = isDynamicPattern;\nfunction hasBraceExpansion(pattern) {\n  const openingBraceIndex = pattern.indexOf('{');\n  if (openingBraceIndex === -1) {\n    return false;\n  }\n  const closingBraceIndex = pattern.indexOf('}', openingBraceIndex + 1);\n  if (closingBraceIndex === -1) {\n    return false;\n  }\n  const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);\n  return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);\n}\nfunction convertToPositivePattern(pattern) {\n  return isNegativePattern(pattern) ? pattern.slice(1) : pattern;\n}\nexports.convertToPositivePattern = convertToPositivePattern;\nfunction convertToNegativePattern(pattern) {\n  return '!' + pattern;\n}\nexports.convertToNegativePattern = convertToNegativePattern;\nfunction isNegativePattern(pattern) {\n  return pattern.startsWith('!') && pattern[1] !== '(';\n}\nexports.isNegativePattern = isNegativePattern;\nfunction isPositivePattern(pattern) {\n  return !isNegativePattern(pattern);\n}\nexports.isPositivePattern = isPositivePattern;\nfunction getNegativePatterns(patterns) {\n  return patterns.filter(isNegativePattern);\n}\nexports.getNegativePatterns = getNegativePatterns;\nfunction getPositivePatterns(patterns) {\n  return patterns.filter(isPositivePattern);\n}\nexports.getPositivePatterns = getPositivePatterns;\n/**\n * Returns patterns that can be applied inside the current directory.\n *\n * @example\n * // ['./*', '*', 'a/*']\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\n */\nfunction getPatternsInsideCurrentDirectory(patterns) {\n  return patterns.filter(pattern => !isPatternRelatedToParentDirectory(pattern));\n}\nexports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;\n/**\n * Returns patterns to be expanded relative to (outside) the current directory.\n *\n * @example\n * // ['../*', './../*']\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\n */\nfunction getPatternsOutsideCurrentDirectory(patterns) {\n  return patterns.filter(isPatternRelatedToParentDirectory);\n}\nexports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;\nfunction isPatternRelatedToParentDirectory(pattern) {\n  return pattern.startsWith('..') || pattern.startsWith('./..');\n}\nexports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;\nfunction getBaseDirectory(pattern) {\n  return globParent(pattern, {\n    flipBackslashes: false\n  });\n}\nexports.getBaseDirectory = getBaseDirectory;\nfunction hasGlobStar(pattern) {\n  return pattern.includes(GLOBSTAR);\n}\nexports.hasGlobStar = hasGlobStar;\nfunction endsWithSlashGlobStar(pattern) {\n  return pattern.endsWith('/' + GLOBSTAR);\n}\nexports.endsWithSlashGlobStar = endsWithSlashGlobStar;\nfunction isAffectDepthOfReadingPattern(pattern) {\n  const basename = path.basename(pattern);\n  return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);\n}\nexports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;\nfunction expandPatternsWithBraceExpansion(patterns) {\n  return patterns.reduce((collection, pattern) => {\n    return collection.concat(expandBraceExpansion(pattern));\n  }, []);\n}\nexports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;\nfunction expandBraceExpansion(pattern) {\n  const patterns = micromatch.braces(pattern, {\n    expand: true,\n    nodupes: true\n  });\n  /**\n   * Sort the patterns by length so that the same depth patterns are processed side by side.\n   * `a/{b,}/{c,}/*` – `['a///*', 'a/b//*', 'a//c/*', 'a/b/c/*']`\n   */\n  patterns.sort((a, b) => a.length - b.length);\n  /**\n   * Micromatch can return an empty string in the case of patterns like `{a,}`.\n   */\n  return patterns.filter(pattern => pattern !== '');\n}\nexports.expandBraceExpansion = expandBraceExpansion;\nfunction getPatternParts(pattern, options) {\n  let _micromatch$scan = micromatch.scan(pattern, Object.assign(Object.assign({}, options), {\n      parts: true\n    })),\n    parts = _micromatch$scan.parts;\n  /**\n   * The scan method returns an empty array in some cases.\n   * See micromatch/picomatch#58 for more details.\n   */\n  if (parts.length === 0) {\n    parts = [pattern];\n  }\n  /**\n   * The scan method does not return an empty part for the pattern with a forward slash.\n   * This is another part of micromatch/picomatch#58.\n   */\n  if (parts[0].startsWith('/')) {\n    parts[0] = parts[0].slice(1);\n    parts.unshift('');\n  }\n  return parts;\n}\nexports.getPatternParts = getPatternParts;\nfunction makeRe(pattern, options) {\n  return micromatch.makeRe(pattern, options);\n}\nexports.makeRe = makeRe;\nfunction convertPatternsToRe(patterns, options) {\n  return patterns.map(pattern => makeRe(pattern, options));\n}\nexports.convertPatternsToRe = convertPatternsToRe;\nfunction matchAny(entry, patternsRe) {\n  return patternsRe.some(patternRe => patternRe.test(entry));\n}\nexports.matchAny = matchAny;\n/**\n * This package only works with forward slashes as a path separator.\n * Because of this, we cannot use the standard `path.normalize` method, because on Windows platform it will use of backslashes.\n */\nfunction removeDuplicateSlashes(pattern) {\n  return pattern.replace(DOUBLE_SLASH_RE, '/');\n}\nexports.removeDuplicateSlashes = removeDuplicateSlashes;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fast-glob\\out\\utils\\pattern.js");

/***/ }),

/***/ "./node_modules/fast-glob/out/utils/stream.js":
/*!****************************************************!*\
  !*** ./node_modules/fast-glob/out/utils/stream.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.merge = void 0;\nconst merge2 = __webpack_require__(/*! merge2 */ \"./node_modules/merge2/index.js\");\nfunction merge(streams) {\n  const mergedStream = merge2(streams);\n  streams.forEach(stream => {\n    stream.once('error', error => mergedStream.emit('error', error));\n  });\n  mergedStream.once('close', () => propagateCloseEventToSources(streams));\n  mergedStream.once('end', () => propagateCloseEventToSources(streams));\n  return mergedStream;\n}\nexports.merge = merge;\nfunction propagateCloseEventToSources(streams) {\n  streams.forEach(stream => stream.emit('close'));\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fast-glob\\out\\utils\\stream.js");

/***/ }),

/***/ "./node_modules/fast-glob/out/utils/string.js":
/*!****************************************************!*\
  !*** ./node_modules/fast-glob/out/utils/string.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.isEmpty = exports.isString = void 0;\nfunction isString(input) {\n  return typeof input === 'string';\n}\nexports.isString = isString;\nfunction isEmpty(input) {\n  return input === '';\n}\nexports.isEmpty = isEmpty;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fast-glob\\out\\utils\\string.js");

/***/ }),

/***/ "./node_modules/fastq/queue.js":
/*!*************************************!*\
  !*** ./node_modules/fastq/queue.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* eslint-disable no-var */\nvar reusify = __webpack_require__(/*! reusify */ \"./node_modules/reusify/reusify.js\");\nfunction fastqueue(context, worker, concurrency) {\n  if (typeof context === 'function') {\n    concurrency = worker;\n    worker = context;\n    context = null;\n  }\n  if (concurrency < 1) {\n    throw new Error('fastqueue concurrency must be greater than 1');\n  }\n  var cache = reusify(Task);\n  var queueHead = null;\n  var queueTail = null;\n  var _running = 0;\n  var errorHandler = null;\n  var self = {\n    push: push,\n    drain: noop,\n    saturated: noop,\n    pause: pause,\n    paused: false,\n    concurrency: concurrency,\n    running: running,\n    resume: resume,\n    idle: idle,\n    length: length,\n    getQueue: getQueue,\n    unshift: unshift,\n    empty: noop,\n    kill: kill,\n    killAndDrain: killAndDrain,\n    error: error\n  };\n  return self;\n  function running() {\n    return _running;\n  }\n  function pause() {\n    self.paused = true;\n  }\n  function length() {\n    var current = queueHead;\n    var counter = 0;\n    while (current) {\n      current = current.next;\n      counter++;\n    }\n    return counter;\n  }\n  function getQueue() {\n    var current = queueHead;\n    var tasks = [];\n    while (current) {\n      tasks.push(current.value);\n      current = current.next;\n    }\n    return tasks;\n  }\n  function resume() {\n    if (!self.paused) return;\n    self.paused = false;\n    for (var i = 0; i < self.concurrency; i++) {\n      _running++;\n      release();\n    }\n  }\n  function idle() {\n    return _running === 0 && self.length() === 0;\n  }\n  function push(value, done) {\n    var current = cache.get();\n    current.context = context;\n    current.release = release;\n    current.value = value;\n    current.callback = done || noop;\n    current.errorHandler = errorHandler;\n    if (_running === self.concurrency || self.paused) {\n      if (queueTail) {\n        queueTail.next = current;\n        queueTail = current;\n      } else {\n        queueHead = current;\n        queueTail = current;\n        self.saturated();\n      }\n    } else {\n      _running++;\n      worker.call(context, current.value, current.worked);\n    }\n  }\n  function unshift(value, done) {\n    var current = cache.get();\n    current.context = context;\n    current.release = release;\n    current.value = value;\n    current.callback = done || noop;\n    if (_running === self.concurrency || self.paused) {\n      if (queueHead) {\n        current.next = queueHead;\n        queueHead = current;\n      } else {\n        queueHead = current;\n        queueTail = current;\n        self.saturated();\n      }\n    } else {\n      _running++;\n      worker.call(context, current.value, current.worked);\n    }\n  }\n  function release(holder) {\n    if (holder) {\n      cache.release(holder);\n    }\n    var next = queueHead;\n    if (next) {\n      if (!self.paused) {\n        if (queueTail === queueHead) {\n          queueTail = null;\n        }\n        queueHead = next.next;\n        next.next = null;\n        worker.call(context, next.value, next.worked);\n        if (queueTail === null) {\n          self.empty();\n        }\n      } else {\n        _running--;\n      }\n    } else if (--_running === 0) {\n      self.drain();\n    }\n  }\n  function kill() {\n    queueHead = null;\n    queueTail = null;\n    self.drain = noop;\n  }\n  function killAndDrain() {\n    queueHead = null;\n    queueTail = null;\n    self.drain();\n    self.drain = noop;\n  }\n  function error(handler) {\n    errorHandler = handler;\n  }\n}\nfunction noop() {}\nfunction Task() {\n  this.value = null;\n  this.callback = noop;\n  this.next = null;\n  this.release = noop;\n  this.context = null;\n  this.errorHandler = null;\n  var self = this;\n  this.worked = function worked(err, result) {\n    var callback = self.callback;\n    var errorHandler = self.errorHandler;\n    var val = self.value;\n    self.value = null;\n    self.callback = noop;\n    if (self.errorHandler) {\n      errorHandler(err, val);\n    }\n    callback.call(self.context, err, result);\n    self.release(self);\n  };\n}\nfunction queueAsPromised(context, worker, concurrency) {\n  if (typeof context === 'function') {\n    concurrency = worker;\n    worker = context;\n    context = null;\n  }\n  function asyncWrapper(arg, cb) {\n    worker.call(this, arg).then(function (res) {\n      cb(null, res);\n    }, cb);\n  }\n  var queue = fastqueue(context, asyncWrapper, concurrency);\n  var pushCb = queue.push;\n  var unshiftCb = queue.unshift;\n  queue.push = push;\n  queue.unshift = unshift;\n  queue.drained = drained;\n  return queue;\n  function push(value) {\n    var p = new Promise(function (resolve, reject) {\n      pushCb(value, function (err, result) {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(result);\n      });\n    });\n\n    // Let's fork the promise chain to\n    // make the error bubble up to the user but\n    // not lead to a unhandledRejection\n    p.catch(noop);\n    return p;\n  }\n  function unshift(value) {\n    var p = new Promise(function (resolve, reject) {\n      unshiftCb(value, function (err, result) {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(result);\n      });\n    });\n\n    // Let's fork the promise chain to\n    // make the error bubble up to the user but\n    // not lead to a unhandledRejection\n    p.catch(noop);\n    return p;\n  }\n  function drained() {\n    if (queue.idle()) {\n      return new Promise(function (resolve) {\n        resolve();\n      });\n    }\n    var previousDrain = queue.drain;\n    var p = new Promise(function (resolve) {\n      queue.drain = function () {\n        previousDrain();\n        resolve();\n      };\n    });\n    return p;\n  }\n}\nmodule.exports = fastqueue;\nmodule.exports.promise = queueAsPromised;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fastq\\queue.js");

/***/ }),

/***/ "./node_modules/fs.realpath/index.js":
/*!*******************************************!*\
  !*** ./node_modules/fs.realpath/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = realpath;\nrealpath.realpath = realpath;\nrealpath.sync = realpathSync;\nrealpath.realpathSync = realpathSync;\nrealpath.monkeypatch = monkeypatch;\nrealpath.unmonkeypatch = unmonkeypatch;\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar origRealpath = fs.realpath;\nvar origRealpathSync = fs.realpathSync;\nvar version = process.version;\nvar ok = /^v[0-5]\\./.test(version);\nvar old = __webpack_require__(/*! ./old.js */ \"./node_modules/fs.realpath/old.js\");\nfunction newError(er) {\n  return er && er.syscall === 'realpath' && (er.code === 'ELOOP' || er.code === 'ENOMEM' || er.code === 'ENAMETOOLONG');\n}\nfunction realpath(p, cache, cb) {\n  if (ok) {\n    return origRealpath(p, cache, cb);\n  }\n  if (typeof cache === 'function') {\n    cb = cache;\n    cache = null;\n  }\n  origRealpath(p, cache, function (er, result) {\n    if (newError(er)) {\n      old.realpath(p, cache, cb);\n    } else {\n      cb(er, result);\n    }\n  });\n}\nfunction realpathSync(p, cache) {\n  if (ok) {\n    return origRealpathSync(p, cache);\n  }\n  try {\n    return origRealpathSync(p, cache);\n  } catch (er) {\n    if (newError(er)) {\n      return old.realpathSync(p, cache);\n    } else {\n      throw er;\n    }\n  }\n}\nfunction monkeypatch() {\n  fs.realpath = realpath;\n  fs.realpathSync = realpathSync;\n}\nfunction unmonkeypatch() {\n  fs.realpath = origRealpath;\n  fs.realpathSync = origRealpathSync;\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fs.realpath\\index.js");

/***/ }),

/***/ "./node_modules/fs.realpath/old.js":
/*!*****************************************!*\
  !*** ./node_modules/fs.realpath/old.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar pathModule = __webpack_require__(/*! path */ \"path\");\nvar isWindows = process.platform === 'win32';\nvar fs = __webpack_require__(/*! fs */ \"fs\");\n\n// JavaScript implementation of realpath, ported from node pre-v6\n\nvar DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\nfunction rethrow() {\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\n  // is fairly slow to generate.\n  var callback;\n  if (DEBUG) {\n    var backtrace = new Error();\n    callback = debugCallback;\n  } else callback = missingCallback;\n  return callback;\n  function debugCallback(err) {\n    if (err) {\n      backtrace.message = err.message;\n      err = backtrace;\n      missingCallback(err);\n    }\n  }\n  function missingCallback(err) {\n    if (err) {\n      if (process.throwDeprecation) throw err; // Forgot a callback but don't know where? Use NODE_DEBUG=fs\n      else if (!process.noDeprecation) {\n        var msg = 'fs: missing callback ' + (err.stack || err.message);\n        if (process.traceDeprecation) console.trace(msg);else console.error(msg);\n      }\n    }\n  }\n}\nfunction maybeCallback(cb) {\n  return typeof cb === 'function' ? cb : rethrow();\n}\nvar normalize = pathModule.normalize;\n\n// Regexp that finds the next partion of a (partial) path\n// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']\nif (isWindows) {\n  var nextPartRe = /(.*?)(?:[\\/\\\\]+|$)/g;\n} else {\n  var nextPartRe = /(.*?)(?:[\\/]+|$)/g;\n}\n\n// Regex to find the device root, including trailing slash. E.g. 'c:\\\\'.\nif (isWindows) {\n  var splitRootRe = /^(?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/][^\\\\\\/]+)?[\\\\\\/]*/;\n} else {\n  var splitRootRe = /^[\\/]*/;\n}\nexports.realpathSync = function realpathSync(p, cache) {\n  // make p is absolute\n  p = pathModule.resolve(p);\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return cache[p];\n  }\n  var original = p,\n    seenLinks = {},\n    knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n  start();\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstatSync(base);\n      knownHard[base] = true;\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || cache && cache[base] === base) {\n      continue;\n    }\n    var resolvedLink;\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // some known symbolic link.  no need to stat again.\n      resolvedLink = cache[base];\n    } else {\n      var stat = fs.lstatSync(base);\n      if (!stat.isSymbolicLink()) {\n        knownHard[base] = true;\n        if (cache) cache[base] = base;\n        continue;\n      }\n\n      // read the link if it wasn't read before\n      // dev/ino always return 0 on windows, so skip the check.\n      var linkTarget = null;\n      if (!isWindows) {\n        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n        if (seenLinks.hasOwnProperty(id)) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (linkTarget === null) {\n        fs.statSync(base);\n        linkTarget = fs.readlinkSync(base);\n      }\n      resolvedLink = pathModule.resolve(previous, linkTarget);\n      // track this, if given a cache.\n      if (cache) cache[base] = resolvedLink;\n      if (!isWindows) seenLinks[id] = linkTarget;\n    }\n\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n  if (cache) cache[original] = p;\n  return p;\n};\nexports.realpath = function realpath(p, cache, cb) {\n  if (typeof cb !== 'function') {\n    cb = maybeCallback(cache);\n    cache = null;\n  }\n\n  // make p is absolute\n  p = pathModule.resolve(p);\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return process.nextTick(cb.bind(null, null, cache[p]));\n  }\n  var original = p,\n    seenLinks = {},\n    knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n  start();\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base, function (err) {\n        if (err) return cb(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  function LOOP() {\n    // stop if scanned past end of path\n    if (pos >= p.length) {\n      if (cache) cache[original] = p;\n      return cb(null, p);\n    }\n\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || cache && cache[base] === base) {\n      return process.nextTick(LOOP);\n    }\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // known symbolic link.  no need to stat again.\n      return gotResolvedLink(cache[base]);\n    }\n    return fs.lstat(base, gotStat);\n  }\n  function gotStat(err, stat) {\n    if (err) return cb(err);\n\n    // if not a symlink, skip to the next path part\n    if (!stat.isSymbolicLink()) {\n      knownHard[base] = true;\n      if (cache) cache[base] = base;\n      return process.nextTick(LOOP);\n    }\n\n    // stat & read the link if not read before\n    // call gotTarget as soon as the link target is known\n    // dev/ino always return 0 on windows, so skip the check.\n    if (!isWindows) {\n      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n      if (seenLinks.hasOwnProperty(id)) {\n        return gotTarget(null, seenLinks[id], base);\n      }\n    }\n    fs.stat(base, function (err) {\n      if (err) return cb(err);\n      fs.readlink(base, function (err, target) {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err, target);\n      });\n    });\n  }\n  function gotTarget(err, target, base) {\n    if (err) return cb(err);\n    var resolvedLink = pathModule.resolve(previous, target);\n    if (cache) cache[base] = resolvedLink;\n    gotResolvedLink(resolvedLink);\n  }\n  function gotResolvedLink(resolvedLink) {\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n};\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\fs.realpath\\old.js");

/***/ }),

/***/ "./node_modules/inflight/inflight.js":
/*!*******************************************!*\
  !*** ./node_modules/inflight/inflight.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar wrappy = __webpack_require__(/*! wrappy */ \"./node_modules/wrappy/wrappy.js\");\nvar reqs = Object.create(null);\nvar once = __webpack_require__(/*! once */ \"./node_modules/once/once.js\");\nmodule.exports = wrappy(inflight);\nfunction inflight(key, cb) {\n  if (reqs[key]) {\n    reqs[key].push(cb);\n    return null;\n  } else {\n    reqs[key] = [cb];\n    return makeres(key);\n  }\n}\nfunction makeres(key) {\n  return once(function RES() {\n    var cbs = reqs[key];\n    var len = cbs.length;\n    var args = slice(arguments);\n\n    // XXX It's somewhat ambiguous whether a new callback added in this\n    // pass should be queued for later execution if something in the\n    // list of callbacks throws, or if it should just be discarded.\n    // However, it's such an edge case that it hardly matters, and either\n    // choice is likely as surprising as the other.\n    // As it happens, we do go ahead and schedule it for later execution.\n    try {\n      for (var i = 0; i < len; i++) {\n        cbs[i].apply(null, args);\n      }\n    } finally {\n      if (cbs.length > len) {\n        // added more in the interim.\n        // de-zalgo, just in case, but don't call again.\n        cbs.splice(0, len);\n        process.nextTick(function () {\n          RES.apply(null, args);\n        });\n      } else {\n        delete reqs[key];\n      }\n    }\n  });\n}\nfunction slice(args) {\n  var length = args.length;\n  var array = [];\n  for (var i = 0; i < length; i++) array[i] = args[i];\n  return array;\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\inflight\\inflight.js");

/***/ }),

/***/ "./node_modules/inherits/inherits.js":
/*!*******************************************!*\
  !*** ./node_modules/inherits/inherits.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\ntry {\n  var util = __webpack_require__(/*! util */ \"util\");\n  /* istanbul ignore next */\n  if (typeof util.inherits !== 'function') throw '';\n  module.exports = util.inherits;\n} catch (e) {\n  /* istanbul ignore next */\n  module.exports = __webpack_require__(/*! ./inherits_browser.js */ \"./node_modules/inherits/inherits_browser.js\");\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\inherits\\inherits.js");

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor;\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor;\n      var TempCtor = function TempCtor() {};\n      TempCtor.prototype = superCtor.prototype;\n      ctor.prototype = new TempCtor();\n      ctor.prototype.constructor = ctor;\n    }\n  };\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\inherits\\inherits_browser.js");

/***/ }),

/***/ "./node_modules/is-extglob/index.js":
/*!******************************************!*\
  !*** ./node_modules/is-extglob/index.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * is-extglob <https://github.com/jonschlinkert/is-extglob>\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nmodule.exports = function isExtglob(str) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n  var match;\n  while (match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str)) {\n    if (match[2]) return true;\n    str = str.slice(match.index + match[0].length);\n  }\n  return false;\n};\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\is-extglob\\index.js");

/***/ }),

/***/ "./node_modules/is-glob/index.js":
/*!***************************************!*\
  !*** ./node_modules/is-glob/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * is-glob <https://github.com/jonschlinkert/is-glob>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isExtglob = __webpack_require__(/*! is-extglob */ \"./node_modules/is-extglob/index.js\");\nvar chars = {\n  '{': '}',\n  '(': ')',\n  '[': ']'\n};\nvar strictCheck = function strictCheck(str) {\n  if (str[0] === '!') {\n    return true;\n  }\n  var index = 0;\n  var pipeIndex = -2;\n  var closeSquareIndex = -2;\n  var closeCurlyIndex = -2;\n  var closeParenIndex = -2;\n  var backSlashIndex = -2;\n  while (index < str.length) {\n    if (str[index] === '*') {\n      return true;\n    }\n    if (str[index + 1] === '?' && /[\\].+)]/.test(str[index])) {\n      return true;\n    }\n    if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {\n      if (closeSquareIndex < index) {\n        closeSquareIndex = str.indexOf(']', index);\n      }\n      if (closeSquareIndex > index) {\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n      }\n    }\n    if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {\n      closeCurlyIndex = str.indexOf('}', index);\n      if (closeCurlyIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {\n          return true;\n        }\n      }\n    }\n    if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {\n      closeParenIndex = str.indexOf(')', index);\n      if (closeParenIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n          return true;\n        }\n      }\n    }\n    if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {\n      if (pipeIndex < index) {\n        pipeIndex = str.indexOf('|', index);\n      }\n      if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {\n        closeParenIndex = str.indexOf(')', pipeIndex);\n        if (closeParenIndex > pipeIndex) {\n          backSlashIndex = str.indexOf('\\\\', pipeIndex);\n          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n            return true;\n          }\n        }\n      }\n    }\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n      if (close) {\n        var n = str.indexOf(close, index);\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n  return false;\n};\nvar relaxedCheck = function relaxedCheck(str) {\n  if (str[0] === '!') {\n    return true;\n  }\n  var index = 0;\n  while (index < str.length) {\n    if (/[*?{}()[\\]]/.test(str[index])) {\n      return true;\n    }\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n      if (close) {\n        var n = str.indexOf(close, index);\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n  return false;\n};\nmodule.exports = function isGlob(str, options) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n  if (isExtglob(str)) {\n    return true;\n  }\n  var check = strictCheck;\n\n  // optionally relax check\n  if (options && options.strict === false) {\n    check = relaxedCheck;\n  }\n  return check(str);\n};\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\is-glob\\index.js");

/***/ }),

/***/ "./node_modules/merge2/index.js":
/*!**************************************!*\
  !*** ./node_modules/merge2/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*\n * merge2\n * https://github.com/teambition/merge2\n *\n * Copyright (c) 2014-2020 Teambition\n * Licensed under the MIT license.\n */\nconst Stream = __webpack_require__(/*! stream */ \"stream\");\nconst PassThrough = Stream.PassThrough;\nconst slice = Array.prototype.slice;\nmodule.exports = merge2;\nfunction merge2() {\n  const streamsQueue = [];\n  const args = slice.call(arguments);\n  let merging = false;\n  let options = args[args.length - 1];\n  if (options && !Array.isArray(options) && options.pipe == null) {\n    args.pop();\n  } else {\n    options = {};\n  }\n  const doEnd = options.end !== false;\n  const doPipeError = options.pipeError === true;\n  if (options.objectMode == null) {\n    options.objectMode = true;\n  }\n  if (options.highWaterMark == null) {\n    options.highWaterMark = 64 * 1024;\n  }\n  const mergedStream = PassThrough(options);\n  function addStream() {\n    for (let i = 0, len = arguments.length; i < len; i++) {\n      streamsQueue.push(pauseStreams(arguments[i], options));\n    }\n    mergeStream();\n    return this;\n  }\n  function mergeStream() {\n    if (merging) {\n      return;\n    }\n    merging = true;\n    let streams = streamsQueue.shift();\n    if (!streams) {\n      process.nextTick(endStream);\n      return;\n    }\n    if (!Array.isArray(streams)) {\n      streams = [streams];\n    }\n    let pipesCount = streams.length + 1;\n    function next() {\n      if (--pipesCount > 0) {\n        return;\n      }\n      merging = false;\n      mergeStream();\n    }\n    function pipe(stream) {\n      function onend() {\n        stream.removeListener('merge2UnpipeEnd', onend);\n        stream.removeListener('end', onend);\n        if (doPipeError) {\n          stream.removeListener('error', onerror);\n        }\n        next();\n      }\n      function onerror(err) {\n        mergedStream.emit('error', err);\n      }\n      // skip ended stream\n      if (stream._readableState.endEmitted) {\n        return next();\n      }\n      stream.on('merge2UnpipeEnd', onend);\n      stream.on('end', onend);\n      if (doPipeError) {\n        stream.on('error', onerror);\n      }\n      stream.pipe(mergedStream, {\n        end: false\n      });\n      // compatible for old stream\n      stream.resume();\n    }\n    for (let i = 0; i < streams.length; i++) {\n      pipe(streams[i]);\n    }\n    next();\n  }\n  function endStream() {\n    merging = false;\n    // emit 'queueDrain' when all streams merged.\n    mergedStream.emit('queueDrain');\n    if (doEnd) {\n      mergedStream.end();\n    }\n  }\n  mergedStream.setMaxListeners(0);\n  mergedStream.add = addStream;\n  mergedStream.on('unpipe', function (stream) {\n    stream.emit('merge2UnpipeEnd');\n  });\n  if (args.length) {\n    addStream.apply(null, args);\n  }\n  return mergedStream;\n}\n\n// check and pause streams for pipe.\nfunction pauseStreams(streams, options) {\n  if (!Array.isArray(streams)) {\n    // Backwards-compat with old-style streams\n    if (!streams._readableState && streams.pipe) {\n      streams = streams.pipe(PassThrough(options));\n    }\n    if (!streams._readableState || !streams.pause || !streams.pipe) {\n      throw new Error('Only readable stream can be merged.');\n    }\n    streams.pause();\n  } else {\n    for (let i = 0, len = streams.length; i < len; i++) {\n      streams[i] = pauseStreams(streams[i], options);\n    }\n  }\n  return streams;\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\merge2\\index.js");

/***/ }),

/***/ "./node_modules/micromatch/index.js":
/*!******************************************!*\
  !*** ./node_modules/micromatch/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nconst util = __webpack_require__(/*! util */ \"util\");\nconst braces = __webpack_require__(/*! braces */ \"./node_modules/micromatch/node_modules/braces/index.js\");\nconst picomatch = __webpack_require__(/*! picomatch */ \"./node_modules/picomatch/index.js\");\nconst utils = __webpack_require__(/*! picomatch/lib/utils */ \"./node_modules/picomatch/lib/utils.js\");\nconst isEmptyString = val => val === '' || val === './';\n\n/**\n * Returns an array of strings that match one or more glob patterns.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm(list, patterns[, options]);\n *\n * console.log(mm(['a.js', 'a.txt'], ['*.js']));\n * //=> [ 'a.js' ]\n * ```\n * @param {String|Array<string>} `list` List of strings to match.\n * @param {String|Array<string>} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options)\n * @return {Array} Returns an array of matches\n * @summary false\n * @api public\n */\n\nconst micromatch = (list, patterns, options) => {\n  patterns = [].concat(patterns);\n  list = [].concat(list);\n  let omit = new Set();\n  let keep = new Set();\n  let items = new Set();\n  let negatives = 0;\n  let onResult = state => {\n    items.add(state.output);\n    if (options && options.onResult) {\n      options.onResult(state);\n    }\n  };\n  for (let i = 0; i < patterns.length; i++) {\n    let isMatch = picomatch(String(patterns[i]), _objectSpread(_objectSpread({}, options), {}, {\n      onResult\n    }), true);\n    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;\n    if (negated) negatives++;\n    var _iterator = _createForOfIteratorHelper(list),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        let item = _step.value;\n        let matched = isMatch(item, true);\n        let match = negated ? !matched.isMatch : matched.isMatch;\n        if (!match) continue;\n        if (negated) {\n          omit.add(matched.output);\n        } else {\n          omit.delete(matched.output);\n          keep.add(matched.output);\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  let result = negatives === patterns.length ? [...items] : [...keep];\n  let matches = result.filter(item => !omit.has(item));\n  if (options && matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error(`No matches found for \"${patterns.join(', ')}\"`);\n    }\n    if (options.nonull === true || options.nullglob === true) {\n      return options.unescape ? patterns.map(p => p.replace(/\\\\/g, '')) : patterns;\n    }\n  }\n  return matches;\n};\n\n/**\n * Backwards compatibility\n */\n\nmicromatch.match = micromatch;\n\n/**\n * Returns a matcher function from the given glob `pattern` and `options`.\n * The returned function takes a string to match as its only argument and returns\n * true if the string is a match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matcher(pattern[, options]);\n *\n * const isMatch = mm.matcher('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @param {String} `pattern` Glob pattern\n * @param {Object} `options`\n * @return {Function} Returns a matcher function.\n * @api public\n */\n\nmicromatch.matcher = (pattern, options) => picomatch(pattern, options);\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.isMatch(string, patterns[, options]);\n *\n * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(mm.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `[options]` See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Backwards compatibility\n */\n\nmicromatch.any = micromatch.isMatch;\n\n/**\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.not(list, patterns[, options]);\n *\n * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));\n * //=> ['b.b', 'c.c']\n * ```\n * @param {Array} `list` Array of strings to match.\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\n * @api public\n */\n\nmicromatch.not = (list, patterns, options = {}) => {\n  patterns = [].concat(patterns).map(String);\n  let result = new Set();\n  let items = [];\n  let onResult = state => {\n    if (options.onResult) options.onResult(state);\n    items.push(state.output);\n  };\n  let matches = new Set(micromatch(list, patterns, _objectSpread(_objectSpread({}, options), {}, {\n    onResult\n  })));\n  for (var _i = 0, _items = items; _i < _items.length; _i++) {\n    let item = _items[_i];\n    if (!matches.has(item)) {\n      result.add(item);\n    }\n  }\n  return [...result];\n};\n\n/**\n * Returns true if the given `string` contains the given pattern. Similar\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\n *\n * ```js\n * var mm = require('micromatch');\n * // mm.contains(string, pattern[, options]);\n *\n * console.log(mm.contains('aa/bb/cc', '*b'));\n * //=> true\n * console.log(mm.contains('aa/bb/cc', '*d'));\n * //=> false\n * ```\n * @param {String} `str` The string to match.\n * @param {String|Array} `patterns` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any of the patterns matches any part of `str`.\n * @api public\n */\n\nmicromatch.contains = (str, pattern, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n  if (Array.isArray(pattern)) {\n    return pattern.some(p => micromatch.contains(str, p, options));\n  }\n  if (typeof pattern === 'string') {\n    if (isEmptyString(str) || isEmptyString(pattern)) {\n      return false;\n    }\n    if (str.includes(pattern) || str.startsWith('./') && str.slice(2).includes(pattern)) {\n      return true;\n    }\n  }\n  return micromatch.isMatch(str, pattern, _objectSpread(_objectSpread({}, options), {}, {\n    contains: true\n  }));\n};\n\n/**\n * Filter the keys of the given object with the given `glob` pattern\n * and `options`. Does not attempt to match nested keys. If you need this feature,\n * use [glob-object][] instead.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matchKeys(object, patterns[, options]);\n *\n * const obj = { aa: 'a', ab: 'b', ac: 'c' };\n * console.log(mm.matchKeys(obj, '*b'));\n * //=> { ab: 'b' }\n * ```\n * @param {Object} `object` The object with keys to filter.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Object} Returns an object with only keys that match the given patterns.\n * @api public\n */\n\nmicromatch.matchKeys = (obj, patterns, options) => {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('Expected the first argument to be an object');\n  }\n  let keys = micromatch(Object.keys(obj), patterns, options);\n  let res = {};\n  var _iterator2 = _createForOfIteratorHelper(keys),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      let key = _step2.value;\n      res[key] = obj[key];\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return res;\n};\n\n/**\n * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.some(list, patterns[, options]);\n *\n * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // true\n * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any `patterns` matches any of the strings in `list`\n * @api public\n */\n\nmicromatch.some = (list, patterns, options) => {\n  let items = [].concat(list);\n  var _iterator3 = _createForOfIteratorHelper([].concat(patterns)),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      let pattern = _step3.value;\n      let isMatch = picomatch(String(pattern), options);\n      if (items.some(item => isMatch(item))) {\n        return true;\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return false;\n};\n\n/**\n * Returns true if every string in the given `list` matches\n * any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.every(list, patterns[, options]);\n *\n * console.log(mm.every('foo.js', ['foo.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // false\n * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if all `patterns` matches all of the strings in `list`\n * @api public\n */\n\nmicromatch.every = (list, patterns, options) => {\n  let items = [].concat(list);\n  var _iterator4 = _createForOfIteratorHelper([].concat(patterns)),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      let pattern = _step4.value;\n      let isMatch = picomatch(String(pattern), options);\n      if (!items.every(item => isMatch(item))) {\n        return false;\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  return true;\n};\n\n/**\n * Returns true if **all** of the given `patterns` match\n * the specified string.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.all(string, patterns[, options]);\n *\n * console.log(mm.all('foo.js', ['foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', '!foo.js']));\n * // false\n *\n * console.log(mm.all('foo.js', ['*.js', 'foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\n * // true\n * ```\n * @param {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.all = (str, patterns, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n  return [].concat(patterns).every(p => picomatch(p, options)(str));\n};\n\n/**\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.capture(pattern, string[, options]);\n *\n * console.log(mm.capture('test/*.js', 'test/foo.js'));\n * //=> ['foo']\n * console.log(mm.capture('test/*.js', 'foo/bar.css'));\n * //=> null\n * ```\n * @param {String} `glob` Glob pattern to use for matching.\n * @param {String} `input` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array|null} Returns an array of captures if the input matches the glob pattern, otherwise `null`.\n * @api public\n */\n\nmicromatch.capture = (glob, input, options) => {\n  let posix = utils.isWindows(options);\n  let regex = picomatch.makeRe(String(glob), _objectSpread(_objectSpread({}, options), {}, {\n    capture: true\n  }));\n  let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);\n  if (match) {\n    return match.slice(1).map(v => v === void 0 ? '' : v);\n  }\n};\n\n/**\n * Create a regular expression from the given glob `pattern`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.makeRe(pattern[, options]);\n *\n * console.log(mm.makeRe('*.js'));\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\n * ```\n * @param {String} `pattern` A glob pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\nmicromatch.makeRe = (...args) => picomatch.makeRe(...args);\n\n/**\n * Scan a glob pattern to separate the pattern into segments. Used\n * by the [split](#split) method.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm.scan(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\nmicromatch.scan = (...args) => picomatch.scan(...args);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm.parse(pattern[, options]);\n * ```\n * @param {String} `glob`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as regex source string.\n * @api public\n */\n\nmicromatch.parse = (patterns, options) => {\n  let res = [];\n  var _iterator5 = _createForOfIteratorHelper([].concat(patterns || [])),\n    _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      let pattern = _step5.value;\n      var _iterator6 = _createForOfIteratorHelper(braces(String(pattern), options)),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          let str = _step6.value;\n          res.push(picomatch.parse(str, options));\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  return res;\n};\n\n/**\n * Process the given brace `pattern`.\n *\n * ```js\n * const { braces } = require('micromatch');\n * console.log(braces('foo/{a,b,c}/bar'));\n * //=> [ 'foo/(a|b|c)/bar' ]\n *\n * console.log(braces('foo/{a,b,c}/bar', { expand: true }));\n * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]\n * ```\n * @param {String} `pattern` String with brace pattern to process.\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\n * @return {Array}\n * @api public\n */\n\nmicromatch.braces = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n  if (options && options.nobrace === true || !/\\{.*\\}/.test(pattern)) {\n    return [pattern];\n  }\n  return braces(pattern, options);\n};\n\n/**\n * Expand braces\n */\n\nmicromatch.braceExpand = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n  return micromatch.braces(pattern, _objectSpread(_objectSpread({}, options), {}, {\n    expand: true\n  }));\n};\n\n/**\n * Expose micromatch\n */\n\nmodule.exports = micromatch;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\micromatch\\index.js");

/***/ }),

/***/ "./node_modules/micromatch/node_modules/braces/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/micromatch/node_modules/braces/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nconst stringify = __webpack_require__(/*! ./lib/stringify */ \"./node_modules/micromatch/node_modules/braces/lib/stringify.js\");\nconst compile = __webpack_require__(/*! ./lib/compile */ \"./node_modules/micromatch/node_modules/braces/lib/compile.js\");\nconst expand = __webpack_require__(/*! ./lib/expand */ \"./node_modules/micromatch/node_modules/braces/lib/expand.js\");\nconst parse = __webpack_require__(/*! ./lib/parse */ \"./node_modules/micromatch/node_modules/braces/lib/parse.js\");\n\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nconst braces = (input, options = {}) => {\n  let output = [];\n  if (Array.isArray(input)) {\n    var _iterator = _createForOfIteratorHelper(input),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        let pattern = _step.value;\n        let result = braces.create(pattern, options);\n        if (Array.isArray(result)) {\n          output.push(...result);\n        } else {\n          output.push(result);\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  } else {\n    output = [].concat(braces.create(input, options));\n  }\n  if (options && options.expand === true && options.nodupes === true) {\n    output = [...new Set(output)];\n  }\n  return output;\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\n\nbraces.parse = (input, options = {}) => parse(input, options);\n\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.stringify = (input, options = {}) => {\n  if (typeof input === 'string') {\n    return stringify(braces.parse(input, options), options);\n  }\n  return stringify(input, options);\n};\n\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.compile = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n  return compile(input, options);\n};\n\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.expand = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n  let result = expand(input, options);\n\n  // filter out empty strings if specified\n  if (options.noempty === true) {\n    result = result.filter(Boolean);\n  }\n\n  // filter out duplicates if specified\n  if (options.nodupes === true) {\n    result = [...new Set(result)];\n  }\n  return result;\n};\n\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.create = (input, options = {}) => {\n  if (input === '' || input.length < 3) {\n    return [input];\n  }\n  return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);\n};\n\n/**\n * Expose \"braces\"\n */\n\nmodule.exports = braces;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\micromatch\\node_modules\\braces\\index.js");

/***/ }),

/***/ "./node_modules/micromatch/node_modules/braces/lib/compile.js":
/*!********************************************************************!*\
  !*** ./node_modules/micromatch/node_modules/braces/lib/compile.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nconst fill = __webpack_require__(/*! fill-range */ \"./node_modules/micromatch/node_modules/fill-range/index.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/micromatch/node_modules/braces/lib/utils.js\");\nconst compile = (ast, options = {}) => {\n  let walk = (node, parent = {}) => {\n    let invalidBlock = utils.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let invalid = invalidBlock === true || invalidNode === true;\n    let prefix = options.escapeInvalid === true ? '\\\\' : '';\n    let output = '';\n    if (node.isOpen === true) {\n      return prefix + node.value;\n    }\n    if (node.isClose === true) {\n      return prefix + node.value;\n    }\n    if (node.type === 'open') {\n      return invalid ? prefix + node.value : '(';\n    }\n    if (node.type === 'close') {\n      return invalid ? prefix + node.value : ')';\n    }\n    if (node.type === 'comma') {\n      return node.prev.type === 'comma' ? '' : invalid ? node.value : '|';\n    }\n    if (node.value) {\n      return node.value;\n    }\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n      let range = fill(...args, _objectSpread(_objectSpread({}, options), {}, {\n        wrap: false,\n        toRegex: true\n      }));\n      if (range.length !== 0) {\n        return args.length > 1 && range.length > 1 ? `(${range})` : range;\n      }\n    }\n    if (node.nodes) {\n      var _iterator = _createForOfIteratorHelper(node.nodes),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          let child = _step.value;\n          output += walk(child, node);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    return output;\n  };\n  return walk(ast);\n};\nmodule.exports = compile;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\micromatch\\node_modules\\braces\\lib\\compile.js");

/***/ }),

/***/ "./node_modules/micromatch/node_modules/braces/lib/constants.js":
/*!**********************************************************************!*\
  !*** ./node_modules/micromatch/node_modules/braces/lib/constants.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n  // Digits\n  CHAR_0: '0',\n  /* 0 */\n  CHAR_9: '9',\n  /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 'A',\n  /* A */\n  CHAR_LOWERCASE_A: 'a',\n  /* a */\n  CHAR_UPPERCASE_Z: 'Z',\n  /* Z */\n  CHAR_LOWERCASE_Z: 'z',\n  /* z */\n\n  CHAR_LEFT_PARENTHESES: '(',\n  /* ( */\n  CHAR_RIGHT_PARENTHESES: ')',\n  /* ) */\n\n  CHAR_ASTERISK: '*',\n  /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: '&',\n  /* & */\n  CHAR_AT: '@',\n  /* @ */\n  CHAR_BACKSLASH: '\\\\',\n  /* \\ */\n  CHAR_BACKTICK: '`',\n  /* ` */\n  CHAR_CARRIAGE_RETURN: '\\r',\n  /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: '^',\n  /* ^ */\n  CHAR_COLON: ':',\n  /* : */\n  CHAR_COMMA: ',',\n  /* , */\n  CHAR_DOLLAR: '$',\n  /* . */\n  CHAR_DOT: '.',\n  /* . */\n  CHAR_DOUBLE_QUOTE: '\"',\n  /* \" */\n  CHAR_EQUAL: '=',\n  /* = */\n  CHAR_EXCLAMATION_MARK: '!',\n  /* ! */\n  CHAR_FORM_FEED: '\\f',\n  /* \\f */\n  CHAR_FORWARD_SLASH: '/',\n  /* / */\n  CHAR_HASH: '#',\n  /* # */\n  CHAR_HYPHEN_MINUS: '-',\n  /* - */\n  CHAR_LEFT_ANGLE_BRACKET: '<',\n  /* < */\n  CHAR_LEFT_CURLY_BRACE: '{',\n  /* { */\n  CHAR_LEFT_SQUARE_BRACKET: '[',\n  /* [ */\n  CHAR_LINE_FEED: '\\n',\n  /* \\n */\n  CHAR_NO_BREAK_SPACE: '\\u00A0',\n  /* \\u00A0 */\n  CHAR_PERCENT: '%',\n  /* % */\n  CHAR_PLUS: '+',\n  /* + */\n  CHAR_QUESTION_MARK: '?',\n  /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: '>',\n  /* > */\n  CHAR_RIGHT_CURLY_BRACE: '}',\n  /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: ']',\n  /* ] */\n  CHAR_SEMICOLON: ';',\n  /* ; */\n  CHAR_SINGLE_QUOTE: '\\'',\n  /* ' */\n  CHAR_SPACE: ' ',\n  /*   */\n  CHAR_TAB: '\\t',\n  /* \\t */\n  CHAR_UNDERSCORE: '_',\n  /* _ */\n  CHAR_VERTICAL_LINE: '|',\n  /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF' /* \\uFEFF */\n};\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\micromatch\\node_modules\\braces\\lib\\constants.js");

/***/ }),

/***/ "./node_modules/micromatch/node_modules/braces/lib/expand.js":
/*!*******************************************************************!*\
  !*** ./node_modules/micromatch/node_modules/braces/lib/expand.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nconst fill = __webpack_require__(/*! fill-range */ \"./node_modules/micromatch/node_modules/fill-range/index.js\");\nconst stringify = __webpack_require__(/*! ./stringify */ \"./node_modules/micromatch/node_modules/braces/lib/stringify.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/micromatch/node_modules/braces/lib/utils.js\");\nconst append = (queue = '', stash = '', enclose = false) => {\n  let result = [];\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n  if (!stash.length) return queue;\n  if (!queue.length) {\n    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n  }\n  var _iterator = _createForOfIteratorHelper(queue),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      let item = _step.value;\n      if (Array.isArray(item)) {\n        var _iterator2 = _createForOfIteratorHelper(item),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            let value = _step2.value;\n            result.push(append(value, stash, enclose));\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      } else {\n        var _iterator3 = _createForOfIteratorHelper(stash),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            let ele = _step3.value;\n            if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return utils.flatten(result);\n};\nconst expand = (ast, options = {}) => {\n  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\n  let walk = (node, parent = {}) => {\n    node.queue = [];\n    let p = parent;\n    let q = parent.queue;\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify(node, options)));\n      return;\n    }\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n      let range = fill(...args, options);\n      if (range.length === 0) {\n        range = stringify(node, options);\n      }\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n    let enclose = utils.encloseBrace(node);\n    let queue = node.queue;\n    let block = node;\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i];\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n    return queue;\n  };\n  return utils.flatten(walk(ast));\n};\nmodule.exports = expand;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\micromatch\\node_modules\\braces\\lib\\expand.js");

/***/ }),

/***/ "./node_modules/micromatch/node_modules/braces/lib/parse.js":
/*!******************************************************************!*\
  !*** ./node_modules/micromatch/node_modules/braces/lib/parse.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst stringify = __webpack_require__(/*! ./stringify */ \"./node_modules/micromatch/node_modules/braces/lib/stringify.js\");\n\n/**\n * Constants\n */\n\nconst _require = __webpack_require__(/*! ./constants */ \"./node_modules/micromatch/node_modules/braces/lib/constants.js\"),\n  MAX_LENGTH = _require.MAX_LENGTH,\n  CHAR_BACKSLASH = _require.CHAR_BACKSLASH,\n  CHAR_BACKTICK = _require.CHAR_BACKTICK,\n  CHAR_COMMA = _require.CHAR_COMMA,\n  CHAR_DOT = _require.CHAR_DOT,\n  CHAR_LEFT_PARENTHESES = _require.CHAR_LEFT_PARENTHESES,\n  CHAR_RIGHT_PARENTHESES = _require.CHAR_RIGHT_PARENTHESES,\n  CHAR_LEFT_CURLY_BRACE = _require.CHAR_LEFT_CURLY_BRACE,\n  CHAR_RIGHT_CURLY_BRACE = _require.CHAR_RIGHT_CURLY_BRACE,\n  CHAR_LEFT_SQUARE_BRACKET = _require.CHAR_LEFT_SQUARE_BRACKET,\n  CHAR_RIGHT_SQUARE_BRACKET = _require.CHAR_RIGHT_SQUARE_BRACKET,\n  CHAR_DOUBLE_QUOTE = _require.CHAR_DOUBLE_QUOTE,\n  CHAR_SINGLE_QUOTE = _require.CHAR_SINGLE_QUOTE,\n  CHAR_NO_BREAK_SPACE = _require.CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE = _require.CHAR_ZERO_WIDTH_NOBREAK_SPACE;\n\n/**\n * parse\n */\n\nconst parse = (input, options = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n  let opts = options || {};\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  if (input.length > max) {\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n  }\n  let ast = {\n    type: 'root',\n    input,\n    nodes: []\n  };\n  let stack = [ast];\n  let block = ast;\n  let prev = ast;\n  let brackets = 0;\n  let length = input.length;\n  let index = 0;\n  let depth = 0;\n  let value;\n  let memo = {};\n\n  /**\n   * Helpers\n   */\n\n  const advance = () => input[index++];\n  const push = node => {\n    if (node.type === 'text' && prev.type === 'dot') {\n      prev.type = 'text';\n    }\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n    block.nodes.push(node);\n    node.parent = block;\n    node.prev = prev;\n    prev = node;\n    return node;\n  };\n  push({\n    type: 'bos'\n  });\n  while (index < length) {\n    block = stack[stack.length - 1];\n    value = advance();\n\n    /**\n     * Invalid chars\n     */\n\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n      continue;\n    }\n\n    /**\n     * Escaped chars\n     */\n\n    if (value === CHAR_BACKSLASH) {\n      push({\n        type: 'text',\n        value: (options.keepEscaping ? value : '') + advance()\n      });\n      continue;\n    }\n\n    /**\n     * Right square bracket (literal): ']'\n     */\n\n    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n      push({\n        type: 'text',\n        value: '\\\\' + value\n      });\n      continue;\n    }\n\n    /**\n     * Left square bracket: '['\n     */\n\n    if (value === CHAR_LEFT_SQUARE_BRACKET) {\n      brackets++;\n      let closed = true;\n      let next;\n      while (index < length && (next = advance())) {\n        value += next;\n        if (next === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          continue;\n        }\n        if (next === CHAR_BACKSLASH) {\n          value += advance();\n          continue;\n        }\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          brackets--;\n          if (brackets === 0) {\n            break;\n          }\n        }\n      }\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === CHAR_LEFT_PARENTHESES) {\n      block = push({\n        type: 'paren',\n        nodes: []\n      });\n      stack.push(block);\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    if (value === CHAR_RIGHT_PARENTHESES) {\n      if (block.type !== 'paren') {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n      block = stack.pop();\n      push({\n        type: 'text',\n        value\n      });\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Quotes: '|\"|`\n     */\n\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n      let open = value;\n      let next;\n      if (options.keepQuotes !== true) {\n        value = '';\n      }\n      while (index < length && (next = advance())) {\n        if (next === CHAR_BACKSLASH) {\n          value += next + advance();\n          continue;\n        }\n        if (next === open) {\n          if (options.keepQuotes === true) value += next;\n          break;\n        }\n        value += next;\n      }\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n\n    /**\n     * Left curly brace: '{'\n     */\n\n    if (value === CHAR_LEFT_CURLY_BRACE) {\n      depth++;\n      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n      let brace = {\n        type: 'brace',\n        open: true,\n        close: false,\n        dollar,\n        depth,\n        commas: 0,\n        ranges: 0,\n        nodes: []\n      };\n      block = push(brace);\n      stack.push(block);\n      push({\n        type: 'open',\n        value\n      });\n      continue;\n    }\n\n    /**\n     * Right curly brace: '}'\n     */\n\n    if (value === CHAR_RIGHT_CURLY_BRACE) {\n      if (block.type !== 'brace') {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n      let type = 'close';\n      block = stack.pop();\n      block.close = true;\n      push({\n        type,\n        value\n      });\n      depth--;\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Comma: ','\n     */\n\n    if (value === CHAR_COMMA && depth > 0) {\n      if (block.ranges > 0) {\n        block.ranges = 0;\n        let open = block.nodes.shift();\n        block.nodes = [open, {\n          type: 'text',\n          value: stringify(block)\n        }];\n      }\n      push({\n        type: 'comma',\n        value\n      });\n      block.commas++;\n      continue;\n    }\n\n    /**\n     * Dot: '.'\n     */\n\n    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n      let siblings = block.nodes;\n      if (depth === 0 || siblings.length === 0) {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n      if (prev.type === 'dot') {\n        block.range = [];\n        prev.value += value;\n        prev.type = 'range';\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n          block.invalid = true;\n          block.ranges = 0;\n          prev.type = 'text';\n          continue;\n        }\n        block.ranges++;\n        block.args = [];\n        continue;\n      }\n      if (prev.type === 'range') {\n        siblings.pop();\n        let before = siblings[siblings.length - 1];\n        before.value += prev.value + value;\n        prev = before;\n        block.ranges--;\n        continue;\n      }\n      push({\n        type: 'dot',\n        value\n      });\n      continue;\n    }\n\n    /**\n     * Text\n     */\n\n    push({\n      type: 'text',\n      value\n    });\n  }\n\n  // Mark imbalanced braces and brackets as invalid\n  do {\n    block = stack.pop();\n    if (block.type !== 'root') {\n      block.nodes.forEach(node => {\n        if (!node.nodes) {\n          if (node.type === 'open') node.isOpen = true;\n          if (node.type === 'close') node.isClose = true;\n          if (!node.nodes) node.type = 'text';\n          node.invalid = true;\n        }\n      });\n\n      // get the location of the block on parent.nodes (block's siblings)\n      let parent = stack[stack.length - 1];\n      let index = parent.nodes.indexOf(block);\n      // replace the (invalid) block with it's nodes\n      parent.nodes.splice(index, 1, ...block.nodes);\n    }\n  } while (stack.length > 0);\n  push({\n    type: 'eos'\n  });\n  return ast;\n};\nmodule.exports = parse;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\micromatch\\node_modules\\braces\\lib\\parse.js");

/***/ }),

/***/ "./node_modules/micromatch/node_modules/braces/lib/stringify.js":
/*!**********************************************************************!*\
  !*** ./node_modules/micromatch/node_modules/braces/lib/stringify.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/micromatch/node_modules/braces/lib/utils.js\");\nmodule.exports = (ast, options = {}) => {\n  let stringify = (node, parent = {}) => {\n    let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let output = '';\n    if (node.value) {\n      if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {\n        return '\\\\' + node.value;\n      }\n      return node.value;\n    }\n    if (node.value) {\n      return node.value;\n    }\n    if (node.nodes) {\n      var _iterator = _createForOfIteratorHelper(node.nodes),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          let child = _step.value;\n          output += stringify(child);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    return output;\n  };\n  return stringify(ast);\n};\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\micromatch\\node_modules\\braces\\lib\\stringify.js");

/***/ }),

/***/ "./node_modules/micromatch/node_modules/braces/lib/utils.js":
/*!******************************************************************!*\
  !*** ./node_modules/micromatch/node_modules/braces/lib/utils.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.isInteger = num => {\n  if (typeof num === 'number') {\n    return Number.isInteger(num);\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isInteger(Number(num));\n  }\n  return false;\n};\n\n/**\n * Find a node of the given type\n */\n\nexports.find = (node, type) => node.nodes.find(node => node.type === type);\n\n/**\n * Find a node of the given type\n */\n\nexports.exceedsLimit = (min, max, step = 1, limit) => {\n  if (limit === false) return false;\n  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n  return (Number(max) - Number(min)) / Number(step) >= limit;\n};\n\n/**\n * Escape the given node with '\\\\' before node.value\n */\n\nexports.escapeNode = (block, n = 0, type) => {\n  let node = block.nodes[n];\n  if (!node) return;\n  if (type && node.type === type || node.type === 'open' || node.type === 'close') {\n    if (node.escaped !== true) {\n      node.value = '\\\\' + node.value;\n      node.escaped = true;\n    }\n  }\n};\n\n/**\n * Returns true if the given brace node should be enclosed in literal braces\n */\n\nexports.encloseBrace = node => {\n  if (node.type !== 'brace') return false;\n  if (node.commas >> 0 + node.ranges >> 0 === 0) {\n    node.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a brace node is invalid.\n */\n\nexports.isInvalidBrace = block => {\n  if (block.type !== 'brace') return false;\n  if (block.invalid === true || block.dollar) return true;\n  if (block.commas >> 0 + block.ranges >> 0 === 0) {\n    block.invalid = true;\n    return true;\n  }\n  if (block.open !== true || block.close !== true) {\n    block.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a node is an open or close node\n */\n\nexports.isOpenOrClose = node => {\n  if (node.type === 'open' || node.type === 'close') {\n    return true;\n  }\n  return node.open === true || node.close === true;\n};\n\n/**\n * Reduce an array of text nodes.\n */\n\nexports.reduce = nodes => nodes.reduce((acc, node) => {\n  if (node.type === 'text') acc.push(node.value);\n  if (node.type === 'range') node.type = 'text';\n  return acc;\n}, []);\n\n/**\n * Flatten an array\n */\n\nexports.flatten = (...args) => {\n  const result = [];\n  const flat = arr => {\n    for (let i = 0; i < arr.length; i++) {\n      let ele = arr[i];\n      Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);\n    }\n    return result;\n  };\n  flat(args);\n  return result;\n};\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\micromatch\\node_modules\\braces\\lib\\utils.js");

/***/ }),

/***/ "./node_modules/micromatch/node_modules/fill-range/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/micromatch/node_modules/fill-range/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nconst util = __webpack_require__(/*! util */ \"util\");\nconst toRegexRange = __webpack_require__(/*! to-regex-range */ \"./node_modules/micromatch/node_modules/to-regex-range/index.js\");\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\nconst transform = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\nconst isValidValue = value => {\n  return typeof value === 'number' || typeof value === 'string' && value !== '';\n};\nconst isNumber = num => Number.isInteger(+num);\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n  while (value[++index] === '0');\n  return index > 0;\n};\nconst stringify = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n  return options.stringify === true;\n};\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = dash + input.padStart(dash ? maxLength - 1 : maxLength, '0');\n  }\n  if (toNumber === false) {\n    return String(input);\n  }\n  return input;\n};\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n  while (input.length < maxLength) input = '0' + input;\n  return negative ? '-' + input : input;\n};\nconst toSequence = (parts, options) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n  if (parts.positives.length) {\n    positives = parts.positives.join('|');\n  }\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.join('|')})`;\n  }\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n  return result;\n};\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange(a, b, _objectSpread({\n      wrap: false\n    }, options));\n  }\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n  return toRegexRange(start, end, options);\n};\nconst rangeError = (...args) => {\n  return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n};\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n  return [];\n};\nconst fillNumbers = (start, end, step = 1, options = {}) => {\n  let a = Number(start);\n  let b = Number(end);\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  }\n\n  // fix negative zero\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify(start, end, options) === false;\n  let format = options.transform || transform(toNumber);\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n  let parts = {\n    negatives: [],\n    positives: []\n  };\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n  let range = [];\n  let index = 0;\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n    a = descending ? a - step : a + step;\n    index++;\n  }\n  if (options.toRegex === true) {\n    return step > 1 ? toSequence(parts, options) : toRegex(range, null, _objectSpread({\n      wrap: false\n    }, options));\n  }\n  return range;\n};\nconst fillLetters = (start, end, step = 1, options = {}) => {\n  if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {\n    return invalidRange(start, end, options);\n  }\n  let format = options.transform || (val => String.fromCharCode(val));\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n  let range = [];\n  let index = 0;\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n  if (options.toRegex === true) {\n    return toRegex(range, null, {\n      wrap: false,\n      options\n    });\n  }\n  return range;\n};\nconst fill = (start, end, step, options = {}) => {\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n  if (typeof step === 'function') {\n    return fill(start, end, 1, {\n      transform: step\n    });\n  }\n  if (isObject(step)) {\n    return fill(start, end, 0, step);\n  }\n  let opts = _objectSpread({}, options);\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n  if (!isNumber(step)) {\n    if (step != null && !isObject(step)) return invalidStep(step, opts);\n    return fill(start, end, 1, step);\n  }\n  if (isNumber(start) && isNumber(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\nmodule.exports = fill;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\micromatch\\node_modules\\fill-range\\index.js");

/***/ }),

/***/ "./node_modules/micromatch/node_modules/is-number/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/micromatch/node_modules/is-number/index.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nmodule.exports = function (num) {\n  if (typeof num === 'number') {\n    return num - num === 0;\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n  }\n  return false;\n};\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\micromatch\\node_modules\\is-number\\index.js");

/***/ }),

/***/ "./node_modules/micromatch/node_modules/to-regex-range/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/micromatch/node_modules/to-regex-range/index.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nconst isNumber = __webpack_require__(/*! is-number */ \"./node_modules/micromatch/node_modules/is-number/index.js\");\nconst toRegexRange = (min, max, options) => {\n  if (isNumber(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n  if (isNumber(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n  let opts = _objectSpread({\n    relaxZeros: true\n  }, options);\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange.cache[cacheKey].result;\n  }\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n    if (opts.capture) {\n      return `(${result})`;\n    }\n    if (opts.wrap === false) {\n      return result;\n    }\n    return `(?:${result})`;\n  }\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = {\n    min,\n    max,\n    a,\n    b\n  };\n  let positives = [];\n  let negatives = [];\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives, opts);\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && positives.length + negatives.length > 1) {\n    state.result = `(?:${state.result})`;\n  }\n  toRegexRange.cache[cacheKey] = state;\n  return state.result;\n};\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true, options) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n  stop = countZeros(max + 1, zeros) - 1;\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return {\n      pattern: start,\n      count: [],\n      digits: 0\n    };\n  }\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n  for (let i = 0; i < digits; i++) {\n    let _zipped$i = _slicedToArray(zipped[i], 2),\n      startDigit = _zipped$i[0],\n      stopDigit = _zipped$i[1];\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit, options);\n    } else {\n      count++;\n    }\n  }\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n  return {\n    pattern,\n    count: [count],\n    digits\n  };\n}\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n  return tokens;\n}\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n  var _iterator = _createForOfIteratorHelper(arr),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      let ele = _step.value;\n      let string = ele.string;\n\n      // only push if _both_ are negative...\n      if (!intersection && !contains(comparison, 'string', string)) {\n        result.push(prefix + string);\n      }\n\n      // or _both_ are positive\n      if (intersection && contains(comparison, 'string', string)) {\n        result.push(prefix + string);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return result;\n}\n\n/**\n * Zip strings\n */\n\nfunction zip(a, b) {\n  let arr = [];\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n  return arr;\n}\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\nfunction countZeros(integer, zeros) {\n  return integer - integer % Math.pow(10, zeros);\n}\nfunction toQuantifier(digits) {\n  let _digits = _slicedToArray(digits, 2),\n    _digits$ = _digits[0],\n    start = _digits$ === void 0 ? 0 : _digits$,\n    _digits$2 = _digits[1],\n    stop = _digits$2 === void 0 ? '' : _digits$2;\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n  return '';\n}\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${b - a === 1 ? '' : '-'}${b}]`;\n}\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n  switch (diff) {\n    case 0:\n      return '';\n    case 1:\n      return relax ? '0?' : '0';\n    case 2:\n      return relax ? '0{0,2}' : '00';\n    default:\n      {\n        return relax ? `0{0,${diff}}` : `0{${diff}}`;\n      }\n  }\n}\n\n/**\n * Cache\n */\n\ntoRegexRange.cache = {};\ntoRegexRange.clearCache = () => toRegexRange.cache = {};\n\n/**\n * Expose `toRegexRange`\n */\n\nmodule.exports = toRegexRange;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\micromatch\\node_modules\\to-regex-range\\index.js");

/***/ }),

/***/ "./node_modules/moment/moment.js":
/*!***************************************!*\
  !*** ./node_modules/moment/moment.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\n\n//! moment.js\n//! version : 2.29.4\n//! authors : Tim Wood, Iskren Chernev, Moment.js contributors\n//! license : MIT\n//! momentjs.com\n\n;\n(function (global, factory) {\n   true ? module.exports = factory() : 0;\n})(void 0, function () {\n  'use strict';\n\n  var hookCallback;\n  function hooks() {\n    return hookCallback.apply(null, arguments);\n  }\n\n  // This is done to register the method called with moment()\n  // without creating circular dependencies.\n  function setHookCallback(callback) {\n    hookCallback = callback;\n  }\n  function isArray(input) {\n    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';\n  }\n  function isObject(input) {\n    // IE8 will treat undefined and null as object if it wasn't for\n    // input != null\n    return input != null && Object.prototype.toString.call(input) === '[object Object]';\n  }\n  function hasOwnProp(a, b) {\n    return Object.prototype.hasOwnProperty.call(a, b);\n  }\n  function isObjectEmpty(obj) {\n    if (Object.getOwnPropertyNames) {\n      return Object.getOwnPropertyNames(obj).length === 0;\n    } else {\n      var k;\n      for (k in obj) {\n        if (hasOwnProp(obj, k)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n  function isUndefined(input) {\n    return input === void 0;\n  }\n  function isNumber(input) {\n    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';\n  }\n  function isDate(input) {\n    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';\n  }\n  function map(arr, fn) {\n    var res = [],\n      i,\n      arrLen = arr.length;\n    for (i = 0; i < arrLen; ++i) {\n      res.push(fn(arr[i], i));\n    }\n    return res;\n  }\n  function extend(a, b) {\n    for (var i in b) {\n      if (hasOwnProp(b, i)) {\n        a[i] = b[i];\n      }\n    }\n    if (hasOwnProp(b, 'toString')) {\n      a.toString = b.toString;\n    }\n    if (hasOwnProp(b, 'valueOf')) {\n      a.valueOf = b.valueOf;\n    }\n    return a;\n  }\n  function createUTC(input, format, locale, strict) {\n    return createLocalOrUTC(input, format, locale, strict, true).utc();\n  }\n  function defaultParsingFlags() {\n    // We need to deep clone this object.\n    return {\n      empty: false,\n      unusedTokens: [],\n      unusedInput: [],\n      overflow: -2,\n      charsLeftOver: 0,\n      nullInput: false,\n      invalidEra: null,\n      invalidMonth: null,\n      invalidFormat: false,\n      userInvalidated: false,\n      iso: false,\n      parsedDateParts: [],\n      era: null,\n      meridiem: null,\n      rfc2822: false,\n      weekdayMismatch: false\n    };\n  }\n  function getParsingFlags(m) {\n    if (m._pf == null) {\n      m._pf = defaultParsingFlags();\n    }\n    return m._pf;\n  }\n  var some;\n  if (Array.prototype.some) {\n    some = Array.prototype.some;\n  } else {\n    some = function some(fun) {\n      var t = Object(this),\n        len = t.length >>> 0,\n        i;\n      for (i = 0; i < len; i++) {\n        if (i in t && fun.call(this, t[i], i, t)) {\n          return true;\n        }\n      }\n      return false;\n    };\n  }\n  function isValid(m) {\n    if (m._isValid == null) {\n      var flags = getParsingFlags(m),\n        parsedParts = some.call(flags.parsedDateParts, function (i) {\n          return i != null;\n        }),\n        isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);\n      if (m._strict) {\n        isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;\n      }\n      if (Object.isFrozen == null || !Object.isFrozen(m)) {\n        m._isValid = isNowValid;\n      } else {\n        return isNowValid;\n      }\n    }\n    return m._isValid;\n  }\n  function createInvalid(flags) {\n    var m = createUTC(NaN);\n    if (flags != null) {\n      extend(getParsingFlags(m), flags);\n    } else {\n      getParsingFlags(m).userInvalidated = true;\n    }\n    return m;\n  }\n\n  // Plugins that add properties should also add the key here (null value),\n  // so we can properly clone ourselves.\n  var momentProperties = hooks.momentProperties = [],\n    updateInProgress = false;\n  function copyConfig(to, from) {\n    var i,\n      prop,\n      val,\n      momentPropertiesLen = momentProperties.length;\n    if (!isUndefined(from._isAMomentObject)) {\n      to._isAMomentObject = from._isAMomentObject;\n    }\n    if (!isUndefined(from._i)) {\n      to._i = from._i;\n    }\n    if (!isUndefined(from._f)) {\n      to._f = from._f;\n    }\n    if (!isUndefined(from._l)) {\n      to._l = from._l;\n    }\n    if (!isUndefined(from._strict)) {\n      to._strict = from._strict;\n    }\n    if (!isUndefined(from._tzm)) {\n      to._tzm = from._tzm;\n    }\n    if (!isUndefined(from._isUTC)) {\n      to._isUTC = from._isUTC;\n    }\n    if (!isUndefined(from._offset)) {\n      to._offset = from._offset;\n    }\n    if (!isUndefined(from._pf)) {\n      to._pf = getParsingFlags(from);\n    }\n    if (!isUndefined(from._locale)) {\n      to._locale = from._locale;\n    }\n    if (momentPropertiesLen > 0) {\n      for (i = 0; i < momentPropertiesLen; i++) {\n        prop = momentProperties[i];\n        val = from[prop];\n        if (!isUndefined(val)) {\n          to[prop] = val;\n        }\n      }\n    }\n    return to;\n  }\n\n  // Moment prototype object\n  function Moment(config) {\n    copyConfig(this, config);\n    this._d = new Date(config._d != null ? config._d.getTime() : NaN);\n    if (!this.isValid()) {\n      this._d = new Date(NaN);\n    }\n    // Prevent infinite loop in case updateOffset creates new moment\n    // objects.\n    if (updateInProgress === false) {\n      updateInProgress = true;\n      hooks.updateOffset(this);\n      updateInProgress = false;\n    }\n  }\n  function isMoment(obj) {\n    return obj instanceof Moment || obj != null && obj._isAMomentObject != null;\n  }\n  function warn(msg) {\n    if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {\n      console.warn('Deprecation warning: ' + msg);\n    }\n  }\n  function deprecate(msg, fn) {\n    var firstTime = true;\n    return extend(function () {\n      if (hooks.deprecationHandler != null) {\n        hooks.deprecationHandler(null, msg);\n      }\n      if (firstTime) {\n        var args = [],\n          arg,\n          i,\n          key,\n          argLen = arguments.length;\n        for (i = 0; i < argLen; i++) {\n          arg = '';\n          if (typeof arguments[i] === 'object') {\n            arg += '\\n[' + i + '] ';\n            for (key in arguments[0]) {\n              if (hasOwnProp(arguments[0], key)) {\n                arg += key + ': ' + arguments[0][key] + ', ';\n              }\n            }\n            arg = arg.slice(0, -2); // Remove trailing comma and space\n          } else {\n            arg = arguments[i];\n          }\n          args.push(arg);\n        }\n        warn(msg + '\\nArguments: ' + Array.prototype.slice.call(args).join('') + '\\n' + new Error().stack);\n        firstTime = false;\n      }\n      return fn.apply(this, arguments);\n    }, fn);\n  }\n  var deprecations = {};\n  function deprecateSimple(name, msg) {\n    if (hooks.deprecationHandler != null) {\n      hooks.deprecationHandler(name, msg);\n    }\n    if (!deprecations[name]) {\n      warn(msg);\n      deprecations[name] = true;\n    }\n  }\n  hooks.suppressDeprecationWarnings = false;\n  hooks.deprecationHandler = null;\n  function isFunction(input) {\n    return typeof Function !== 'undefined' && input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';\n  }\n  function set(config) {\n    var prop, i;\n    for (i in config) {\n      if (hasOwnProp(config, i)) {\n        prop = config[i];\n        if (isFunction(prop)) {\n          this[i] = prop;\n        } else {\n          this['_' + i] = prop;\n        }\n      }\n    }\n    this._config = config;\n    // Lenient ordinal parsing accepts just a number in addition to\n    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.\n    // TODO: Remove \"ordinalParse\" fallback in next major release.\n    this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\\d{1,2}/.source);\n  }\n  function mergeConfigs(parentConfig, childConfig) {\n    var res = extend({}, parentConfig),\n      prop;\n    for (prop in childConfig) {\n      if (hasOwnProp(childConfig, prop)) {\n        if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {\n          res[prop] = {};\n          extend(res[prop], parentConfig[prop]);\n          extend(res[prop], childConfig[prop]);\n        } else if (childConfig[prop] != null) {\n          res[prop] = childConfig[prop];\n        } else {\n          delete res[prop];\n        }\n      }\n    }\n    for (prop in parentConfig) {\n      if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {\n        // make sure changes to properties don't modify parent config\n        res[prop] = extend({}, res[prop]);\n      }\n    }\n    return res;\n  }\n  function Locale(config) {\n    if (config != null) {\n      this.set(config);\n    }\n  }\n  var keys;\n  if (Object.keys) {\n    keys = Object.keys;\n  } else {\n    keys = function keys(obj) {\n      var i,\n        res = [];\n      for (i in obj) {\n        if (hasOwnProp(obj, i)) {\n          res.push(i);\n        }\n      }\n      return res;\n    };\n  }\n  var defaultCalendar = {\n    sameDay: '[Today at] LT',\n    nextDay: '[Tomorrow at] LT',\n    nextWeek: 'dddd [at] LT',\n    lastDay: '[Yesterday at] LT',\n    lastWeek: '[Last] dddd [at] LT',\n    sameElse: 'L'\n  };\n  function calendar(key, mom, now) {\n    var output = this._calendar[key] || this._calendar['sameElse'];\n    return isFunction(output) ? output.call(mom, now) : output;\n  }\n  function zeroFill(number, targetLength, forceSign) {\n    var absNumber = '' + Math.abs(number),\n      zerosToFill = targetLength - absNumber.length,\n      sign = number >= 0;\n    return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;\n  }\n  var formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,\n    localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g,\n    formatFunctions = {},\n    formatTokenFunctions = {};\n\n  // token:    'M'\n  // padded:   ['MM', 2]\n  // ordinal:  'Mo'\n  // callback: function () { this.month() + 1 }\n  function addFormatToken(token, padded, ordinal, callback) {\n    var func = callback;\n    if (typeof callback === 'string') {\n      func = function func() {\n        return this[callback]();\n      };\n    }\n    if (token) {\n      formatTokenFunctions[token] = func;\n    }\n    if (padded) {\n      formatTokenFunctions[padded[0]] = function () {\n        return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\n      };\n    }\n    if (ordinal) {\n      formatTokenFunctions[ordinal] = function () {\n        return this.localeData().ordinal(func.apply(this, arguments), token);\n      };\n    }\n  }\n  function removeFormattingTokens(input) {\n    if (input.match(/\\[[\\s\\S]/)) {\n      return input.replace(/^\\[|\\]$/g, '');\n    }\n    return input.replace(/\\\\/g, '');\n  }\n  function makeFormatFunction(format) {\n    var array = format.match(formattingTokens),\n      i,\n      length;\n    for (i = 0, length = array.length; i < length; i++) {\n      if (formatTokenFunctions[array[i]]) {\n        array[i] = formatTokenFunctions[array[i]];\n      } else {\n        array[i] = removeFormattingTokens(array[i]);\n      }\n    }\n    return function (mom) {\n      var output = '',\n        i;\n      for (i = 0; i < length; i++) {\n        output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];\n      }\n      return output;\n    };\n  }\n\n  // format date using native date object\n  function formatMoment(m, format) {\n    if (!m.isValid()) {\n      return m.localeData().invalidDate();\n    }\n    format = expandFormat(format, m.localeData());\n    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);\n    return formatFunctions[format](m);\n  }\n  function expandFormat(format, locale) {\n    var i = 5;\n    function replaceLongDateFormatTokens(input) {\n      return locale.longDateFormat(input) || input;\n    }\n    localFormattingTokens.lastIndex = 0;\n    while (i >= 0 && localFormattingTokens.test(format)) {\n      format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\n      localFormattingTokens.lastIndex = 0;\n      i -= 1;\n    }\n    return format;\n  }\n  var defaultLongDateFormat = {\n    LTS: 'h:mm:ss A',\n    LT: 'h:mm A',\n    L: 'MM/DD/YYYY',\n    LL: 'MMMM D, YYYY',\n    LLL: 'MMMM D, YYYY h:mm A',\n    LLLL: 'dddd, MMMM D, YYYY h:mm A'\n  };\n  function longDateFormat(key) {\n    var format = this._longDateFormat[key],\n      formatUpper = this._longDateFormat[key.toUpperCase()];\n    if (format || !formatUpper) {\n      return format;\n    }\n    this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function (tok) {\n      if (tok === 'MMMM' || tok === 'MM' || tok === 'DD' || tok === 'dddd') {\n        return tok.slice(1);\n      }\n      return tok;\n    }).join('');\n    return this._longDateFormat[key];\n  }\n  var defaultInvalidDate = 'Invalid date';\n  function invalidDate() {\n    return this._invalidDate;\n  }\n  var defaultOrdinal = '%d',\n    defaultDayOfMonthOrdinalParse = /\\d{1,2}/;\n  function ordinal(number) {\n    return this._ordinal.replace('%d', number);\n  }\n  var defaultRelativeTime = {\n    future: 'in %s',\n    past: '%s ago',\n    s: 'a few seconds',\n    ss: '%d seconds',\n    m: 'a minute',\n    mm: '%d minutes',\n    h: 'an hour',\n    hh: '%d hours',\n    d: 'a day',\n    dd: '%d days',\n    w: 'a week',\n    ww: '%d weeks',\n    M: 'a month',\n    MM: '%d months',\n    y: 'a year',\n    yy: '%d years'\n  };\n  function relativeTime(number, withoutSuffix, string, isFuture) {\n    var output = this._relativeTime[string];\n    return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);\n  }\n  function pastFuture(diff, output) {\n    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\n    return isFunction(format) ? format(output) : format.replace(/%s/i, output);\n  }\n  var aliases = {};\n  function addUnitAlias(unit, shorthand) {\n    var lowerCase = unit.toLowerCase();\n    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;\n  }\n  function normalizeUnits(units) {\n    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;\n  }\n  function normalizeObjectUnits(inputObject) {\n    var normalizedInput = {},\n      normalizedProp,\n      prop;\n    for (prop in inputObject) {\n      if (hasOwnProp(inputObject, prop)) {\n        normalizedProp = normalizeUnits(prop);\n        if (normalizedProp) {\n          normalizedInput[normalizedProp] = inputObject[prop];\n        }\n      }\n    }\n    return normalizedInput;\n  }\n  var priorities = {};\n  function addUnitPriority(unit, priority) {\n    priorities[unit] = priority;\n  }\n  function getPrioritizedUnits(unitsObj) {\n    var units = [],\n      u;\n    for (u in unitsObj) {\n      if (hasOwnProp(unitsObj, u)) {\n        units.push({\n          unit: u,\n          priority: priorities[u]\n        });\n      }\n    }\n    units.sort(function (a, b) {\n      return a.priority - b.priority;\n    });\n    return units;\n  }\n  function isLeapYear(year) {\n    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n  }\n  function absFloor(number) {\n    if (number < 0) {\n      // -0 -> 0\n      return Math.ceil(number) || 0;\n    } else {\n      return Math.floor(number);\n    }\n  }\n  function toInt(argumentForCoercion) {\n    var coercedNumber = +argumentForCoercion,\n      value = 0;\n    if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n      value = absFloor(coercedNumber);\n    }\n    return value;\n  }\n  function makeGetSet(unit, keepTime) {\n    return function (value) {\n      if (value != null) {\n        set$1(this, unit, value);\n        hooks.updateOffset(this, keepTime);\n        return this;\n      } else {\n        return get(this, unit);\n      }\n    };\n  }\n  function get(mom, unit) {\n    return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;\n  }\n  function set$1(mom, unit, value) {\n    if (mom.isValid() && !isNaN(value)) {\n      if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {\n        value = toInt(value);\n        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));\n      } else {\n        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);\n      }\n    }\n  }\n\n  // MOMENTS\n\n  function stringGet(units) {\n    units = normalizeUnits(units);\n    if (isFunction(this[units])) {\n      return this[units]();\n    }\n    return this;\n  }\n  function stringSet(units, value) {\n    if (typeof units === 'object') {\n      units = normalizeObjectUnits(units);\n      var prioritized = getPrioritizedUnits(units),\n        i,\n        prioritizedLen = prioritized.length;\n      for (i = 0; i < prioritizedLen; i++) {\n        this[prioritized[i].unit](units[prioritized[i].unit]);\n      }\n    } else {\n      units = normalizeUnits(units);\n      if (isFunction(this[units])) {\n        return this[units](value);\n      }\n    }\n    return this;\n  }\n  var match1 = /\\d/,\n    //       0 - 9\n    match2 = /\\d\\d/,\n    //      00 - 99\n    match3 = /\\d{3}/,\n    //     000 - 999\n    match4 = /\\d{4}/,\n    //    0000 - 9999\n    match6 = /[+-]?\\d{6}/,\n    // -999999 - 999999\n    match1to2 = /\\d\\d?/,\n    //       0 - 99\n    match3to4 = /\\d\\d\\d\\d?/,\n    //     999 - 9999\n    match5to6 = /\\d\\d\\d\\d\\d\\d?/,\n    //   99999 - 999999\n    match1to3 = /\\d{1,3}/,\n    //       0 - 999\n    match1to4 = /\\d{1,4}/,\n    //       0 - 9999\n    match1to6 = /[+-]?\\d{1,6}/,\n    // -999999 - 999999\n    matchUnsigned = /\\d+/,\n    //       0 - inf\n    matchSigned = /[+-]?\\d+/,\n    //    -inf - inf\n    matchOffset = /Z|[+-]\\d\\d:?\\d\\d/gi,\n    // +00:00 -00:00 +0000 -0000 or Z\n    matchShortOffset = /Z|[+-]\\d\\d(?::?\\d\\d)?/gi,\n    // +00 -00 +00:00 -00:00 +0000 -0000 or Z\n    matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/,\n    // 123456789 123456789.123\n    // any word (or two) characters or numbers including two/three word month in arabic.\n    // includes scottish gaelic two word and hyphenated months\n    matchWord = /[0-9]{0,256}['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFF07\\uFF10-\\uFFEF]{1,256}|[\\u0600-\\u06FF\\/]{1,256}(\\s*?[\\u0600-\\u06FF]{1,256}){1,2}/i,\n    regexes;\n  regexes = {};\n  function addRegexToken(token, regex, strictRegex) {\n    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {\n      return isStrict && strictRegex ? strictRegex : regex;\n    };\n  }\n  function getParseRegexForToken(token, config) {\n    if (!hasOwnProp(regexes, token)) {\n      return new RegExp(unescapeFormat(token));\n    }\n    return regexes[token](config._strict, config._locale);\n  }\n\n  // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n  function unescapeFormat(s) {\n    return regexEscape(s.replace('\\\\', '').replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function (matched, p1, p2, p3, p4) {\n      return p1 || p2 || p3 || p4;\n    }));\n  }\n  function regexEscape(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n  }\n  var tokens = {};\n  function addParseToken(token, callback) {\n    var i,\n      func = callback,\n      tokenLen;\n    if (typeof token === 'string') {\n      token = [token];\n    }\n    if (isNumber(callback)) {\n      func = function func(input, array) {\n        array[callback] = toInt(input);\n      };\n    }\n    tokenLen = token.length;\n    for (i = 0; i < tokenLen; i++) {\n      tokens[token[i]] = func;\n    }\n  }\n  function addWeekParseToken(token, callback) {\n    addParseToken(token, function (input, array, config, token) {\n      config._w = config._w || {};\n      callback(input, config._w, config, token);\n    });\n  }\n  function addTimeToArrayFromToken(token, input, config) {\n    if (input != null && hasOwnProp(tokens, token)) {\n      tokens[token](input, config._a, config, token);\n    }\n  }\n  var YEAR = 0,\n    MONTH = 1,\n    DATE = 2,\n    HOUR = 3,\n    MINUTE = 4,\n    SECOND = 5,\n    MILLISECOND = 6,\n    WEEK = 7,\n    WEEKDAY = 8;\n  function mod(n, x) {\n    return (n % x + x) % x;\n  }\n  var indexOf;\n  if (Array.prototype.indexOf) {\n    indexOf = Array.prototype.indexOf;\n  } else {\n    indexOf = function indexOf(o) {\n      // I know\n      var i;\n      for (i = 0; i < this.length; ++i) {\n        if (this[i] === o) {\n          return i;\n        }\n      }\n      return -1;\n    };\n  }\n  function daysInMonth(year, month) {\n    if (isNaN(year) || isNaN(month)) {\n      return NaN;\n    }\n    var modMonth = mod(month, 12);\n    year += (month - modMonth) / 12;\n    return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;\n  }\n\n  // FORMATTING\n\n  addFormatToken('M', ['MM', 2], 'Mo', function () {\n    return this.month() + 1;\n  });\n  addFormatToken('MMM', 0, 0, function (format) {\n    return this.localeData().monthsShort(this, format);\n  });\n  addFormatToken('MMMM', 0, 0, function (format) {\n    return this.localeData().months(this, format);\n  });\n\n  // ALIASES\n\n  addUnitAlias('month', 'M');\n\n  // PRIORITY\n\n  addUnitPriority('month', 8);\n\n  // PARSING\n\n  addRegexToken('M', match1to2);\n  addRegexToken('MM', match1to2, match2);\n  addRegexToken('MMM', function (isStrict, locale) {\n    return locale.monthsShortRegex(isStrict);\n  });\n  addRegexToken('MMMM', function (isStrict, locale) {\n    return locale.monthsRegex(isStrict);\n  });\n  addParseToken(['M', 'MM'], function (input, array) {\n    array[MONTH] = toInt(input) - 1;\n  });\n  addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {\n    var month = config._locale.monthsParse(input, token, config._strict);\n    // if we didn't find a month name, mark the date as invalid.\n    if (month != null) {\n      array[MONTH] = month;\n    } else {\n      getParsingFlags(config).invalidMonth = input;\n    }\n  });\n\n  // LOCALES\n\n  var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),\n    defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),\n    MONTHS_IN_FORMAT = /D[oD]?(\\[[^\\[\\]]*\\]|\\s)+MMMM?/,\n    defaultMonthsShortRegex = matchWord,\n    defaultMonthsRegex = matchWord;\n  function localeMonths(m, format) {\n    if (!m) {\n      return isArray(this._months) ? this._months : this._months['standalone'];\n    }\n    return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];\n  }\n  function localeMonthsShort(m, format) {\n    if (!m) {\n      return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];\n    }\n    return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];\n  }\n  function handleStrictParse(monthName, format, strict) {\n    var i,\n      ii,\n      mom,\n      llc = monthName.toLocaleLowerCase();\n    if (!this._monthsParse) {\n      // this is not used\n      this._monthsParse = [];\n      this._longMonthsParse = [];\n      this._shortMonthsParse = [];\n      for (i = 0; i < 12; ++i) {\n        mom = createUTC([2000, i]);\n        this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();\n        this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();\n      }\n    }\n    if (strict) {\n      if (format === 'MMM') {\n        ii = indexOf.call(this._shortMonthsParse, llc);\n        return ii !== -1 ? ii : null;\n      } else {\n        ii = indexOf.call(this._longMonthsParse, llc);\n        return ii !== -1 ? ii : null;\n      }\n    } else {\n      if (format === 'MMM') {\n        ii = indexOf.call(this._shortMonthsParse, llc);\n        if (ii !== -1) {\n          return ii;\n        }\n        ii = indexOf.call(this._longMonthsParse, llc);\n        return ii !== -1 ? ii : null;\n      } else {\n        ii = indexOf.call(this._longMonthsParse, llc);\n        if (ii !== -1) {\n          return ii;\n        }\n        ii = indexOf.call(this._shortMonthsParse, llc);\n        return ii !== -1 ? ii : null;\n      }\n    }\n  }\n  function localeMonthsParse(monthName, format, strict) {\n    var i, mom, regex;\n    if (this._monthsParseExact) {\n      return handleStrictParse.call(this, monthName, format, strict);\n    }\n    if (!this._monthsParse) {\n      this._monthsParse = [];\n      this._longMonthsParse = [];\n      this._shortMonthsParse = [];\n    }\n\n    // TODO: add sorting\n    // Sorting makes sure if one month (or abbr) is a prefix of another\n    // see sorting in computeMonthsParse\n    for (i = 0; i < 12; i++) {\n      // make the regex if we don't have it already\n      mom = createUTC([2000, i]);\n      if (strict && !this._longMonthsParse[i]) {\n        this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');\n        this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');\n      }\n      if (!strict && !this._monthsParse[i]) {\n        regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\n        this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\n      }\n      // test the regex\n      if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {\n        return i;\n      } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {\n        return i;\n      } else if (!strict && this._monthsParse[i].test(monthName)) {\n        return i;\n      }\n    }\n  }\n\n  // MOMENTS\n\n  function setMonth(mom, value) {\n    var dayOfMonth;\n    if (!mom.isValid()) {\n      // No op\n      return mom;\n    }\n    if (typeof value === 'string') {\n      if (/^\\d+$/.test(value)) {\n        value = toInt(value);\n      } else {\n        value = mom.localeData().monthsParse(value);\n        // TODO: Another silent failure?\n        if (!isNumber(value)) {\n          return mom;\n        }\n      }\n    }\n    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\n    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);\n    return mom;\n  }\n  function getSetMonth(value) {\n    if (value != null) {\n      setMonth(this, value);\n      hooks.updateOffset(this, true);\n      return this;\n    } else {\n      return get(this, 'Month');\n    }\n  }\n  function getDaysInMonth() {\n    return daysInMonth(this.year(), this.month());\n  }\n  function monthsShortRegex(isStrict) {\n    if (this._monthsParseExact) {\n      if (!hasOwnProp(this, '_monthsRegex')) {\n        computeMonthsParse.call(this);\n      }\n      if (isStrict) {\n        return this._monthsShortStrictRegex;\n      } else {\n        return this._monthsShortRegex;\n      }\n    } else {\n      if (!hasOwnProp(this, '_monthsShortRegex')) {\n        this._monthsShortRegex = defaultMonthsShortRegex;\n      }\n      return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;\n    }\n  }\n  function monthsRegex(isStrict) {\n    if (this._monthsParseExact) {\n      if (!hasOwnProp(this, '_monthsRegex')) {\n        computeMonthsParse.call(this);\n      }\n      if (isStrict) {\n        return this._monthsStrictRegex;\n      } else {\n        return this._monthsRegex;\n      }\n    } else {\n      if (!hasOwnProp(this, '_monthsRegex')) {\n        this._monthsRegex = defaultMonthsRegex;\n      }\n      return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;\n    }\n  }\n  function computeMonthsParse() {\n    function cmpLenRev(a, b) {\n      return b.length - a.length;\n    }\n    var shortPieces = [],\n      longPieces = [],\n      mixedPieces = [],\n      i,\n      mom;\n    for (i = 0; i < 12; i++) {\n      // make the regex if we don't have it already\n      mom = createUTC([2000, i]);\n      shortPieces.push(this.monthsShort(mom, ''));\n      longPieces.push(this.months(mom, ''));\n      mixedPieces.push(this.months(mom, ''));\n      mixedPieces.push(this.monthsShort(mom, ''));\n    }\n    // Sorting makes sure if one month (or abbr) is a prefix of another it\n    // will match the longer piece.\n    shortPieces.sort(cmpLenRev);\n    longPieces.sort(cmpLenRev);\n    mixedPieces.sort(cmpLenRev);\n    for (i = 0; i < 12; i++) {\n      shortPieces[i] = regexEscape(shortPieces[i]);\n      longPieces[i] = regexEscape(longPieces[i]);\n    }\n    for (i = 0; i < 24; i++) {\n      mixedPieces[i] = regexEscape(mixedPieces[i]);\n    }\n    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n    this._monthsShortRegex = this._monthsRegex;\n    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n  }\n\n  // FORMATTING\n\n  addFormatToken('Y', 0, 0, function () {\n    var y = this.year();\n    return y <= 9999 ? zeroFill(y, 4) : '+' + y;\n  });\n  addFormatToken(0, ['YY', 2], 0, function () {\n    return this.year() % 100;\n  });\n  addFormatToken(0, ['YYYY', 4], 0, 'year');\n  addFormatToken(0, ['YYYYY', 5], 0, 'year');\n  addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');\n\n  // ALIASES\n\n  addUnitAlias('year', 'y');\n\n  // PRIORITIES\n\n  addUnitPriority('year', 1);\n\n  // PARSING\n\n  addRegexToken('Y', matchSigned);\n  addRegexToken('YY', match1to2, match2);\n  addRegexToken('YYYY', match1to4, match4);\n  addRegexToken('YYYYY', match1to6, match6);\n  addRegexToken('YYYYYY', match1to6, match6);\n  addParseToken(['YYYYY', 'YYYYYY'], YEAR);\n  addParseToken('YYYY', function (input, array) {\n    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);\n  });\n  addParseToken('YY', function (input, array) {\n    array[YEAR] = hooks.parseTwoDigitYear(input);\n  });\n  addParseToken('Y', function (input, array) {\n    array[YEAR] = parseInt(input, 10);\n  });\n\n  // HELPERS\n\n  function daysInYear(year) {\n    return isLeapYear(year) ? 366 : 365;\n  }\n\n  // HOOKS\n\n  hooks.parseTwoDigitYear = function (input) {\n    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n  };\n\n  // MOMENTS\n\n  var getSetYear = makeGetSet('FullYear', true);\n  function getIsLeapYear() {\n    return isLeapYear(this.year());\n  }\n  function createDate(y, m, d, h, M, s, ms) {\n    // can't just apply() to create a date:\n    // https://stackoverflow.com/q/181348\n    var date;\n    // the date constructor remaps years 0-99 to 1900-1999\n    if (y < 100 && y >= 0) {\n      // preserve leap years using a full 400 year cycle, then reset\n      date = new Date(y + 400, m, d, h, M, s, ms);\n      if (isFinite(date.getFullYear())) {\n        date.setFullYear(y);\n      }\n    } else {\n      date = new Date(y, m, d, h, M, s, ms);\n    }\n    return date;\n  }\n  function createUTCDate(y) {\n    var date, args;\n    // the Date.UTC function remaps years 0-99 to 1900-1999\n    if (y < 100 && y >= 0) {\n      args = Array.prototype.slice.call(arguments);\n      // preserve leap years using a full 400 year cycle, then reset\n      args[0] = y + 400;\n      date = new Date(Date.UTC.apply(null, args));\n      if (isFinite(date.getUTCFullYear())) {\n        date.setUTCFullYear(y);\n      }\n    } else {\n      date = new Date(Date.UTC.apply(null, arguments));\n    }\n    return date;\n  }\n\n  // start-of-first-week - start-of-year\n  function firstWeekOffset(year, dow, doy) {\n    var\n      // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n      fwd = 7 + dow - doy,\n      // first-week day local weekday -- which local weekday is fwd\n      fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;\n    return -fwdlw + fwd - 1;\n  }\n\n  // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\n  function dayOfYearFromWeeks(year, week, weekday, dow, doy) {\n    var localWeekday = (7 + weekday - dow) % 7,\n      weekOffset = firstWeekOffset(year, dow, doy),\n      dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,\n      resYear,\n      resDayOfYear;\n    if (dayOfYear <= 0) {\n      resYear = year - 1;\n      resDayOfYear = daysInYear(resYear) + dayOfYear;\n    } else if (dayOfYear > daysInYear(year)) {\n      resYear = year + 1;\n      resDayOfYear = dayOfYear - daysInYear(year);\n    } else {\n      resYear = year;\n      resDayOfYear = dayOfYear;\n    }\n    return {\n      year: resYear,\n      dayOfYear: resDayOfYear\n    };\n  }\n  function weekOfYear(mom, dow, doy) {\n    var weekOffset = firstWeekOffset(mom.year(), dow, doy),\n      week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,\n      resWeek,\n      resYear;\n    if (week < 1) {\n      resYear = mom.year() - 1;\n      resWeek = week + weeksInYear(resYear, dow, doy);\n    } else if (week > weeksInYear(mom.year(), dow, doy)) {\n      resWeek = week - weeksInYear(mom.year(), dow, doy);\n      resYear = mom.year() + 1;\n    } else {\n      resYear = mom.year();\n      resWeek = week;\n    }\n    return {\n      week: resWeek,\n      year: resYear\n    };\n  }\n  function weeksInYear(year, dow, doy) {\n    var weekOffset = firstWeekOffset(year, dow, doy),\n      weekOffsetNext = firstWeekOffset(year + 1, dow, doy);\n    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;\n  }\n\n  // FORMATTING\n\n  addFormatToken('w', ['ww', 2], 'wo', 'week');\n  addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');\n\n  // ALIASES\n\n  addUnitAlias('week', 'w');\n  addUnitAlias('isoWeek', 'W');\n\n  // PRIORITIES\n\n  addUnitPriority('week', 5);\n  addUnitPriority('isoWeek', 5);\n\n  // PARSING\n\n  addRegexToken('w', match1to2);\n  addRegexToken('ww', match1to2, match2);\n  addRegexToken('W', match1to2);\n  addRegexToken('WW', match1to2, match2);\n  addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {\n    week[token.substr(0, 1)] = toInt(input);\n  });\n\n  // HELPERS\n\n  // LOCALES\n\n  function localeWeek(mom) {\n    return weekOfYear(mom, this._week.dow, this._week.doy).week;\n  }\n  var defaultLocaleWeek = {\n    dow: 0,\n    // Sunday is the first day of the week.\n    doy: 6 // The week that contains Jan 6th is the first week of the year.\n  };\n\n  function localeFirstDayOfWeek() {\n    return this._week.dow;\n  }\n  function localeFirstDayOfYear() {\n    return this._week.doy;\n  }\n\n  // MOMENTS\n\n  function getSetWeek(input) {\n    var week = this.localeData().week(this);\n    return input == null ? week : this.add((input - week) * 7, 'd');\n  }\n  function getSetISOWeek(input) {\n    var week = weekOfYear(this, 1, 4).week;\n    return input == null ? week : this.add((input - week) * 7, 'd');\n  }\n\n  // FORMATTING\n\n  addFormatToken('d', 0, 'do', 'day');\n  addFormatToken('dd', 0, 0, function (format) {\n    return this.localeData().weekdaysMin(this, format);\n  });\n  addFormatToken('ddd', 0, 0, function (format) {\n    return this.localeData().weekdaysShort(this, format);\n  });\n  addFormatToken('dddd', 0, 0, function (format) {\n    return this.localeData().weekdays(this, format);\n  });\n  addFormatToken('e', 0, 0, 'weekday');\n  addFormatToken('E', 0, 0, 'isoWeekday');\n\n  // ALIASES\n\n  addUnitAlias('day', 'd');\n  addUnitAlias('weekday', 'e');\n  addUnitAlias('isoWeekday', 'E');\n\n  // PRIORITY\n  addUnitPriority('day', 11);\n  addUnitPriority('weekday', 11);\n  addUnitPriority('isoWeekday', 11);\n\n  // PARSING\n\n  addRegexToken('d', match1to2);\n  addRegexToken('e', match1to2);\n  addRegexToken('E', match1to2);\n  addRegexToken('dd', function (isStrict, locale) {\n    return locale.weekdaysMinRegex(isStrict);\n  });\n  addRegexToken('ddd', function (isStrict, locale) {\n    return locale.weekdaysShortRegex(isStrict);\n  });\n  addRegexToken('dddd', function (isStrict, locale) {\n    return locale.weekdaysRegex(isStrict);\n  });\n  addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {\n    var weekday = config._locale.weekdaysParse(input, token, config._strict);\n    // if we didn't get a weekday name, mark the date as invalid\n    if (weekday != null) {\n      week.d = weekday;\n    } else {\n      getParsingFlags(config).invalidWeekday = input;\n    }\n  });\n  addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {\n    week[token] = toInt(input);\n  });\n\n  // HELPERS\n\n  function parseWeekday(input, locale) {\n    if (typeof input !== 'string') {\n      return input;\n    }\n    if (!isNaN(input)) {\n      return parseInt(input, 10);\n    }\n    input = locale.weekdaysParse(input);\n    if (typeof input === 'number') {\n      return input;\n    }\n    return null;\n  }\n  function parseIsoWeekday(input, locale) {\n    if (typeof input === 'string') {\n      return locale.weekdaysParse(input) % 7 || 7;\n    }\n    return isNaN(input) ? null : input;\n  }\n\n  // LOCALES\n  function shiftWeekdays(ws, n) {\n    return ws.slice(n, 7).concat(ws.slice(0, n));\n  }\n  var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),\n    defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),\n    defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),\n    defaultWeekdaysRegex = matchWord,\n    defaultWeekdaysShortRegex = matchWord,\n    defaultWeekdaysMinRegex = matchWord;\n  function localeWeekdays(m, format) {\n    var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? 'format' : 'standalone'];\n    return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;\n  }\n  function localeWeekdaysShort(m) {\n    return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;\n  }\n  function localeWeekdaysMin(m) {\n    return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;\n  }\n  function handleStrictParse$1(weekdayName, format, strict) {\n    var i,\n      ii,\n      mom,\n      llc = weekdayName.toLocaleLowerCase();\n    if (!this._weekdaysParse) {\n      this._weekdaysParse = [];\n      this._shortWeekdaysParse = [];\n      this._minWeekdaysParse = [];\n      for (i = 0; i < 7; ++i) {\n        mom = createUTC([2000, 1]).day(i);\n        this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();\n        this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();\n        this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();\n      }\n    }\n    if (strict) {\n      if (format === 'dddd') {\n        ii = indexOf.call(this._weekdaysParse, llc);\n        return ii !== -1 ? ii : null;\n      } else if (format === 'ddd') {\n        ii = indexOf.call(this._shortWeekdaysParse, llc);\n        return ii !== -1 ? ii : null;\n      } else {\n        ii = indexOf.call(this._minWeekdaysParse, llc);\n        return ii !== -1 ? ii : null;\n      }\n    } else {\n      if (format === 'dddd') {\n        ii = indexOf.call(this._weekdaysParse, llc);\n        if (ii !== -1) {\n          return ii;\n        }\n        ii = indexOf.call(this._shortWeekdaysParse, llc);\n        if (ii !== -1) {\n          return ii;\n        }\n        ii = indexOf.call(this._minWeekdaysParse, llc);\n        return ii !== -1 ? ii : null;\n      } else if (format === 'ddd') {\n        ii = indexOf.call(this._shortWeekdaysParse, llc);\n        if (ii !== -1) {\n          return ii;\n        }\n        ii = indexOf.call(this._weekdaysParse, llc);\n        if (ii !== -1) {\n          return ii;\n        }\n        ii = indexOf.call(this._minWeekdaysParse, llc);\n        return ii !== -1 ? ii : null;\n      } else {\n        ii = indexOf.call(this._minWeekdaysParse, llc);\n        if (ii !== -1) {\n          return ii;\n        }\n        ii = indexOf.call(this._weekdaysParse, llc);\n        if (ii !== -1) {\n          return ii;\n        }\n        ii = indexOf.call(this._shortWeekdaysParse, llc);\n        return ii !== -1 ? ii : null;\n      }\n    }\n  }\n  function localeWeekdaysParse(weekdayName, format, strict) {\n    var i, mom, regex;\n    if (this._weekdaysParseExact) {\n      return handleStrictParse$1.call(this, weekdayName, format, strict);\n    }\n    if (!this._weekdaysParse) {\n      this._weekdaysParse = [];\n      this._minWeekdaysParse = [];\n      this._shortWeekdaysParse = [];\n      this._fullWeekdaysParse = [];\n    }\n    for (i = 0; i < 7; i++) {\n      // make the regex if we don't have it already\n\n      mom = createUTC([2000, 1]).day(i);\n      if (strict && !this._fullWeekdaysParse[i]) {\n        this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\\\.?') + '$', 'i');\n        this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\\\.?') + '$', 'i');\n        this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\\\.?') + '$', 'i');\n      }\n      if (!this._weekdaysParse[i]) {\n        regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');\n        this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');\n      }\n      // test the regex\n      if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {\n        return i;\n      } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {\n        return i;\n      } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {\n        return i;\n      } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {\n        return i;\n      }\n    }\n  }\n\n  // MOMENTS\n\n  function getSetDayOfWeek(input) {\n    if (!this.isValid()) {\n      return input != null ? this : NaN;\n    }\n    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\n    if (input != null) {\n      input = parseWeekday(input, this.localeData());\n      return this.add(input - day, 'd');\n    } else {\n      return day;\n    }\n  }\n  function getSetLocaleDayOfWeek(input) {\n    if (!this.isValid()) {\n      return input != null ? this : NaN;\n    }\n    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\n    return input == null ? weekday : this.add(input - weekday, 'd');\n  }\n  function getSetISODayOfWeek(input) {\n    if (!this.isValid()) {\n      return input != null ? this : NaN;\n    }\n\n    // behaves the same as moment#day except\n    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\n    // as a setter, sunday should belong to the previous week.\n\n    if (input != null) {\n      var weekday = parseIsoWeekday(input, this.localeData());\n      return this.day(this.day() % 7 ? weekday : weekday - 7);\n    } else {\n      return this.day() || 7;\n    }\n  }\n  function weekdaysRegex(isStrict) {\n    if (this._weekdaysParseExact) {\n      if (!hasOwnProp(this, '_weekdaysRegex')) {\n        computeWeekdaysParse.call(this);\n      }\n      if (isStrict) {\n        return this._weekdaysStrictRegex;\n      } else {\n        return this._weekdaysRegex;\n      }\n    } else {\n      if (!hasOwnProp(this, '_weekdaysRegex')) {\n        this._weekdaysRegex = defaultWeekdaysRegex;\n      }\n      return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;\n    }\n  }\n  function weekdaysShortRegex(isStrict) {\n    if (this._weekdaysParseExact) {\n      if (!hasOwnProp(this, '_weekdaysRegex')) {\n        computeWeekdaysParse.call(this);\n      }\n      if (isStrict) {\n        return this._weekdaysShortStrictRegex;\n      } else {\n        return this._weekdaysShortRegex;\n      }\n    } else {\n      if (!hasOwnProp(this, '_weekdaysShortRegex')) {\n        this._weekdaysShortRegex = defaultWeekdaysShortRegex;\n      }\n      return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;\n    }\n  }\n  function weekdaysMinRegex(isStrict) {\n    if (this._weekdaysParseExact) {\n      if (!hasOwnProp(this, '_weekdaysRegex')) {\n        computeWeekdaysParse.call(this);\n      }\n      if (isStrict) {\n        return this._weekdaysMinStrictRegex;\n      } else {\n        return this._weekdaysMinRegex;\n      }\n    } else {\n      if (!hasOwnProp(this, '_weekdaysMinRegex')) {\n        this._weekdaysMinRegex = defaultWeekdaysMinRegex;\n      }\n      return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;\n    }\n  }\n  function computeWeekdaysParse() {\n    function cmpLenRev(a, b) {\n      return b.length - a.length;\n    }\n    var minPieces = [],\n      shortPieces = [],\n      longPieces = [],\n      mixedPieces = [],\n      i,\n      mom,\n      minp,\n      shortp,\n      longp;\n    for (i = 0; i < 7; i++) {\n      // make the regex if we don't have it already\n      mom = createUTC([2000, 1]).day(i);\n      minp = regexEscape(this.weekdaysMin(mom, ''));\n      shortp = regexEscape(this.weekdaysShort(mom, ''));\n      longp = regexEscape(this.weekdays(mom, ''));\n      minPieces.push(minp);\n      shortPieces.push(shortp);\n      longPieces.push(longp);\n      mixedPieces.push(minp);\n      mixedPieces.push(shortp);\n      mixedPieces.push(longp);\n    }\n    // Sorting makes sure if one weekday (or abbr) is a prefix of another it\n    // will match the longer piece.\n    minPieces.sort(cmpLenRev);\n    shortPieces.sort(cmpLenRev);\n    longPieces.sort(cmpLenRev);\n    mixedPieces.sort(cmpLenRev);\n    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n    this._weekdaysShortRegex = this._weekdaysRegex;\n    this._weekdaysMinRegex = this._weekdaysRegex;\n    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');\n  }\n\n  // FORMATTING\n\n  function hFormat() {\n    return this.hours() % 12 || 12;\n  }\n  function kFormat() {\n    return this.hours() || 24;\n  }\n  addFormatToken('H', ['HH', 2], 0, 'hour');\n  addFormatToken('h', ['hh', 2], 0, hFormat);\n  addFormatToken('k', ['kk', 2], 0, kFormat);\n  addFormatToken('hmm', 0, 0, function () {\n    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);\n  });\n  addFormatToken('hmmss', 0, 0, function () {\n    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);\n  });\n  addFormatToken('Hmm', 0, 0, function () {\n    return '' + this.hours() + zeroFill(this.minutes(), 2);\n  });\n  addFormatToken('Hmmss', 0, 0, function () {\n    return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);\n  });\n  function meridiem(token, lowercase) {\n    addFormatToken(token, 0, 0, function () {\n      return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);\n    });\n  }\n  meridiem('a', true);\n  meridiem('A', false);\n\n  // ALIASES\n\n  addUnitAlias('hour', 'h');\n\n  // PRIORITY\n  addUnitPriority('hour', 13);\n\n  // PARSING\n\n  function matchMeridiem(isStrict, locale) {\n    return locale._meridiemParse;\n  }\n  addRegexToken('a', matchMeridiem);\n  addRegexToken('A', matchMeridiem);\n  addRegexToken('H', match1to2);\n  addRegexToken('h', match1to2);\n  addRegexToken('k', match1to2);\n  addRegexToken('HH', match1to2, match2);\n  addRegexToken('hh', match1to2, match2);\n  addRegexToken('kk', match1to2, match2);\n  addRegexToken('hmm', match3to4);\n  addRegexToken('hmmss', match5to6);\n  addRegexToken('Hmm', match3to4);\n  addRegexToken('Hmmss', match5to6);\n  addParseToken(['H', 'HH'], HOUR);\n  addParseToken(['k', 'kk'], function (input, array, config) {\n    var kInput = toInt(input);\n    array[HOUR] = kInput === 24 ? 0 : kInput;\n  });\n  addParseToken(['a', 'A'], function (input, array, config) {\n    config._isPm = config._locale.isPM(input);\n    config._meridiem = input;\n  });\n  addParseToken(['h', 'hh'], function (input, array, config) {\n    array[HOUR] = toInt(input);\n    getParsingFlags(config).bigHour = true;\n  });\n  addParseToken('hmm', function (input, array, config) {\n    var pos = input.length - 2;\n    array[HOUR] = toInt(input.substr(0, pos));\n    array[MINUTE] = toInt(input.substr(pos));\n    getParsingFlags(config).bigHour = true;\n  });\n  addParseToken('hmmss', function (input, array, config) {\n    var pos1 = input.length - 4,\n      pos2 = input.length - 2;\n    array[HOUR] = toInt(input.substr(0, pos1));\n    array[MINUTE] = toInt(input.substr(pos1, 2));\n    array[SECOND] = toInt(input.substr(pos2));\n    getParsingFlags(config).bigHour = true;\n  });\n  addParseToken('Hmm', function (input, array, config) {\n    var pos = input.length - 2;\n    array[HOUR] = toInt(input.substr(0, pos));\n    array[MINUTE] = toInt(input.substr(pos));\n  });\n  addParseToken('Hmmss', function (input, array, config) {\n    var pos1 = input.length - 4,\n      pos2 = input.length - 2;\n    array[HOUR] = toInt(input.substr(0, pos1));\n    array[MINUTE] = toInt(input.substr(pos1, 2));\n    array[SECOND] = toInt(input.substr(pos2));\n  });\n\n  // LOCALES\n\n  function localeIsPM(input) {\n    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\n    // Using charAt should be more compatible.\n    return (input + '').toLowerCase().charAt(0) === 'p';\n  }\n  var defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i,\n    // Setting the hour should keep the time, because the user explicitly\n    // specified which hour they want. So trying to maintain the same hour (in\n    // a new timezone) makes sense. Adding/subtracting hours does not follow\n    // this rule.\n    getSetHour = makeGetSet('Hours', true);\n  function localeMeridiem(hours, minutes, isLower) {\n    if (hours > 11) {\n      return isLower ? 'pm' : 'PM';\n    } else {\n      return isLower ? 'am' : 'AM';\n    }\n  }\n  var baseConfig = {\n    calendar: defaultCalendar,\n    longDateFormat: defaultLongDateFormat,\n    invalidDate: defaultInvalidDate,\n    ordinal: defaultOrdinal,\n    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,\n    relativeTime: defaultRelativeTime,\n    months: defaultLocaleMonths,\n    monthsShort: defaultLocaleMonthsShort,\n    week: defaultLocaleWeek,\n    weekdays: defaultLocaleWeekdays,\n    weekdaysMin: defaultLocaleWeekdaysMin,\n    weekdaysShort: defaultLocaleWeekdaysShort,\n    meridiemParse: defaultLocaleMeridiemParse\n  };\n\n  // internal storage for locale config files\n  var locales = {},\n    localeFamilies = {},\n    globalLocale;\n  function commonPrefix(arr1, arr2) {\n    var i,\n      minl = Math.min(arr1.length, arr2.length);\n    for (i = 0; i < minl; i += 1) {\n      if (arr1[i] !== arr2[i]) {\n        return i;\n      }\n    }\n    return minl;\n  }\n  function normalizeLocale(key) {\n    return key ? key.toLowerCase().replace('_', '-') : key;\n  }\n\n  // pick the locale from the array\n  // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\n  // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\n  function chooseLocale(names) {\n    var i = 0,\n      j,\n      next,\n      locale,\n      split;\n    while (i < names.length) {\n      split = normalizeLocale(names[i]).split('-');\n      j = split.length;\n      next = normalizeLocale(names[i + 1]);\n      next = next ? next.split('-') : null;\n      while (j > 0) {\n        locale = loadLocale(split.slice(0, j).join('-'));\n        if (locale) {\n          return locale;\n        }\n        if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {\n          //the next array item is better than a shallower substring of this one\n          break;\n        }\n        j--;\n      }\n      i++;\n    }\n    return globalLocale;\n  }\n  function isLocaleNameSane(name) {\n    // Prevent names that look like filesystem paths, i.e contain '/' or '\\'\n    return name.match('^[^/\\\\\\\\]*$') != null;\n  }\n  function loadLocale(name) {\n    var oldLocale = null,\n      aliasedRequire;\n    // TODO: Find a better way to register and load all the locales in Node\n    if (locales[name] === undefined && \"object\" !== 'undefined' && module && module.exports && isLocaleNameSane(name)) {\n      try {\n        oldLocale = globalLocale._abbr;\n        aliasedRequire = undefined;\n        Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'undefined'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n        getSetGlobalLocale(oldLocale);\n      } catch (e) {\n        // mark as not found to avoid repeating expensive file require call causing high CPU\n        // when trying to find en-US, en_US, en-us for every format call\n        locales[name] = null; // null means not found\n      }\n    }\n\n    return locales[name];\n  }\n\n  // This function will load locale and then set the global locale.  If\n  // no arguments are passed in, it will simply return the current global\n  // locale key.\n  function getSetGlobalLocale(key, values) {\n    var data;\n    if (key) {\n      if (isUndefined(values)) {\n        data = getLocale(key);\n      } else {\n        data = defineLocale(key, values);\n      }\n      if (data) {\n        // moment.duration._locale = moment._locale = data;\n        globalLocale = data;\n      } else {\n        if (typeof console !== 'undefined' && console.warn) {\n          //warn user if arguments are passed but the locale could not be set\n          console.warn('Locale ' + key + ' not found. Did you forget to load it?');\n        }\n      }\n    }\n    return globalLocale._abbr;\n  }\n  function defineLocale(name, config) {\n    if (config !== null) {\n      var locale,\n        parentConfig = baseConfig;\n      config.abbr = name;\n      if (locales[name] != null) {\n        deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');\n        parentConfig = locales[name]._config;\n      } else if (config.parentLocale != null) {\n        if (locales[config.parentLocale] != null) {\n          parentConfig = locales[config.parentLocale]._config;\n        } else {\n          locale = loadLocale(config.parentLocale);\n          if (locale != null) {\n            parentConfig = locale._config;\n          } else {\n            if (!localeFamilies[config.parentLocale]) {\n              localeFamilies[config.parentLocale] = [];\n            }\n            localeFamilies[config.parentLocale].push({\n              name: name,\n              config: config\n            });\n            return null;\n          }\n        }\n      }\n      locales[name] = new Locale(mergeConfigs(parentConfig, config));\n      if (localeFamilies[name]) {\n        localeFamilies[name].forEach(function (x) {\n          defineLocale(x.name, x.config);\n        });\n      }\n\n      // backwards compat for now: also set the locale\n      // make sure we set the locale AFTER all child locales have been\n      // created, so we won't end up with the child locale set.\n      getSetGlobalLocale(name);\n      return locales[name];\n    } else {\n      // useful for testing\n      delete locales[name];\n      return null;\n    }\n  }\n  function updateLocale(name, config) {\n    if (config != null) {\n      var locale,\n        tmpLocale,\n        parentConfig = baseConfig;\n      if (locales[name] != null && locales[name].parentLocale != null) {\n        // Update existing child locale in-place to avoid memory-leaks\n        locales[name].set(mergeConfigs(locales[name]._config, config));\n      } else {\n        // MERGE\n        tmpLocale = loadLocale(name);\n        if (tmpLocale != null) {\n          parentConfig = tmpLocale._config;\n        }\n        config = mergeConfigs(parentConfig, config);\n        if (tmpLocale == null) {\n          // updateLocale is called for creating a new locale\n          // Set abbr so it will have a name (getters return\n          // undefined otherwise).\n          config.abbr = name;\n        }\n        locale = new Locale(config);\n        locale.parentLocale = locales[name];\n        locales[name] = locale;\n      }\n\n      // backwards compat for now: also set the locale\n      getSetGlobalLocale(name);\n    } else {\n      // pass null for config to unupdate, useful for tests\n      if (locales[name] != null) {\n        if (locales[name].parentLocale != null) {\n          locales[name] = locales[name].parentLocale;\n          if (name === getSetGlobalLocale()) {\n            getSetGlobalLocale(name);\n          }\n        } else if (locales[name] != null) {\n          delete locales[name];\n        }\n      }\n    }\n    return locales[name];\n  }\n\n  // returns locale data\n  function getLocale(key) {\n    var locale;\n    if (key && key._locale && key._locale._abbr) {\n      key = key._locale._abbr;\n    }\n    if (!key) {\n      return globalLocale;\n    }\n    if (!isArray(key)) {\n      //short-circuit everything else\n      locale = loadLocale(key);\n      if (locale) {\n        return locale;\n      }\n      key = [key];\n    }\n    return chooseLocale(key);\n  }\n  function listLocales() {\n    return keys(locales);\n  }\n  function checkOverflow(m) {\n    var overflow,\n      a = m._a;\n    if (a && getParsingFlags(m).overflow === -2) {\n      overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;\n      if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {\n        overflow = DATE;\n      }\n      if (getParsingFlags(m)._overflowWeeks && overflow === -1) {\n        overflow = WEEK;\n      }\n      if (getParsingFlags(m)._overflowWeekday && overflow === -1) {\n        overflow = WEEKDAY;\n      }\n      getParsingFlags(m).overflow = overflow;\n    }\n    return m;\n  }\n\n  // iso 8601 regex\n  // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\n  var extendedIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([+-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/,\n    basicIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d|))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([+-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/,\n    tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/,\n    isoDates = [['YYYYYY-MM-DD', /[+-]\\d{6}-\\d\\d-\\d\\d/], ['YYYY-MM-DD', /\\d{4}-\\d\\d-\\d\\d/], ['GGGG-[W]WW-E', /\\d{4}-W\\d\\d-\\d/], ['GGGG-[W]WW', /\\d{4}-W\\d\\d/, false], ['YYYY-DDD', /\\d{4}-\\d{3}/], ['YYYY-MM', /\\d{4}-\\d\\d/, false], ['YYYYYYMMDD', /[+-]\\d{10}/], ['YYYYMMDD', /\\d{8}/], ['GGGG[W]WWE', /\\d{4}W\\d{3}/], ['GGGG[W]WW', /\\d{4}W\\d{2}/, false], ['YYYYDDD', /\\d{7}/], ['YYYYMM', /\\d{6}/, false], ['YYYY', /\\d{4}/, false]],\n    // iso time formats and regexes\n    isoTimes = [['HH:mm:ss.SSSS', /\\d\\d:\\d\\d:\\d\\d\\.\\d+/], ['HH:mm:ss,SSSS', /\\d\\d:\\d\\d:\\d\\d,\\d+/], ['HH:mm:ss', /\\d\\d:\\d\\d:\\d\\d/], ['HH:mm', /\\d\\d:\\d\\d/], ['HHmmss.SSSS', /\\d\\d\\d\\d\\d\\d\\.\\d+/], ['HHmmss,SSSS', /\\d\\d\\d\\d\\d\\d,\\d+/], ['HHmmss', /\\d\\d\\d\\d\\d\\d/], ['HHmm', /\\d\\d\\d\\d/], ['HH', /\\d\\d/]],\n    aspNetJsonRegex = /^\\/?Date\\((-?\\d+)/i,\n    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3\n    rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\\d{4}))$/,\n    obsOffsets = {\n      UT: 0,\n      GMT: 0,\n      EDT: -4 * 60,\n      EST: -5 * 60,\n      CDT: -5 * 60,\n      CST: -6 * 60,\n      MDT: -6 * 60,\n      MST: -7 * 60,\n      PDT: -7 * 60,\n      PST: -8 * 60\n    };\n\n  // date from iso format\n  function configFromISO(config) {\n    var i,\n      l,\n      string = config._i,\n      match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),\n      allowTime,\n      dateFormat,\n      timeFormat,\n      tzFormat,\n      isoDatesLen = isoDates.length,\n      isoTimesLen = isoTimes.length;\n    if (match) {\n      getParsingFlags(config).iso = true;\n      for (i = 0, l = isoDatesLen; i < l; i++) {\n        if (isoDates[i][1].exec(match[1])) {\n          dateFormat = isoDates[i][0];\n          allowTime = isoDates[i][2] !== false;\n          break;\n        }\n      }\n      if (dateFormat == null) {\n        config._isValid = false;\n        return;\n      }\n      if (match[3]) {\n        for (i = 0, l = isoTimesLen; i < l; i++) {\n          if (isoTimes[i][1].exec(match[3])) {\n            // match[2] should be 'T' or space\n            timeFormat = (match[2] || ' ') + isoTimes[i][0];\n            break;\n          }\n        }\n        if (timeFormat == null) {\n          config._isValid = false;\n          return;\n        }\n      }\n      if (!allowTime && timeFormat != null) {\n        config._isValid = false;\n        return;\n      }\n      if (match[4]) {\n        if (tzRegex.exec(match[4])) {\n          tzFormat = 'Z';\n        } else {\n          config._isValid = false;\n          return;\n        }\n      }\n      config._f = dateFormat + (timeFormat || '') + (tzFormat || '');\n      configFromStringAndFormat(config);\n    } else {\n      config._isValid = false;\n    }\n  }\n  function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {\n    var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];\n    if (secondStr) {\n      result.push(parseInt(secondStr, 10));\n    }\n    return result;\n  }\n  function untruncateYear(yearStr) {\n    var year = parseInt(yearStr, 10);\n    if (year <= 49) {\n      return 2000 + year;\n    } else if (year <= 999) {\n      return 1900 + year;\n    }\n    return year;\n  }\n  function preprocessRFC2822(s) {\n    // Remove comments and folding whitespace and replace multiple-spaces with a single space\n    return s.replace(/\\([^()]*\\)|[\\n\\t]/g, ' ').replace(/(\\s\\s+)/g, ' ').replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n  }\n  function checkWeekday(weekdayStr, parsedInput, config) {\n    if (weekdayStr) {\n      // TODO: Replace the vanilla JS Date object with an independent day-of-week check.\n      var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),\n        weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();\n      if (weekdayProvided !== weekdayActual) {\n        getParsingFlags(config).weekdayMismatch = true;\n        config._isValid = false;\n        return false;\n      }\n    }\n    return true;\n  }\n  function calculateOffset(obsOffset, militaryOffset, numOffset) {\n    if (obsOffset) {\n      return obsOffsets[obsOffset];\n    } else if (militaryOffset) {\n      // the only allowed military tz is Z\n      return 0;\n    } else {\n      var hm = parseInt(numOffset, 10),\n        m = hm % 100,\n        h = (hm - m) / 100;\n      return h * 60 + m;\n    }\n  }\n\n  // date and time from ref 2822 format\n  function configFromRFC2822(config) {\n    var match = rfc2822.exec(preprocessRFC2822(config._i)),\n      parsedArray;\n    if (match) {\n      parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);\n      if (!checkWeekday(match[1], parsedArray, config)) {\n        return;\n      }\n      config._a = parsedArray;\n      config._tzm = calculateOffset(match[8], match[9], match[10]);\n      config._d = createUTCDate.apply(null, config._a);\n      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n      getParsingFlags(config).rfc2822 = true;\n    } else {\n      config._isValid = false;\n    }\n  }\n\n  // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict\n  function configFromString(config) {\n    var matched = aspNetJsonRegex.exec(config._i);\n    if (matched !== null) {\n      config._d = new Date(+matched[1]);\n      return;\n    }\n    configFromISO(config);\n    if (config._isValid === false) {\n      delete config._isValid;\n    } else {\n      return;\n    }\n    configFromRFC2822(config);\n    if (config._isValid === false) {\n      delete config._isValid;\n    } else {\n      return;\n    }\n    if (config._strict) {\n      config._isValid = false;\n    } else {\n      // Final attempt, use Input Fallback\n      hooks.createFromInputFallback(config);\n    }\n  }\n  hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {\n    config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\n  });\n\n  // Pick the first defined of two or three arguments.\n  function defaults(a, b, c) {\n    if (a != null) {\n      return a;\n    }\n    if (b != null) {\n      return b;\n    }\n    return c;\n  }\n  function currentDateArray(config) {\n    // hooks is actually the exported moment object\n    var nowValue = new Date(hooks.now());\n    if (config._useUTC) {\n      return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];\n    }\n    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];\n  }\n\n  // convert an array to a date.\n  // the array should mirror the parameters below\n  // note: all values past the year are optional and will default to the lowest possible value.\n  // [year, month, day , hour, minute, second, millisecond]\n  function configFromArray(config) {\n    var i,\n      date,\n      input = [],\n      currentDate,\n      expectedWeekday,\n      yearToUse;\n    if (config._d) {\n      return;\n    }\n    currentDate = currentDateArray(config);\n\n    //compute day of the year from weeks and weekdays\n    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n      dayOfYearFromWeekInfo(config);\n    }\n\n    //if the day of the year is set, figure out what it is\n    if (config._dayOfYear != null) {\n      yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\n      if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {\n        getParsingFlags(config)._overflowDayOfYear = true;\n      }\n      date = createUTCDate(yearToUse, 0, config._dayOfYear);\n      config._a[MONTH] = date.getUTCMonth();\n      config._a[DATE] = date.getUTCDate();\n    }\n\n    // Default to current date.\n    // * if no year, month, day of month are given, default to today\n    // * if day of month is given, default month and year\n    // * if month is given, default only year\n    // * if year is given, don't default anything\n    for (i = 0; i < 3 && config._a[i] == null; ++i) {\n      config._a[i] = input[i] = currentDate[i];\n    }\n\n    // Zero out whatever was not defaulted, including time\n    for (; i < 7; i++) {\n      config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];\n    }\n\n    // Check for 24:00:00.000\n    if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {\n      config._nextDay = true;\n      config._a[HOUR] = 0;\n    }\n    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);\n    expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();\n\n    // Apply timezone offset from input. The actual utcOffset can be changed\n    // with parseZone.\n    if (config._tzm != null) {\n      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n    }\n    if (config._nextDay) {\n      config._a[HOUR] = 24;\n    }\n\n    // check for mismatching day of week\n    if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {\n      getParsingFlags(config).weekdayMismatch = true;\n    }\n  }\n  function dayOfYearFromWeekInfo(config) {\n    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;\n    w = config._w;\n    if (w.GG != null || w.W != null || w.E != null) {\n      dow = 1;\n      doy = 4;\n\n      // TODO: We need to take the current isoWeekYear, but that depends on\n      // how we interpret now (local, utc, fixed offset). So create\n      // a now version of current config (take local/utc/offset flags, and\n      // create now).\n      weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);\n      week = defaults(w.W, 1);\n      weekday = defaults(w.E, 1);\n      if (weekday < 1 || weekday > 7) {\n        weekdayOverflow = true;\n      }\n    } else {\n      dow = config._locale._week.dow;\n      doy = config._locale._week.doy;\n      curWeek = weekOfYear(createLocal(), dow, doy);\n      weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);\n\n      // Default to current week.\n      week = defaults(w.w, curWeek.week);\n      if (w.d != null) {\n        // weekday -- low day numbers are considered next week\n        weekday = w.d;\n        if (weekday < 0 || weekday > 6) {\n          weekdayOverflow = true;\n        }\n      } else if (w.e != null) {\n        // local weekday -- counting starts from beginning of week\n        weekday = w.e + dow;\n        if (w.e < 0 || w.e > 6) {\n          weekdayOverflow = true;\n        }\n      } else {\n        // default to beginning of week\n        weekday = dow;\n      }\n    }\n    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {\n      getParsingFlags(config)._overflowWeeks = true;\n    } else if (weekdayOverflow != null) {\n      getParsingFlags(config)._overflowWeekday = true;\n    } else {\n      temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\n      config._a[YEAR] = temp.year;\n      config._dayOfYear = temp.dayOfYear;\n    }\n  }\n\n  // constant that refers to the ISO standard\n  hooks.ISO_8601 = function () {};\n\n  // constant that refers to the RFC 2822 form\n  hooks.RFC_2822 = function () {};\n\n  // date from string and format string\n  function configFromStringAndFormat(config) {\n    // TODO: Move this to another part of the creation flow to prevent circular deps\n    if (config._f === hooks.ISO_8601) {\n      configFromISO(config);\n      return;\n    }\n    if (config._f === hooks.RFC_2822) {\n      configFromRFC2822(config);\n      return;\n    }\n    config._a = [];\n    getParsingFlags(config).empty = true;\n\n    // This array is used to make a Date, either with `new Date` or `Date.UTC`\n    var string = '' + config._i,\n      i,\n      parsedInput,\n      tokens,\n      token,\n      skipped,\n      stringLength = string.length,\n      totalParsedInputLength = 0,\n      era,\n      tokenLen;\n    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\n    tokenLen = tokens.length;\n    for (i = 0; i < tokenLen; i++) {\n      token = tokens[i];\n      parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\n      if (parsedInput) {\n        skipped = string.substr(0, string.indexOf(parsedInput));\n        if (skipped.length > 0) {\n          getParsingFlags(config).unusedInput.push(skipped);\n        }\n        string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n        totalParsedInputLength += parsedInput.length;\n      }\n      // don't parse if it's not a known token\n      if (formatTokenFunctions[token]) {\n        if (parsedInput) {\n          getParsingFlags(config).empty = false;\n        } else {\n          getParsingFlags(config).unusedTokens.push(token);\n        }\n        addTimeToArrayFromToken(token, parsedInput, config);\n      } else if (config._strict && !parsedInput) {\n        getParsingFlags(config).unusedTokens.push(token);\n      }\n    }\n\n    // add remaining unparsed input length to the string\n    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\n    if (string.length > 0) {\n      getParsingFlags(config).unusedInput.push(string);\n    }\n\n    // clear _12h flag if hour is <= 12\n    if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {\n      getParsingFlags(config).bigHour = undefined;\n    }\n    getParsingFlags(config).parsedDateParts = config._a.slice(0);\n    getParsingFlags(config).meridiem = config._meridiem;\n    // handle meridiem\n    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);\n\n    // handle era\n    era = getParsingFlags(config).era;\n    if (era !== null) {\n      config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);\n    }\n    configFromArray(config);\n    checkOverflow(config);\n  }\n  function meridiemFixWrap(locale, hour, meridiem) {\n    var isPm;\n    if (meridiem == null) {\n      // nothing to do\n      return hour;\n    }\n    if (locale.meridiemHour != null) {\n      return locale.meridiemHour(hour, meridiem);\n    } else if (locale.isPM != null) {\n      // Fallback\n      isPm = locale.isPM(meridiem);\n      if (isPm && hour < 12) {\n        hour += 12;\n      }\n      if (!isPm && hour === 12) {\n        hour = 0;\n      }\n      return hour;\n    } else {\n      // this is not supposed to happen\n      return hour;\n    }\n  }\n\n  // date from string and array of format strings\n  function configFromStringAndArray(config) {\n    var tempConfig,\n      bestMoment,\n      scoreToBeat,\n      i,\n      currentScore,\n      validFormatFound,\n      bestFormatIsValid = false,\n      configfLen = config._f.length;\n    if (configfLen === 0) {\n      getParsingFlags(config).invalidFormat = true;\n      config._d = new Date(NaN);\n      return;\n    }\n    for (i = 0; i < configfLen; i++) {\n      currentScore = 0;\n      validFormatFound = false;\n      tempConfig = copyConfig({}, config);\n      if (config._useUTC != null) {\n        tempConfig._useUTC = config._useUTC;\n      }\n      tempConfig._f = config._f[i];\n      configFromStringAndFormat(tempConfig);\n      if (isValid(tempConfig)) {\n        validFormatFound = true;\n      }\n\n      // if there is any input that was not parsed add a penalty for that format\n      currentScore += getParsingFlags(tempConfig).charsLeftOver;\n\n      //or tokens\n      currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n      getParsingFlags(tempConfig).score = currentScore;\n      if (!bestFormatIsValid) {\n        if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {\n          scoreToBeat = currentScore;\n          bestMoment = tempConfig;\n          if (validFormatFound) {\n            bestFormatIsValid = true;\n          }\n        }\n      } else {\n        if (currentScore < scoreToBeat) {\n          scoreToBeat = currentScore;\n          bestMoment = tempConfig;\n        }\n      }\n    }\n    extend(config, bestMoment || tempConfig);\n  }\n  function configFromObject(config) {\n    if (config._d) {\n      return;\n    }\n    var i = normalizeObjectUnits(config._i),\n      dayOrDate = i.day === undefined ? i.date : i.day;\n    config._a = map([i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond], function (obj) {\n      return obj && parseInt(obj, 10);\n    });\n    configFromArray(config);\n  }\n  function createFromConfig(config) {\n    var res = new Moment(checkOverflow(prepareConfig(config)));\n    if (res._nextDay) {\n      // Adding is smart enough around DST\n      res.add(1, 'd');\n      res._nextDay = undefined;\n    }\n    return res;\n  }\n  function prepareConfig(config) {\n    var input = config._i,\n      format = config._f;\n    config._locale = config._locale || getLocale(config._l);\n    if (input === null || format === undefined && input === '') {\n      return createInvalid({\n        nullInput: true\n      });\n    }\n    if (typeof input === 'string') {\n      config._i = input = config._locale.preparse(input);\n    }\n    if (isMoment(input)) {\n      return new Moment(checkOverflow(input));\n    } else if (isDate(input)) {\n      config._d = input;\n    } else if (isArray(format)) {\n      configFromStringAndArray(config);\n    } else if (format) {\n      configFromStringAndFormat(config);\n    } else {\n      configFromInput(config);\n    }\n    if (!isValid(config)) {\n      config._d = null;\n    }\n    return config;\n  }\n  function configFromInput(config) {\n    var input = config._i;\n    if (isUndefined(input)) {\n      config._d = new Date(hooks.now());\n    } else if (isDate(input)) {\n      config._d = new Date(input.valueOf());\n    } else if (typeof input === 'string') {\n      configFromString(config);\n    } else if (isArray(input)) {\n      config._a = map(input.slice(0), function (obj) {\n        return parseInt(obj, 10);\n      });\n      configFromArray(config);\n    } else if (isObject(input)) {\n      configFromObject(config);\n    } else if (isNumber(input)) {\n      // from milliseconds\n      config._d = new Date(input);\n    } else {\n      hooks.createFromInputFallback(config);\n    }\n  }\n  function createLocalOrUTC(input, format, locale, strict, isUTC) {\n    var c = {};\n    if (format === true || format === false) {\n      strict = format;\n      format = undefined;\n    }\n    if (locale === true || locale === false) {\n      strict = locale;\n      locale = undefined;\n    }\n    if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {\n      input = undefined;\n    }\n    // object construction must be done this way.\n    // https://github.com/moment/moment/issues/1423\n    c._isAMomentObject = true;\n    c._useUTC = c._isUTC = isUTC;\n    c._l = locale;\n    c._i = input;\n    c._f = format;\n    c._strict = strict;\n    return createFromConfig(c);\n  }\n  function createLocal(input, format, locale, strict) {\n    return createLocalOrUTC(input, format, locale, strict, false);\n  }\n  var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {\n      var other = createLocal.apply(null, arguments);\n      if (this.isValid() && other.isValid()) {\n        return other < this ? this : other;\n      } else {\n        return createInvalid();\n      }\n    }),\n    prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {\n      var other = createLocal.apply(null, arguments);\n      if (this.isValid() && other.isValid()) {\n        return other > this ? this : other;\n      } else {\n        return createInvalid();\n      }\n    });\n\n  // Pick a moment m from moments so that m[fn](other) is true for all\n  // other. This relies on the function fn to be transitive.\n  //\n  // moments should either be an array of moment objects or an array, whose\n  // first element is an array of moment objects.\n  function pickBy(fn, moments) {\n    var res, i;\n    if (moments.length === 1 && isArray(moments[0])) {\n      moments = moments[0];\n    }\n    if (!moments.length) {\n      return createLocal();\n    }\n    res = moments[0];\n    for (i = 1; i < moments.length; ++i) {\n      if (!moments[i].isValid() || moments[i][fn](res)) {\n        res = moments[i];\n      }\n    }\n    return res;\n  }\n\n  // TODO: Use [].sort instead?\n  function min() {\n    var args = [].slice.call(arguments, 0);\n    return pickBy('isBefore', args);\n  }\n  function max() {\n    var args = [].slice.call(arguments, 0);\n    return pickBy('isAfter', args);\n  }\n  var now = function now() {\n    return Date.now ? Date.now() : +new Date();\n  };\n  var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];\n  function isDurationValid(m) {\n    var key,\n      unitHasDecimal = false,\n      i,\n      orderLen = ordering.length;\n    for (key in m) {\n      if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {\n        return false;\n      }\n    }\n    for (i = 0; i < orderLen; ++i) {\n      if (m[ordering[i]]) {\n        if (unitHasDecimal) {\n          return false; // only allow non-integers for smallest unit\n        }\n\n        if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {\n          unitHasDecimal = true;\n        }\n      }\n    }\n    return true;\n  }\n  function isValid$1() {\n    return this._isValid;\n  }\n  function createInvalid$1() {\n    return createDuration(NaN);\n  }\n  function Duration(duration) {\n    var normalizedInput = normalizeObjectUnits(duration),\n      years = normalizedInput.year || 0,\n      quarters = normalizedInput.quarter || 0,\n      months = normalizedInput.month || 0,\n      weeks = normalizedInput.week || normalizedInput.isoWeek || 0,\n      days = normalizedInput.day || 0,\n      hours = normalizedInput.hour || 0,\n      minutes = normalizedInput.minute || 0,\n      seconds = normalizedInput.second || 0,\n      milliseconds = normalizedInput.millisecond || 0;\n    this._isValid = isDurationValid(normalizedInput);\n\n    // representation for dateAddRemove\n    this._milliseconds = +milliseconds + seconds * 1e3 +\n    // 1000\n    minutes * 6e4 +\n    // 1000 * 60\n    hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\n    // Because of dateAddRemove treats 24 hours as different from a\n    // day when working around DST, we need to store them separately\n    this._days = +days + weeks * 7;\n    // It is impossible to translate months into days without knowing\n    // which months you are are talking about, so we have to store\n    // it separately.\n    this._months = +months + quarters * 3 + years * 12;\n    this._data = {};\n    this._locale = getLocale();\n    this._bubble();\n  }\n  function isDuration(obj) {\n    return obj instanceof Duration;\n  }\n  function absRound(number) {\n    if (number < 0) {\n      return Math.round(-1 * number) * -1;\n    } else {\n      return Math.round(number);\n    }\n  }\n\n  // compare two arrays, return the number of differences\n  function compareArrays(array1, array2, dontConvert) {\n    var len = Math.min(array1.length, array2.length),\n      lengthDiff = Math.abs(array1.length - array2.length),\n      diffs = 0,\n      i;\n    for (i = 0; i < len; i++) {\n      if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {\n        diffs++;\n      }\n    }\n    return diffs + lengthDiff;\n  }\n\n  // FORMATTING\n\n  function offset(token, separator) {\n    addFormatToken(token, 0, 0, function () {\n      var offset = this.utcOffset(),\n        sign = '+';\n      if (offset < 0) {\n        offset = -offset;\n        sign = '-';\n      }\n      return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);\n    });\n  }\n  offset('Z', ':');\n  offset('ZZ', '');\n\n  // PARSING\n\n  addRegexToken('Z', matchShortOffset);\n  addRegexToken('ZZ', matchShortOffset);\n  addParseToken(['Z', 'ZZ'], function (input, array, config) {\n    config._useUTC = true;\n    config._tzm = offsetFromString(matchShortOffset, input);\n  });\n\n  // HELPERS\n\n  // timezone chunker\n  // '+10:00' > ['10',  '00']\n  // '-1530'  > ['-15', '30']\n  var chunkOffset = /([\\+\\-]|\\d\\d)/gi;\n  function offsetFromString(matcher, string) {\n    var matches = (string || '').match(matcher),\n      chunk,\n      parts,\n      minutes;\n    if (matches === null) {\n      return null;\n    }\n    chunk = matches[matches.length - 1] || [];\n    parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];\n    minutes = +(parts[1] * 60) + toInt(parts[2]);\n    return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;\n  }\n\n  // Return a moment from input, that is local/utc/zone equivalent to model.\n  function cloneWithOffset(input, model) {\n    var res, diff;\n    if (model._isUTC) {\n      res = model.clone();\n      diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();\n      // Use low-level api, because this fn is low-level api.\n      res._d.setTime(res._d.valueOf() + diff);\n      hooks.updateOffset(res, false);\n      return res;\n    } else {\n      return createLocal(input).local();\n    }\n  }\n  function getDateOffset(m) {\n    // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n    // https://github.com/moment/moment/pull/1871\n    return -Math.round(m._d.getTimezoneOffset());\n  }\n\n  // HOOKS\n\n  // This function will be called whenever a moment is mutated.\n  // It is intended to keep the offset in sync with the timezone.\n  hooks.updateOffset = function () {};\n\n  // MOMENTS\n\n  // keepLocalTime = true means only change the timezone, without\n  // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\n  // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\n  // +0200, so we adjust the time as needed, to be valid.\n  //\n  // Keeping the time actually adds/subtracts (one hour)\n  // from the actual represented time. That is why we call updateOffset\n  // a second time. In case it wants us to change the offset again\n  // _changeInProgress == true case, then we have to adjust, because\n  // there is no such time in the given timezone.\n  function getSetOffset(input, keepLocalTime, keepMinutes) {\n    var offset = this._offset || 0,\n      localAdjust;\n    if (!this.isValid()) {\n      return input != null ? this : NaN;\n    }\n    if (input != null) {\n      if (typeof input === 'string') {\n        input = offsetFromString(matchShortOffset, input);\n        if (input === null) {\n          return this;\n        }\n      } else if (Math.abs(input) < 16 && !keepMinutes) {\n        input = input * 60;\n      }\n      if (!this._isUTC && keepLocalTime) {\n        localAdjust = getDateOffset(this);\n      }\n      this._offset = input;\n      this._isUTC = true;\n      if (localAdjust != null) {\n        this.add(localAdjust, 'm');\n      }\n      if (offset !== input) {\n        if (!keepLocalTime || this._changeInProgress) {\n          addSubtract(this, createDuration(input - offset, 'm'), 1, false);\n        } else if (!this._changeInProgress) {\n          this._changeInProgress = true;\n          hooks.updateOffset(this, true);\n          this._changeInProgress = null;\n        }\n      }\n      return this;\n    } else {\n      return this._isUTC ? offset : getDateOffset(this);\n    }\n  }\n  function getSetZone(input, keepLocalTime) {\n    if (input != null) {\n      if (typeof input !== 'string') {\n        input = -input;\n      }\n      this.utcOffset(input, keepLocalTime);\n      return this;\n    } else {\n      return -this.utcOffset();\n    }\n  }\n  function setOffsetToUTC(keepLocalTime) {\n    return this.utcOffset(0, keepLocalTime);\n  }\n  function setOffsetToLocal(keepLocalTime) {\n    if (this._isUTC) {\n      this.utcOffset(0, keepLocalTime);\n      this._isUTC = false;\n      if (keepLocalTime) {\n        this.subtract(getDateOffset(this), 'm');\n      }\n    }\n    return this;\n  }\n  function setOffsetToParsedOffset() {\n    if (this._tzm != null) {\n      this.utcOffset(this._tzm, false, true);\n    } else if (typeof this._i === 'string') {\n      var tZone = offsetFromString(matchOffset, this._i);\n      if (tZone != null) {\n        this.utcOffset(tZone);\n      } else {\n        this.utcOffset(0, true);\n      }\n    }\n    return this;\n  }\n  function hasAlignedHourOffset(input) {\n    if (!this.isValid()) {\n      return false;\n    }\n    input = input ? createLocal(input).utcOffset() : 0;\n    return (this.utcOffset() - input) % 60 === 0;\n  }\n  function isDaylightSavingTime() {\n    return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();\n  }\n  function isDaylightSavingTimeShifted() {\n    if (!isUndefined(this._isDSTShifted)) {\n      return this._isDSTShifted;\n    }\n    var c = {},\n      other;\n    copyConfig(c, this);\n    c = prepareConfig(c);\n    if (c._a) {\n      other = c._isUTC ? createUTC(c._a) : createLocal(c._a);\n      this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;\n    } else {\n      this._isDSTShifted = false;\n    }\n    return this._isDSTShifted;\n  }\n  function isLocal() {\n    return this.isValid() ? !this._isUTC : false;\n  }\n  function isUtcOffset() {\n    return this.isValid() ? this._isUTC : false;\n  }\n  function isUtc() {\n    return this.isValid() ? this._isUTC && this._offset === 0 : false;\n  }\n\n  // ASP.NET json date format regex\n  var aspNetRegex = /^(-|\\+)?(?:(\\d*)[. ])?(\\d+):(\\d+)(?::(\\d+)(\\.\\d*)?)?$/,\n    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n    // and further modified to allow for strings containing both week and day\n    isoRegex = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n  function createDuration(input, key) {\n    var duration = input,\n      // matching against regexp is expensive, do it on demand\n      match = null,\n      sign,\n      ret,\n      diffRes;\n    if (isDuration(input)) {\n      duration = {\n        ms: input._milliseconds,\n        d: input._days,\n        M: input._months\n      };\n    } else if (isNumber(input) || !isNaN(+input)) {\n      duration = {};\n      if (key) {\n        duration[key] = +input;\n      } else {\n        duration.milliseconds = +input;\n      }\n    } else if (match = aspNetRegex.exec(input)) {\n      sign = match[1] === '-' ? -1 : 1;\n      duration = {\n        y: 0,\n        d: toInt(match[DATE]) * sign,\n        h: toInt(match[HOUR]) * sign,\n        m: toInt(match[MINUTE]) * sign,\n        s: toInt(match[SECOND]) * sign,\n        ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match\n      };\n    } else if (match = isoRegex.exec(input)) {\n      sign = match[1] === '-' ? -1 : 1;\n      duration = {\n        y: parseIso(match[2], sign),\n        M: parseIso(match[3], sign),\n        w: parseIso(match[4], sign),\n        d: parseIso(match[5], sign),\n        h: parseIso(match[6], sign),\n        m: parseIso(match[7], sign),\n        s: parseIso(match[8], sign)\n      };\n    } else if (duration == null) {\n      // checks for null or undefined\n      duration = {};\n    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {\n      diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));\n      duration = {};\n      duration.ms = diffRes.milliseconds;\n      duration.M = diffRes.months;\n    }\n    ret = new Duration(duration);\n    if (isDuration(input) && hasOwnProp(input, '_locale')) {\n      ret._locale = input._locale;\n    }\n    if (isDuration(input) && hasOwnProp(input, '_isValid')) {\n      ret._isValid = input._isValid;\n    }\n    return ret;\n  }\n  createDuration.fn = Duration.prototype;\n  createDuration.invalid = createInvalid$1;\n  function parseIso(inp, sign) {\n    // We'd normally use ~~inp for this, but unfortunately it also\n    // converts floats to ints.\n    // inp may be undefined, so careful calling replace on it.\n    var res = inp && parseFloat(inp.replace(',', '.'));\n    // apply sign while we're at it\n    return (isNaN(res) ? 0 : res) * sign;\n  }\n  function positiveMomentsDifference(base, other) {\n    var res = {};\n    res.months = other.month() - base.month() + (other.year() - base.year()) * 12;\n    if (base.clone().add(res.months, 'M').isAfter(other)) {\n      --res.months;\n    }\n    res.milliseconds = +other - +base.clone().add(res.months, 'M');\n    return res;\n  }\n  function momentsDifference(base, other) {\n    var res;\n    if (!(base.isValid() && other.isValid())) {\n      return {\n        milliseconds: 0,\n        months: 0\n      };\n    }\n    other = cloneWithOffset(other, base);\n    if (base.isBefore(other)) {\n      res = positiveMomentsDifference(base, other);\n    } else {\n      res = positiveMomentsDifference(other, base);\n      res.milliseconds = -res.milliseconds;\n      res.months = -res.months;\n    }\n    return res;\n  }\n\n  // TODO: remove 'name' arg after deprecation is removed\n  function createAdder(direction, name) {\n    return function (val, period) {\n      var dur, tmp;\n      //invert the arguments, but complain about it\n      if (period !== null && !isNaN(+period)) {\n        deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');\n        tmp = val;\n        val = period;\n        period = tmp;\n      }\n      dur = createDuration(val, period);\n      addSubtract(this, dur, direction);\n      return this;\n    };\n  }\n  function addSubtract(mom, duration, isAdding, updateOffset) {\n    var milliseconds = duration._milliseconds,\n      days = absRound(duration._days),\n      months = absRound(duration._months);\n    if (!mom.isValid()) {\n      // No op\n      return;\n    }\n    updateOffset = updateOffset == null ? true : updateOffset;\n    if (months) {\n      setMonth(mom, get(mom, 'Month') + months * isAdding);\n    }\n    if (days) {\n      set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);\n    }\n    if (milliseconds) {\n      mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);\n    }\n    if (updateOffset) {\n      hooks.updateOffset(mom, days || months);\n    }\n  }\n  var add = createAdder(1, 'add'),\n    subtract = createAdder(-1, 'subtract');\n  function isString(input) {\n    return typeof input === 'string' || input instanceof String;\n  }\n\n  // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined\n  function isMomentInput(input) {\n    return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === undefined;\n  }\n  function isMomentInputObject(input) {\n    var objectTest = isObject(input) && !isObjectEmpty(input),\n      propertyTest = false,\n      properties = ['years', 'year', 'y', 'months', 'month', 'M', 'days', 'day', 'd', 'dates', 'date', 'D', 'hours', 'hour', 'h', 'minutes', 'minute', 'm', 'seconds', 'second', 's', 'milliseconds', 'millisecond', 'ms'],\n      i,\n      property,\n      propertyLen = properties.length;\n    for (i = 0; i < propertyLen; i += 1) {\n      property = properties[i];\n      propertyTest = propertyTest || hasOwnProp(input, property);\n    }\n    return objectTest && propertyTest;\n  }\n  function isNumberOrStringArray(input) {\n    var arrayTest = isArray(input),\n      dataTypeTest = false;\n    if (arrayTest) {\n      dataTypeTest = input.filter(function (item) {\n        return !isNumber(item) && isString(input);\n      }).length === 0;\n    }\n    return arrayTest && dataTypeTest;\n  }\n  function isCalendarSpec(input) {\n    var objectTest = isObject(input) && !isObjectEmpty(input),\n      propertyTest = false,\n      properties = ['sameDay', 'nextDay', 'lastDay', 'nextWeek', 'lastWeek', 'sameElse'],\n      i,\n      property;\n    for (i = 0; i < properties.length; i += 1) {\n      property = properties[i];\n      propertyTest = propertyTest || hasOwnProp(input, property);\n    }\n    return objectTest && propertyTest;\n  }\n  function getCalendarFormat(myMoment, now) {\n    var diff = myMoment.diff(now, 'days', true);\n    return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';\n  }\n  function calendar$1(time, formats) {\n    // Support for single parameter, formats only overload to the calendar function\n    if (arguments.length === 1) {\n      if (!arguments[0]) {\n        time = undefined;\n        formats = undefined;\n      } else if (isMomentInput(arguments[0])) {\n        time = arguments[0];\n        formats = undefined;\n      } else if (isCalendarSpec(arguments[0])) {\n        formats = arguments[0];\n        time = undefined;\n      }\n    }\n    // We want to compare the start of today, vs this.\n    // Getting start-of-today depends on whether we're local/utc/offset or not.\n    var now = time || createLocal(),\n      sod = cloneWithOffset(now, this).startOf('day'),\n      format = hooks.calendarFormat(this, sod) || 'sameElse',\n      output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);\n    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));\n  }\n  function clone() {\n    return new Moment(this);\n  }\n  function isAfter(input, units) {\n    var localInput = isMoment(input) ? input : createLocal(input);\n    if (!(this.isValid() && localInput.isValid())) {\n      return false;\n    }\n    units = normalizeUnits(units) || 'millisecond';\n    if (units === 'millisecond') {\n      return this.valueOf() > localInput.valueOf();\n    } else {\n      return localInput.valueOf() < this.clone().startOf(units).valueOf();\n    }\n  }\n  function isBefore(input, units) {\n    var localInput = isMoment(input) ? input : createLocal(input);\n    if (!(this.isValid() && localInput.isValid())) {\n      return false;\n    }\n    units = normalizeUnits(units) || 'millisecond';\n    if (units === 'millisecond') {\n      return this.valueOf() < localInput.valueOf();\n    } else {\n      return this.clone().endOf(units).valueOf() < localInput.valueOf();\n    }\n  }\n  function isBetween(from, to, units, inclusivity) {\n    var localFrom = isMoment(from) ? from : createLocal(from),\n      localTo = isMoment(to) ? to : createLocal(to);\n    if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {\n      return false;\n    }\n    inclusivity = inclusivity || '()';\n    return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));\n  }\n  function isSame(input, units) {\n    var localInput = isMoment(input) ? input : createLocal(input),\n      inputMs;\n    if (!(this.isValid() && localInput.isValid())) {\n      return false;\n    }\n    units = normalizeUnits(units) || 'millisecond';\n    if (units === 'millisecond') {\n      return this.valueOf() === localInput.valueOf();\n    } else {\n      inputMs = localInput.valueOf();\n      return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();\n    }\n  }\n  function isSameOrAfter(input, units) {\n    return this.isSame(input, units) || this.isAfter(input, units);\n  }\n  function isSameOrBefore(input, units) {\n    return this.isSame(input, units) || this.isBefore(input, units);\n  }\n  function diff(input, units, asFloat) {\n    var that, zoneDelta, output;\n    if (!this.isValid()) {\n      return NaN;\n    }\n    that = cloneWithOffset(input, this);\n    if (!that.isValid()) {\n      return NaN;\n    }\n    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;\n    units = normalizeUnits(units);\n    switch (units) {\n      case 'year':\n        output = monthDiff(this, that) / 12;\n        break;\n      case 'month':\n        output = monthDiff(this, that);\n        break;\n      case 'quarter':\n        output = monthDiff(this, that) / 3;\n        break;\n      case 'second':\n        output = (this - that) / 1e3;\n        break;\n      // 1000\n      case 'minute':\n        output = (this - that) / 6e4;\n        break;\n      // 1000 * 60\n      case 'hour':\n        output = (this - that) / 36e5;\n        break;\n      // 1000 * 60 * 60\n      case 'day':\n        output = (this - that - zoneDelta) / 864e5;\n        break;\n      // 1000 * 60 * 60 * 24, negate dst\n      case 'week':\n        output = (this - that - zoneDelta) / 6048e5;\n        break;\n      // 1000 * 60 * 60 * 24 * 7, negate dst\n      default:\n        output = this - that;\n    }\n    return asFloat ? output : absFloor(output);\n  }\n  function monthDiff(a, b) {\n    if (a.date() < b.date()) {\n      // end-of-month calculations work correct when the start month has more\n      // days than the end month.\n      return -monthDiff(b, a);\n    }\n    // difference in months\n    var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),\n      // b is in (anchor - 1 month, anchor + 1 month)\n      anchor = a.clone().add(wholeMonthDiff, 'months'),\n      anchor2,\n      adjust;\n    if (b - anchor < 0) {\n      anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');\n      // linear across the month\n      adjust = (b - anchor) / (anchor - anchor2);\n    } else {\n      anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');\n      // linear across the month\n      adjust = (b - anchor) / (anchor2 - anchor);\n    }\n\n    //check for negative zero, return zero if negative zero\n    return -(wholeMonthDiff + adjust) || 0;\n  }\n  hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';\n  hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';\n  function toString() {\n    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');\n  }\n  function toISOString(keepOffset) {\n    if (!this.isValid()) {\n      return null;\n    }\n    var utc = keepOffset !== true,\n      m = utc ? this.clone().utc() : this;\n    if (m.year() < 0 || m.year() > 9999) {\n      return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');\n    }\n    if (isFunction(Date.prototype.toISOString)) {\n      // native implementation is ~50x faster, use it when we can\n      if (utc) {\n        return this.toDate().toISOString();\n      } else {\n        return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));\n      }\n    }\n    return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');\n  }\n\n  /**\n   * Return a human readable representation of a moment that can\n   * also be evaluated to get a new moment which is the same\n   *\n   * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects\n   */\n  function inspect() {\n    if (!this.isValid()) {\n      return 'moment.invalid(/* ' + this._i + ' */)';\n    }\n    var func = 'moment',\n      zone = '',\n      prefix,\n      year,\n      datetime,\n      suffix;\n    if (!this.isLocal()) {\n      func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';\n      zone = 'Z';\n    }\n    prefix = '[' + func + '(\"]';\n    year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';\n    datetime = '-MM-DD[T]HH:mm:ss.SSS';\n    suffix = zone + '[\")]';\n    return this.format(prefix + year + datetime + suffix);\n  }\n  function format(inputString) {\n    if (!inputString) {\n      inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;\n    }\n    var output = formatMoment(this, inputString);\n    return this.localeData().postformat(output);\n  }\n  function from(time, withoutSuffix) {\n    if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {\n      return createDuration({\n        to: this,\n        from: time\n      }).locale(this.locale()).humanize(!withoutSuffix);\n    } else {\n      return this.localeData().invalidDate();\n    }\n  }\n  function fromNow(withoutSuffix) {\n    return this.from(createLocal(), withoutSuffix);\n  }\n  function to(time, withoutSuffix) {\n    if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {\n      return createDuration({\n        from: this,\n        to: time\n      }).locale(this.locale()).humanize(!withoutSuffix);\n    } else {\n      return this.localeData().invalidDate();\n    }\n  }\n  function toNow(withoutSuffix) {\n    return this.to(createLocal(), withoutSuffix);\n  }\n\n  // If passed a locale key, it will set the locale for this\n  // instance.  Otherwise, it will return the locale configuration\n  // variables for this instance.\n  function locale(key) {\n    var newLocaleData;\n    if (key === undefined) {\n      return this._locale._abbr;\n    } else {\n      newLocaleData = getLocale(key);\n      if (newLocaleData != null) {\n        this._locale = newLocaleData;\n      }\n      return this;\n    }\n  }\n  var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {\n    if (key === undefined) {\n      return this.localeData();\n    } else {\n      return this.locale(key);\n    }\n  });\n  function localeData() {\n    return this._locale;\n  }\n  var MS_PER_SECOND = 1000,\n    MS_PER_MINUTE = 60 * MS_PER_SECOND,\n    MS_PER_HOUR = 60 * MS_PER_MINUTE,\n    MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;\n\n  // actual modulo - handles negative numbers (for dates before 1970):\n  function mod$1(dividend, divisor) {\n    return (dividend % divisor + divisor) % divisor;\n  }\n  function localStartOfDate(y, m, d) {\n    // the date constructor remaps years 0-99 to 1900-1999\n    if (y < 100 && y >= 0) {\n      // preserve leap years using a full 400 year cycle, then reset\n      return new Date(y + 400, m, d) - MS_PER_400_YEARS;\n    } else {\n      return new Date(y, m, d).valueOf();\n    }\n  }\n  function utcStartOfDate(y, m, d) {\n    // Date.UTC remaps years 0-99 to 1900-1999\n    if (y < 100 && y >= 0) {\n      // preserve leap years using a full 400 year cycle, then reset\n      return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;\n    } else {\n      return Date.UTC(y, m, d);\n    }\n  }\n  function startOf(units) {\n    var time, startOfDate;\n    units = normalizeUnits(units);\n    if (units === undefined || units === 'millisecond' || !this.isValid()) {\n      return this;\n    }\n    startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;\n    switch (units) {\n      case 'year':\n        time = startOfDate(this.year(), 0, 1);\n        break;\n      case 'quarter':\n        time = startOfDate(this.year(), this.month() - this.month() % 3, 1);\n        break;\n      case 'month':\n        time = startOfDate(this.year(), this.month(), 1);\n        break;\n      case 'week':\n        time = startOfDate(this.year(), this.month(), this.date() - this.weekday());\n        break;\n      case 'isoWeek':\n        time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));\n        break;\n      case 'day':\n      case 'date':\n        time = startOfDate(this.year(), this.month(), this.date());\n        break;\n      case 'hour':\n        time = this._d.valueOf();\n        time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);\n        break;\n      case 'minute':\n        time = this._d.valueOf();\n        time -= mod$1(time, MS_PER_MINUTE);\n        break;\n      case 'second':\n        time = this._d.valueOf();\n        time -= mod$1(time, MS_PER_SECOND);\n        break;\n    }\n    this._d.setTime(time);\n    hooks.updateOffset(this, true);\n    return this;\n  }\n  function endOf(units) {\n    var time, startOfDate;\n    units = normalizeUnits(units);\n    if (units === undefined || units === 'millisecond' || !this.isValid()) {\n      return this;\n    }\n    startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;\n    switch (units) {\n      case 'year':\n        time = startOfDate(this.year() + 1, 0, 1) - 1;\n        break;\n      case 'quarter':\n        time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;\n        break;\n      case 'month':\n        time = startOfDate(this.year(), this.month() + 1, 1) - 1;\n        break;\n      case 'week':\n        time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;\n        break;\n      case 'isoWeek':\n        time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;\n        break;\n      case 'day':\n      case 'date':\n        time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;\n        break;\n      case 'hour':\n        time = this._d.valueOf();\n        time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;\n        break;\n      case 'minute':\n        time = this._d.valueOf();\n        time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;\n        break;\n      case 'second':\n        time = this._d.valueOf();\n        time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;\n        break;\n    }\n    this._d.setTime(time);\n    hooks.updateOffset(this, true);\n    return this;\n  }\n  function valueOf() {\n    return this._d.valueOf() - (this._offset || 0) * 60000;\n  }\n  function unix() {\n    return Math.floor(this.valueOf() / 1000);\n  }\n  function toDate() {\n    return new Date(this.valueOf());\n  }\n  function toArray() {\n    var m = this;\n    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];\n  }\n  function toObject() {\n    var m = this;\n    return {\n      years: m.year(),\n      months: m.month(),\n      date: m.date(),\n      hours: m.hours(),\n      minutes: m.minutes(),\n      seconds: m.seconds(),\n      milliseconds: m.milliseconds()\n    };\n  }\n  function toJSON() {\n    // new Date(NaN).toJSON() === null\n    return this.isValid() ? this.toISOString() : null;\n  }\n  function isValid$2() {\n    return isValid(this);\n  }\n  function parsingFlags() {\n    return extend({}, getParsingFlags(this));\n  }\n  function invalidAt() {\n    return getParsingFlags(this).overflow;\n  }\n  function creationData() {\n    return {\n      input: this._i,\n      format: this._f,\n      locale: this._locale,\n      isUTC: this._isUTC,\n      strict: this._strict\n    };\n  }\n  addFormatToken('N', 0, 0, 'eraAbbr');\n  addFormatToken('NN', 0, 0, 'eraAbbr');\n  addFormatToken('NNN', 0, 0, 'eraAbbr');\n  addFormatToken('NNNN', 0, 0, 'eraName');\n  addFormatToken('NNNNN', 0, 0, 'eraNarrow');\n  addFormatToken('y', ['y', 1], 'yo', 'eraYear');\n  addFormatToken('y', ['yy', 2], 0, 'eraYear');\n  addFormatToken('y', ['yyy', 3], 0, 'eraYear');\n  addFormatToken('y', ['yyyy', 4], 0, 'eraYear');\n  addRegexToken('N', matchEraAbbr);\n  addRegexToken('NN', matchEraAbbr);\n  addRegexToken('NNN', matchEraAbbr);\n  addRegexToken('NNNN', matchEraName);\n  addRegexToken('NNNNN', matchEraNarrow);\n  addParseToken(['N', 'NN', 'NNN', 'NNNN', 'NNNNN'], function (input, array, config, token) {\n    var era = config._locale.erasParse(input, token, config._strict);\n    if (era) {\n      getParsingFlags(config).era = era;\n    } else {\n      getParsingFlags(config).invalidEra = input;\n    }\n  });\n  addRegexToken('y', matchUnsigned);\n  addRegexToken('yy', matchUnsigned);\n  addRegexToken('yyy', matchUnsigned);\n  addRegexToken('yyyy', matchUnsigned);\n  addRegexToken('yo', matchEraYearOrdinal);\n  addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);\n  addParseToken(['yo'], function (input, array, config, token) {\n    var match;\n    if (config._locale._eraYearOrdinalRegex) {\n      match = input.match(config._locale._eraYearOrdinalRegex);\n    }\n    if (config._locale.eraYearOrdinalParse) {\n      array[YEAR] = config._locale.eraYearOrdinalParse(input, match);\n    } else {\n      array[YEAR] = parseInt(input, 10);\n    }\n  });\n  function localeEras(m, format) {\n    var i,\n      l,\n      date,\n      eras = this._eras || getLocale('en')._eras;\n    for (i = 0, l = eras.length; i < l; ++i) {\n      switch (typeof eras[i].since) {\n        case 'string':\n          // truncate time\n          date = hooks(eras[i].since).startOf('day');\n          eras[i].since = date.valueOf();\n          break;\n      }\n      switch (typeof eras[i].until) {\n        case 'undefined':\n          eras[i].until = +Infinity;\n          break;\n        case 'string':\n          // truncate time\n          date = hooks(eras[i].until).startOf('day').valueOf();\n          eras[i].until = date.valueOf();\n          break;\n      }\n    }\n    return eras;\n  }\n  function localeErasParse(eraName, format, strict) {\n    var i,\n      l,\n      eras = this.eras(),\n      name,\n      abbr,\n      narrow;\n    eraName = eraName.toUpperCase();\n    for (i = 0, l = eras.length; i < l; ++i) {\n      name = eras[i].name.toUpperCase();\n      abbr = eras[i].abbr.toUpperCase();\n      narrow = eras[i].narrow.toUpperCase();\n      if (strict) {\n        switch (format) {\n          case 'N':\n          case 'NN':\n          case 'NNN':\n            if (abbr === eraName) {\n              return eras[i];\n            }\n            break;\n          case 'NNNN':\n            if (name === eraName) {\n              return eras[i];\n            }\n            break;\n          case 'NNNNN':\n            if (narrow === eraName) {\n              return eras[i];\n            }\n            break;\n        }\n      } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {\n        return eras[i];\n      }\n    }\n  }\n  function localeErasConvertYear(era, year) {\n    var dir = era.since <= era.until ? +1 : -1;\n    if (year === undefined) {\n      return hooks(era.since).year();\n    } else {\n      return hooks(era.since).year() + (year - era.offset) * dir;\n    }\n  }\n  function getEraName() {\n    var i,\n      l,\n      val,\n      eras = this.localeData().eras();\n    for (i = 0, l = eras.length; i < l; ++i) {\n      // truncate time\n      val = this.clone().startOf('day').valueOf();\n      if (eras[i].since <= val && val <= eras[i].until) {\n        return eras[i].name;\n      }\n      if (eras[i].until <= val && val <= eras[i].since) {\n        return eras[i].name;\n      }\n    }\n    return '';\n  }\n  function getEraNarrow() {\n    var i,\n      l,\n      val,\n      eras = this.localeData().eras();\n    for (i = 0, l = eras.length; i < l; ++i) {\n      // truncate time\n      val = this.clone().startOf('day').valueOf();\n      if (eras[i].since <= val && val <= eras[i].until) {\n        return eras[i].narrow;\n      }\n      if (eras[i].until <= val && val <= eras[i].since) {\n        return eras[i].narrow;\n      }\n    }\n    return '';\n  }\n  function getEraAbbr() {\n    var i,\n      l,\n      val,\n      eras = this.localeData().eras();\n    for (i = 0, l = eras.length; i < l; ++i) {\n      // truncate time\n      val = this.clone().startOf('day').valueOf();\n      if (eras[i].since <= val && val <= eras[i].until) {\n        return eras[i].abbr;\n      }\n      if (eras[i].until <= val && val <= eras[i].since) {\n        return eras[i].abbr;\n      }\n    }\n    return '';\n  }\n  function getEraYear() {\n    var i,\n      l,\n      dir,\n      val,\n      eras = this.localeData().eras();\n    for (i = 0, l = eras.length; i < l; ++i) {\n      dir = eras[i].since <= eras[i].until ? +1 : -1;\n\n      // truncate time\n      val = this.clone().startOf('day').valueOf();\n      if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {\n        return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;\n      }\n    }\n    return this.year();\n  }\n  function erasNameRegex(isStrict) {\n    if (!hasOwnProp(this, '_erasNameRegex')) {\n      computeErasParse.call(this);\n    }\n    return isStrict ? this._erasNameRegex : this._erasRegex;\n  }\n  function erasAbbrRegex(isStrict) {\n    if (!hasOwnProp(this, '_erasAbbrRegex')) {\n      computeErasParse.call(this);\n    }\n    return isStrict ? this._erasAbbrRegex : this._erasRegex;\n  }\n  function erasNarrowRegex(isStrict) {\n    if (!hasOwnProp(this, '_erasNarrowRegex')) {\n      computeErasParse.call(this);\n    }\n    return isStrict ? this._erasNarrowRegex : this._erasRegex;\n  }\n  function matchEraAbbr(isStrict, locale) {\n    return locale.erasAbbrRegex(isStrict);\n  }\n  function matchEraName(isStrict, locale) {\n    return locale.erasNameRegex(isStrict);\n  }\n  function matchEraNarrow(isStrict, locale) {\n    return locale.erasNarrowRegex(isStrict);\n  }\n  function matchEraYearOrdinal(isStrict, locale) {\n    return locale._eraYearOrdinalRegex || matchUnsigned;\n  }\n  function computeErasParse() {\n    var abbrPieces = [],\n      namePieces = [],\n      narrowPieces = [],\n      mixedPieces = [],\n      i,\n      l,\n      eras = this.eras();\n    for (i = 0, l = eras.length; i < l; ++i) {\n      namePieces.push(regexEscape(eras[i].name));\n      abbrPieces.push(regexEscape(eras[i].abbr));\n      narrowPieces.push(regexEscape(eras[i].narrow));\n      mixedPieces.push(regexEscape(eras[i].name));\n      mixedPieces.push(regexEscape(eras[i].abbr));\n      mixedPieces.push(regexEscape(eras[i].narrow));\n    }\n    this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n    this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');\n    this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');\n    this._erasNarrowRegex = new RegExp('^(' + narrowPieces.join('|') + ')', 'i');\n  }\n\n  // FORMATTING\n\n  addFormatToken(0, ['gg', 2], 0, function () {\n    return this.weekYear() % 100;\n  });\n  addFormatToken(0, ['GG', 2], 0, function () {\n    return this.isoWeekYear() % 100;\n  });\n  function addWeekYearFormatToken(token, getter) {\n    addFormatToken(0, [token, token.length], 0, getter);\n  }\n  addWeekYearFormatToken('gggg', 'weekYear');\n  addWeekYearFormatToken('ggggg', 'weekYear');\n  addWeekYearFormatToken('GGGG', 'isoWeekYear');\n  addWeekYearFormatToken('GGGGG', 'isoWeekYear');\n\n  // ALIASES\n\n  addUnitAlias('weekYear', 'gg');\n  addUnitAlias('isoWeekYear', 'GG');\n\n  // PRIORITY\n\n  addUnitPriority('weekYear', 1);\n  addUnitPriority('isoWeekYear', 1);\n\n  // PARSING\n\n  addRegexToken('G', matchSigned);\n  addRegexToken('g', matchSigned);\n  addRegexToken('GG', match1to2, match2);\n  addRegexToken('gg', match1to2, match2);\n  addRegexToken('GGGG', match1to4, match4);\n  addRegexToken('gggg', match1to4, match4);\n  addRegexToken('GGGGG', match1to6, match6);\n  addRegexToken('ggggg', match1to6, match6);\n  addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {\n    week[token.substr(0, 2)] = toInt(input);\n  });\n  addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {\n    week[token] = hooks.parseTwoDigitYear(input);\n  });\n\n  // MOMENTS\n\n  function getSetWeekYear(input) {\n    return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);\n  }\n  function getSetISOWeekYear(input) {\n    return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);\n  }\n  function getISOWeeksInYear() {\n    return weeksInYear(this.year(), 1, 4);\n  }\n  function getISOWeeksInISOWeekYear() {\n    return weeksInYear(this.isoWeekYear(), 1, 4);\n  }\n  function getWeeksInYear() {\n    var weekInfo = this.localeData()._week;\n    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\n  }\n  function getWeeksInWeekYear() {\n    var weekInfo = this.localeData()._week;\n    return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);\n  }\n  function getSetWeekYearHelper(input, week, weekday, dow, doy) {\n    var weeksTarget;\n    if (input == null) {\n      return weekOfYear(this, dow, doy).year;\n    } else {\n      weeksTarget = weeksInYear(input, dow, doy);\n      if (week > weeksTarget) {\n        week = weeksTarget;\n      }\n      return setWeekAll.call(this, input, week, weekday, dow, doy);\n    }\n  }\n  function setWeekAll(weekYear, week, weekday, dow, doy) {\n    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),\n      date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\n    this.year(date.getUTCFullYear());\n    this.month(date.getUTCMonth());\n    this.date(date.getUTCDate());\n    return this;\n  }\n\n  // FORMATTING\n\n  addFormatToken('Q', 0, 'Qo', 'quarter');\n\n  // ALIASES\n\n  addUnitAlias('quarter', 'Q');\n\n  // PRIORITY\n\n  addUnitPriority('quarter', 7);\n\n  // PARSING\n\n  addRegexToken('Q', match1);\n  addParseToken('Q', function (input, array) {\n    array[MONTH] = (toInt(input) - 1) * 3;\n  });\n\n  // MOMENTS\n\n  function getSetQuarter(input) {\n    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\n  }\n\n  // FORMATTING\n\n  addFormatToken('D', ['DD', 2], 'Do', 'date');\n\n  // ALIASES\n\n  addUnitAlias('date', 'D');\n\n  // PRIORITY\n  addUnitPriority('date', 9);\n\n  // PARSING\n\n  addRegexToken('D', match1to2);\n  addRegexToken('DD', match1to2, match2);\n  addRegexToken('Do', function (isStrict, locale) {\n    // TODO: Remove \"ordinalParse\" fallback in next major release.\n    return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;\n  });\n  addParseToken(['D', 'DD'], DATE);\n  addParseToken('Do', function (input, array) {\n    array[DATE] = toInt(input.match(match1to2)[0]);\n  });\n\n  // MOMENTS\n\n  var getSetDayOfMonth = makeGetSet('Date', true);\n\n  // FORMATTING\n\n  addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');\n\n  // ALIASES\n\n  addUnitAlias('dayOfYear', 'DDD');\n\n  // PRIORITY\n  addUnitPriority('dayOfYear', 4);\n\n  // PARSING\n\n  addRegexToken('DDD', match1to3);\n  addRegexToken('DDDD', match3);\n  addParseToken(['DDD', 'DDDD'], function (input, array, config) {\n    config._dayOfYear = toInt(input);\n  });\n\n  // HELPERS\n\n  // MOMENTS\n\n  function getSetDayOfYear(input) {\n    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;\n    return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');\n  }\n\n  // FORMATTING\n\n  addFormatToken('m', ['mm', 2], 0, 'minute');\n\n  // ALIASES\n\n  addUnitAlias('minute', 'm');\n\n  // PRIORITY\n\n  addUnitPriority('minute', 14);\n\n  // PARSING\n\n  addRegexToken('m', match1to2);\n  addRegexToken('mm', match1to2, match2);\n  addParseToken(['m', 'mm'], MINUTE);\n\n  // MOMENTS\n\n  var getSetMinute = makeGetSet('Minutes', false);\n\n  // FORMATTING\n\n  addFormatToken('s', ['ss', 2], 0, 'second');\n\n  // ALIASES\n\n  addUnitAlias('second', 's');\n\n  // PRIORITY\n\n  addUnitPriority('second', 15);\n\n  // PARSING\n\n  addRegexToken('s', match1to2);\n  addRegexToken('ss', match1to2, match2);\n  addParseToken(['s', 'ss'], SECOND);\n\n  // MOMENTS\n\n  var getSetSecond = makeGetSet('Seconds', false);\n\n  // FORMATTING\n\n  addFormatToken('S', 0, 0, function () {\n    return ~~(this.millisecond() / 100);\n  });\n  addFormatToken(0, ['SS', 2], 0, function () {\n    return ~~(this.millisecond() / 10);\n  });\n  addFormatToken(0, ['SSS', 3], 0, 'millisecond');\n  addFormatToken(0, ['SSSS', 4], 0, function () {\n    return this.millisecond() * 10;\n  });\n  addFormatToken(0, ['SSSSS', 5], 0, function () {\n    return this.millisecond() * 100;\n  });\n  addFormatToken(0, ['SSSSSS', 6], 0, function () {\n    return this.millisecond() * 1000;\n  });\n  addFormatToken(0, ['SSSSSSS', 7], 0, function () {\n    return this.millisecond() * 10000;\n  });\n  addFormatToken(0, ['SSSSSSSS', 8], 0, function () {\n    return this.millisecond() * 100000;\n  });\n  addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {\n    return this.millisecond() * 1000000;\n  });\n\n  // ALIASES\n\n  addUnitAlias('millisecond', 'ms');\n\n  // PRIORITY\n\n  addUnitPriority('millisecond', 16);\n\n  // PARSING\n\n  addRegexToken('S', match1to3, match1);\n  addRegexToken('SS', match1to3, match2);\n  addRegexToken('SSS', match1to3, match3);\n  var token, getSetMillisecond;\n  for (token = 'SSSS'; token.length <= 9; token += 'S') {\n    addRegexToken(token, matchUnsigned);\n  }\n  function parseMs(input, array) {\n    array[MILLISECOND] = toInt(('0.' + input) * 1000);\n  }\n  for (token = 'S'; token.length <= 9; token += 'S') {\n    addParseToken(token, parseMs);\n  }\n  getSetMillisecond = makeGetSet('Milliseconds', false);\n\n  // FORMATTING\n\n  addFormatToken('z', 0, 0, 'zoneAbbr');\n  addFormatToken('zz', 0, 0, 'zoneName');\n\n  // MOMENTS\n\n  function getZoneAbbr() {\n    return this._isUTC ? 'UTC' : '';\n  }\n  function getZoneName() {\n    return this._isUTC ? 'Coordinated Universal Time' : '';\n  }\n  var proto = Moment.prototype;\n  proto.add = add;\n  proto.calendar = calendar$1;\n  proto.clone = clone;\n  proto.diff = diff;\n  proto.endOf = endOf;\n  proto.format = format;\n  proto.from = from;\n  proto.fromNow = fromNow;\n  proto.to = to;\n  proto.toNow = toNow;\n  proto.get = stringGet;\n  proto.invalidAt = invalidAt;\n  proto.isAfter = isAfter;\n  proto.isBefore = isBefore;\n  proto.isBetween = isBetween;\n  proto.isSame = isSame;\n  proto.isSameOrAfter = isSameOrAfter;\n  proto.isSameOrBefore = isSameOrBefore;\n  proto.isValid = isValid$2;\n  proto.lang = lang;\n  proto.locale = locale;\n  proto.localeData = localeData;\n  proto.max = prototypeMax;\n  proto.min = prototypeMin;\n  proto.parsingFlags = parsingFlags;\n  proto.set = stringSet;\n  proto.startOf = startOf;\n  proto.subtract = subtract;\n  proto.toArray = toArray;\n  proto.toObject = toObject;\n  proto.toDate = toDate;\n  proto.toISOString = toISOString;\n  proto.inspect = inspect;\n  if (typeof Symbol !== 'undefined' && Symbol.for != null) {\n    proto[Symbol.for('nodejs.util.inspect.custom')] = function () {\n      return 'Moment<' + this.format() + '>';\n    };\n  }\n  proto.toJSON = toJSON;\n  proto.toString = toString;\n  proto.unix = unix;\n  proto.valueOf = valueOf;\n  proto.creationData = creationData;\n  proto.eraName = getEraName;\n  proto.eraNarrow = getEraNarrow;\n  proto.eraAbbr = getEraAbbr;\n  proto.eraYear = getEraYear;\n  proto.year = getSetYear;\n  proto.isLeapYear = getIsLeapYear;\n  proto.weekYear = getSetWeekYear;\n  proto.isoWeekYear = getSetISOWeekYear;\n  proto.quarter = proto.quarters = getSetQuarter;\n  proto.month = getSetMonth;\n  proto.daysInMonth = getDaysInMonth;\n  proto.week = proto.weeks = getSetWeek;\n  proto.isoWeek = proto.isoWeeks = getSetISOWeek;\n  proto.weeksInYear = getWeeksInYear;\n  proto.weeksInWeekYear = getWeeksInWeekYear;\n  proto.isoWeeksInYear = getISOWeeksInYear;\n  proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;\n  proto.date = getSetDayOfMonth;\n  proto.day = proto.days = getSetDayOfWeek;\n  proto.weekday = getSetLocaleDayOfWeek;\n  proto.isoWeekday = getSetISODayOfWeek;\n  proto.dayOfYear = getSetDayOfYear;\n  proto.hour = proto.hours = getSetHour;\n  proto.minute = proto.minutes = getSetMinute;\n  proto.second = proto.seconds = getSetSecond;\n  proto.millisecond = proto.milliseconds = getSetMillisecond;\n  proto.utcOffset = getSetOffset;\n  proto.utc = setOffsetToUTC;\n  proto.local = setOffsetToLocal;\n  proto.parseZone = setOffsetToParsedOffset;\n  proto.hasAlignedHourOffset = hasAlignedHourOffset;\n  proto.isDST = isDaylightSavingTime;\n  proto.isLocal = isLocal;\n  proto.isUtcOffset = isUtcOffset;\n  proto.isUtc = isUtc;\n  proto.isUTC = isUtc;\n  proto.zoneAbbr = getZoneAbbr;\n  proto.zoneName = getZoneName;\n  proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);\n  proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);\n  proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);\n  proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);\n  proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);\n  function createUnix(input) {\n    return createLocal(input * 1000);\n  }\n  function createInZone() {\n    return createLocal.apply(null, arguments).parseZone();\n  }\n  function preParsePostFormat(string) {\n    return string;\n  }\n  var proto$1 = Locale.prototype;\n  proto$1.calendar = calendar;\n  proto$1.longDateFormat = longDateFormat;\n  proto$1.invalidDate = invalidDate;\n  proto$1.ordinal = ordinal;\n  proto$1.preparse = preParsePostFormat;\n  proto$1.postformat = preParsePostFormat;\n  proto$1.relativeTime = relativeTime;\n  proto$1.pastFuture = pastFuture;\n  proto$1.set = set;\n  proto$1.eras = localeEras;\n  proto$1.erasParse = localeErasParse;\n  proto$1.erasConvertYear = localeErasConvertYear;\n  proto$1.erasAbbrRegex = erasAbbrRegex;\n  proto$1.erasNameRegex = erasNameRegex;\n  proto$1.erasNarrowRegex = erasNarrowRegex;\n  proto$1.months = localeMonths;\n  proto$1.monthsShort = localeMonthsShort;\n  proto$1.monthsParse = localeMonthsParse;\n  proto$1.monthsRegex = monthsRegex;\n  proto$1.monthsShortRegex = monthsShortRegex;\n  proto$1.week = localeWeek;\n  proto$1.firstDayOfYear = localeFirstDayOfYear;\n  proto$1.firstDayOfWeek = localeFirstDayOfWeek;\n  proto$1.weekdays = localeWeekdays;\n  proto$1.weekdaysMin = localeWeekdaysMin;\n  proto$1.weekdaysShort = localeWeekdaysShort;\n  proto$1.weekdaysParse = localeWeekdaysParse;\n  proto$1.weekdaysRegex = weekdaysRegex;\n  proto$1.weekdaysShortRegex = weekdaysShortRegex;\n  proto$1.weekdaysMinRegex = weekdaysMinRegex;\n  proto$1.isPM = localeIsPM;\n  proto$1.meridiem = localeMeridiem;\n  function get$1(format, index, field, setter) {\n    var locale = getLocale(),\n      utc = createUTC().set(setter, index);\n    return locale[field](utc, format);\n  }\n  function listMonthsImpl(format, index, field) {\n    if (isNumber(format)) {\n      index = format;\n      format = undefined;\n    }\n    format = format || '';\n    if (index != null) {\n      return get$1(format, index, field, 'month');\n    }\n    var i,\n      out = [];\n    for (i = 0; i < 12; i++) {\n      out[i] = get$1(format, i, field, 'month');\n    }\n    return out;\n  }\n\n  // ()\n  // (5)\n  // (fmt, 5)\n  // (fmt)\n  // (true)\n  // (true, 5)\n  // (true, fmt, 5)\n  // (true, fmt)\n  function listWeekdaysImpl(localeSorted, format, index, field) {\n    if (typeof localeSorted === 'boolean') {\n      if (isNumber(format)) {\n        index = format;\n        format = undefined;\n      }\n      format = format || '';\n    } else {\n      format = localeSorted;\n      index = format;\n      localeSorted = false;\n      if (isNumber(format)) {\n        index = format;\n        format = undefined;\n      }\n      format = format || '';\n    }\n    var locale = getLocale(),\n      shift = localeSorted ? locale._week.dow : 0,\n      i,\n      out = [];\n    if (index != null) {\n      return get$1(format, (index + shift) % 7, field, 'day');\n    }\n    for (i = 0; i < 7; i++) {\n      out[i] = get$1(format, (i + shift) % 7, field, 'day');\n    }\n    return out;\n  }\n  function listMonths(format, index) {\n    return listMonthsImpl(format, index, 'months');\n  }\n  function listMonthsShort(format, index) {\n    return listMonthsImpl(format, index, 'monthsShort');\n  }\n  function listWeekdays(localeSorted, format, index) {\n    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');\n  }\n  function listWeekdaysShort(localeSorted, format, index) {\n    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');\n  }\n  function listWeekdaysMin(localeSorted, format, index) {\n    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');\n  }\n  getSetGlobalLocale('en', {\n    eras: [{\n      since: '0001-01-01',\n      until: +Infinity,\n      offset: 1,\n      name: 'Anno Domini',\n      narrow: 'AD',\n      abbr: 'AD'\n    }, {\n      since: '0000-12-31',\n      until: -Infinity,\n      offset: 1,\n      name: 'Before Christ',\n      narrow: 'BC',\n      abbr: 'BC'\n    }],\n    dayOfMonthOrdinalParse: /\\d{1,2}(th|st|nd|rd)/,\n    ordinal: function ordinal(number) {\n      var b = number % 10,\n        output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';\n      return number + output;\n    }\n  });\n\n  // Side effect imports\n\n  hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);\n  hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);\n  var mathAbs = Math.abs;\n  function abs() {\n    var data = this._data;\n    this._milliseconds = mathAbs(this._milliseconds);\n    this._days = mathAbs(this._days);\n    this._months = mathAbs(this._months);\n    data.milliseconds = mathAbs(data.milliseconds);\n    data.seconds = mathAbs(data.seconds);\n    data.minutes = mathAbs(data.minutes);\n    data.hours = mathAbs(data.hours);\n    data.months = mathAbs(data.months);\n    data.years = mathAbs(data.years);\n    return this;\n  }\n  function addSubtract$1(duration, input, value, direction) {\n    var other = createDuration(input, value);\n    duration._milliseconds += direction * other._milliseconds;\n    duration._days += direction * other._days;\n    duration._months += direction * other._months;\n    return duration._bubble();\n  }\n\n  // supports only 2.0-style add(1, 's') or add(duration)\n  function add$1(input, value) {\n    return addSubtract$1(this, input, value, 1);\n  }\n\n  // supports only 2.0-style subtract(1, 's') or subtract(duration)\n  function subtract$1(input, value) {\n    return addSubtract$1(this, input, value, -1);\n  }\n  function absCeil(number) {\n    if (number < 0) {\n      return Math.floor(number);\n    } else {\n      return Math.ceil(number);\n    }\n  }\n  function bubble() {\n    var milliseconds = this._milliseconds,\n      days = this._days,\n      months = this._months,\n      data = this._data,\n      seconds,\n      minutes,\n      hours,\n      years,\n      monthsFromDays;\n\n    // if we have a mix of positive and negative values, bubble down first\n    // check: https://github.com/moment/moment/issues/2166\n    if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {\n      milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\n      days = 0;\n      months = 0;\n    }\n\n    // The following code bubbles up values, see the tests for\n    // examples of what that means.\n    data.milliseconds = milliseconds % 1000;\n    seconds = absFloor(milliseconds / 1000);\n    data.seconds = seconds % 60;\n    minutes = absFloor(seconds / 60);\n    data.minutes = minutes % 60;\n    hours = absFloor(minutes / 60);\n    data.hours = hours % 24;\n    days += absFloor(hours / 24);\n\n    // convert days to months\n    monthsFromDays = absFloor(daysToMonths(days));\n    months += monthsFromDays;\n    days -= absCeil(monthsToDays(monthsFromDays));\n\n    // 12 months -> 1 year\n    years = absFloor(months / 12);\n    months %= 12;\n    data.days = days;\n    data.months = months;\n    data.years = years;\n    return this;\n  }\n  function daysToMonths(days) {\n    // 400 years have 146097 days (taking into account leap year rules)\n    // 400 years have 12 months === 4800\n    return days * 4800 / 146097;\n  }\n  function monthsToDays(months) {\n    // the reverse of daysToMonths\n    return months * 146097 / 4800;\n  }\n  function as(units) {\n    if (!this.isValid()) {\n      return NaN;\n    }\n    var days,\n      months,\n      milliseconds = this._milliseconds;\n    units = normalizeUnits(units);\n    if (units === 'month' || units === 'quarter' || units === 'year') {\n      days = this._days + milliseconds / 864e5;\n      months = this._months + daysToMonths(days);\n      switch (units) {\n        case 'month':\n          return months;\n        case 'quarter':\n          return months / 3;\n        case 'year':\n          return months / 12;\n      }\n    } else {\n      // handle milliseconds separately because of floating point math errors (issue #1867)\n      days = this._days + Math.round(monthsToDays(this._months));\n      switch (units) {\n        case 'week':\n          return days / 7 + milliseconds / 6048e5;\n        case 'day':\n          return days + milliseconds / 864e5;\n        case 'hour':\n          return days * 24 + milliseconds / 36e5;\n        case 'minute':\n          return days * 1440 + milliseconds / 6e4;\n        case 'second':\n          return days * 86400 + milliseconds / 1000;\n        // Math.floor prevents floating point math errors here\n        case 'millisecond':\n          return Math.floor(days * 864e5) + milliseconds;\n        default:\n          throw new Error('Unknown unit ' + units);\n      }\n    }\n  }\n\n  // TODO: Use this.as('ms')?\n  function valueOf$1() {\n    if (!this.isValid()) {\n      return NaN;\n    }\n    return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;\n  }\n  function makeAs(alias) {\n    return function () {\n      return this.as(alias);\n    };\n  }\n  var asMilliseconds = makeAs('ms'),\n    asSeconds = makeAs('s'),\n    asMinutes = makeAs('m'),\n    asHours = makeAs('h'),\n    asDays = makeAs('d'),\n    asWeeks = makeAs('w'),\n    asMonths = makeAs('M'),\n    asQuarters = makeAs('Q'),\n    asYears = makeAs('y');\n  function clone$1() {\n    return createDuration(this);\n  }\n  function get$2(units) {\n    units = normalizeUnits(units);\n    return this.isValid() ? this[units + 's']() : NaN;\n  }\n  function makeGetter(name) {\n    return function () {\n      return this.isValid() ? this._data[name] : NaN;\n    };\n  }\n  var milliseconds = makeGetter('milliseconds'),\n    seconds = makeGetter('seconds'),\n    minutes = makeGetter('minutes'),\n    hours = makeGetter('hours'),\n    days = makeGetter('days'),\n    months = makeGetter('months'),\n    years = makeGetter('years');\n  function weeks() {\n    return absFloor(this.days() / 7);\n  }\n  var round = Math.round,\n    thresholds = {\n      ss: 44,\n      // a few seconds to seconds\n      s: 45,\n      // seconds to minute\n      m: 45,\n      // minutes to hour\n      h: 22,\n      // hours to day\n      d: 26,\n      // days to month/week\n      w: null,\n      // weeks to month\n      M: 11 // months to year\n    };\n\n  // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\n  function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\n    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n  }\n  function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {\n    var duration = createDuration(posNegDuration).abs(),\n      seconds = round(duration.as('s')),\n      minutes = round(duration.as('m')),\n      hours = round(duration.as('h')),\n      days = round(duration.as('d')),\n      months = round(duration.as('M')),\n      weeks = round(duration.as('w')),\n      years = round(duration.as('y')),\n      a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days];\n    if (thresholds.w != null) {\n      a = a || weeks <= 1 && ['w'] || weeks < thresholds.w && ['ww', weeks];\n    }\n    a = a || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];\n    a[2] = withoutSuffix;\n    a[3] = +posNegDuration > 0;\n    a[4] = locale;\n    return substituteTimeAgo.apply(null, a);\n  }\n\n  // This function allows you to set the rounding function for relative time strings\n  function getSetRelativeTimeRounding(roundingFunction) {\n    if (roundingFunction === undefined) {\n      return round;\n    }\n    if (typeof roundingFunction === 'function') {\n      round = roundingFunction;\n      return true;\n    }\n    return false;\n  }\n\n  // This function allows you to set a threshold for relative time strings\n  function getSetRelativeTimeThreshold(threshold, limit) {\n    if (thresholds[threshold] === undefined) {\n      return false;\n    }\n    if (limit === undefined) {\n      return thresholds[threshold];\n    }\n    thresholds[threshold] = limit;\n    if (threshold === 's') {\n      thresholds.ss = limit - 1;\n    }\n    return true;\n  }\n  function humanize(argWithSuffix, argThresholds) {\n    if (!this.isValid()) {\n      return this.localeData().invalidDate();\n    }\n    var withSuffix = false,\n      th = thresholds,\n      locale,\n      output;\n    if (typeof argWithSuffix === 'object') {\n      argThresholds = argWithSuffix;\n      argWithSuffix = false;\n    }\n    if (typeof argWithSuffix === 'boolean') {\n      withSuffix = argWithSuffix;\n    }\n    if (typeof argThresholds === 'object') {\n      th = Object.assign({}, thresholds, argThresholds);\n      if (argThresholds.s != null && argThresholds.ss == null) {\n        th.ss = argThresholds.s - 1;\n      }\n    }\n    locale = this.localeData();\n    output = relativeTime$1(this, !withSuffix, th, locale);\n    if (withSuffix) {\n      output = locale.pastFuture(+this, output);\n    }\n    return locale.postformat(output);\n  }\n  var abs$1 = Math.abs;\n  function sign(x) {\n    return (x > 0) - (x < 0) || +x;\n  }\n  function toISOString$1() {\n    // for ISO strings we do not use the normal bubbling rules:\n    //  * milliseconds bubble up until they become hours\n    //  * days do not bubble at all\n    //  * months bubble up until they become years\n    // This is because there is no context-free conversion between hours and days\n    // (think of clock changes)\n    // and also not between days and months (28-31 days per month)\n    if (!this.isValid()) {\n      return this.localeData().invalidDate();\n    }\n    var seconds = abs$1(this._milliseconds) / 1000,\n      days = abs$1(this._days),\n      months = abs$1(this._months),\n      minutes,\n      hours,\n      years,\n      s,\n      total = this.asSeconds(),\n      totalSign,\n      ymSign,\n      daysSign,\n      hmsSign;\n    if (!total) {\n      // this is the same as C#'s (Noda) and python (isodate)...\n      // but not other JS (goog.date)\n      return 'P0D';\n    }\n\n    // 3600 seconds -> 60 minutes -> 1 hour\n    minutes = absFloor(seconds / 60);\n    hours = absFloor(minutes / 60);\n    seconds %= 60;\n    minutes %= 60;\n\n    // 12 months -> 1 year\n    years = absFloor(months / 12);\n    months %= 12;\n\n    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n    s = seconds ? seconds.toFixed(3).replace(/\\.?0+$/, '') : '';\n    totalSign = total < 0 ? '-' : '';\n    ymSign = sign(this._months) !== sign(total) ? '-' : '';\n    daysSign = sign(this._days) !== sign(total) ? '-' : '';\n    hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';\n    return totalSign + 'P' + (years ? ymSign + years + 'Y' : '') + (months ? ymSign + months + 'M' : '') + (days ? daysSign + days + 'D' : '') + (hours || minutes || seconds ? 'T' : '') + (hours ? hmsSign + hours + 'H' : '') + (minutes ? hmsSign + minutes + 'M' : '') + (seconds ? hmsSign + s + 'S' : '');\n  }\n  var proto$2 = Duration.prototype;\n  proto$2.isValid = isValid$1;\n  proto$2.abs = abs;\n  proto$2.add = add$1;\n  proto$2.subtract = subtract$1;\n  proto$2.as = as;\n  proto$2.asMilliseconds = asMilliseconds;\n  proto$2.asSeconds = asSeconds;\n  proto$2.asMinutes = asMinutes;\n  proto$2.asHours = asHours;\n  proto$2.asDays = asDays;\n  proto$2.asWeeks = asWeeks;\n  proto$2.asMonths = asMonths;\n  proto$2.asQuarters = asQuarters;\n  proto$2.asYears = asYears;\n  proto$2.valueOf = valueOf$1;\n  proto$2._bubble = bubble;\n  proto$2.clone = clone$1;\n  proto$2.get = get$2;\n  proto$2.milliseconds = milliseconds;\n  proto$2.seconds = seconds;\n  proto$2.minutes = minutes;\n  proto$2.hours = hours;\n  proto$2.days = days;\n  proto$2.weeks = weeks;\n  proto$2.months = months;\n  proto$2.years = years;\n  proto$2.humanize = humanize;\n  proto$2.toISOString = toISOString$1;\n  proto$2.toString = toISOString$1;\n  proto$2.toJSON = toISOString$1;\n  proto$2.locale = locale;\n  proto$2.localeData = localeData;\n  proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);\n  proto$2.lang = lang;\n\n  // FORMATTING\n\n  addFormatToken('X', 0, 0, 'unix');\n  addFormatToken('x', 0, 0, 'valueOf');\n\n  // PARSING\n\n  addRegexToken('x', matchSigned);\n  addRegexToken('X', matchTimestamp);\n  addParseToken('X', function (input, array, config) {\n    config._d = new Date(parseFloat(input) * 1000);\n  });\n  addParseToken('x', function (input, array, config) {\n    config._d = new Date(toInt(input));\n  });\n\n  //! moment.js\n\n  hooks.version = '2.29.4';\n  setHookCallback(createLocal);\n  hooks.fn = proto;\n  hooks.min = min;\n  hooks.max = max;\n  hooks.now = now;\n  hooks.utc = createUTC;\n  hooks.unix = createUnix;\n  hooks.months = listMonths;\n  hooks.isDate = isDate;\n  hooks.locale = getSetGlobalLocale;\n  hooks.invalid = createInvalid;\n  hooks.duration = createDuration;\n  hooks.isMoment = isMoment;\n  hooks.weekdays = listWeekdays;\n  hooks.parseZone = createInZone;\n  hooks.localeData = getLocale;\n  hooks.isDuration = isDuration;\n  hooks.monthsShort = listMonthsShort;\n  hooks.weekdaysMin = listWeekdaysMin;\n  hooks.defineLocale = defineLocale;\n  hooks.updateLocale = updateLocale;\n  hooks.locales = listLocales;\n  hooks.weekdaysShort = listWeekdaysShort;\n  hooks.normalizeUnits = normalizeUnits;\n  hooks.relativeTimeRounding = getSetRelativeTimeRounding;\n  hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;\n  hooks.calendarFormat = getCalendarFormat;\n  hooks.prototype = proto;\n\n  // currently HTML5 input type only supports 24-hour formats\n  hooks.HTML5_FMT = {\n    DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',\n    // <input type=\"datetime-local\" />\n    DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',\n    // <input type=\"datetime-local\" step=\"1\" />\n    DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',\n    // <input type=\"datetime-local\" step=\"0.001\" />\n    DATE: 'YYYY-MM-DD',\n    // <input type=\"date\" />\n    TIME: 'HH:mm',\n    // <input type=\"time\" />\n    TIME_SECONDS: 'HH:mm:ss',\n    // <input type=\"time\" step=\"1\" />\n    TIME_MS: 'HH:mm:ss.SSS',\n    // <input type=\"time\" step=\"0.001\" />\n    WEEK: 'GGGG-[W]WW',\n    // <input type=\"week\" />\n    MONTH: 'YYYY-MM' // <input type=\"month\" />\n  };\n\n  return hooks;\n});\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\moment\\moment.js");

/***/ }),

/***/ "./node_modules/once/once.js":
/*!***********************************!*\
  !*** ./node_modules/once/once.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar wrappy = __webpack_require__(/*! wrappy */ \"./node_modules/wrappy/wrappy.js\");\nmodule.exports = wrappy(once);\nmodule.exports.strict = wrappy(onceStrict);\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function value() {\n      return once(this);\n    },\n    configurable: true\n  });\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function value() {\n      return onceStrict(this);\n    },\n    configurable: true\n  });\n});\nfunction once(fn) {\n  var f = function f() {\n    if (f.called) return f.value;\n    f.called = true;\n    return f.value = fn.apply(this, arguments);\n  };\n  f.called = false;\n  return f;\n}\nfunction onceStrict(fn) {\n  var f = function f() {\n    if (f.called) throw new Error(f.onceError);\n    f.called = true;\n    return f.value = fn.apply(this, arguments);\n  };\n  var name = fn.name || 'Function wrapped with `once`';\n  f.onceError = name + \" shouldn't be called more than once\";\n  f.called = false;\n  return f;\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\once\\once.js");

/***/ }),

/***/ "./node_modules/path-is-absolute/index.js":
/*!************************************************!*\
  !*** ./node_modules/path-is-absolute/index.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nfunction posix(path) {\n  return path.charAt(0) === '/';\n}\nfunction win32(path) {\n  // https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56\n  var splitDeviceRe = /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\n  var result = splitDeviceRe.exec(path);\n  var device = result[1] || '';\n  var isUnc = Boolean(device && device.charAt(1) !== ':');\n\n  // UNC paths are always absolute\n  return Boolean(result[2] || isUnc);\n}\nmodule.exports = process.platform === 'win32' ? win32 : posix;\nmodule.exports.posix = posix;\nmodule.exports.win32 = win32;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\path-is-absolute\\index.js");

/***/ }),

/***/ "./node_modules/picomatch/index.js":
/*!*****************************************!*\
  !*** ./node_modules/picomatch/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = __webpack_require__(/*! ./lib/picomatch */ \"./node_modules/picomatch/lib/picomatch.js\");\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\picomatch\\index.js");

/***/ }),

/***/ "./node_modules/picomatch/lib/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/picomatch/lib/constants.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nconst path = __webpack_require__(/*! path */ \"path\");\nconst WIN_SLASH = '\\\\\\\\/';\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n\n/**\n * Posix glob regex\n */\n\nconst DOT_LITERAL = '\\\\.';\nconst PLUS_LITERAL = '\\\\+';\nconst QMARK_LITERAL = '\\\\?';\nconst SLASH_LITERAL = '\\\\/';\nconst ONE_CHAR = '(?=.)';\nconst QMARK = '[^/]';\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\nconst POSIX_CHARS = {\n  DOT_LITERAL,\n  PLUS_LITERAL,\n  QMARK_LITERAL,\n  SLASH_LITERAL,\n  ONE_CHAR,\n  QMARK,\n  END_ANCHOR,\n  DOTS_SLASH,\n  NO_DOT,\n  NO_DOTS,\n  NO_DOT_SLASH,\n  NO_DOTS_SLASH,\n  QMARK_NO_DOT,\n  STAR,\n  START_ANCHOR\n};\n\n/**\n * Windows glob regex\n */\n\nconst WINDOWS_CHARS = _objectSpread(_objectSpread({}, POSIX_CHARS), {}, {\n  SLASH_LITERAL: `[${WIN_SLASH}]`,\n  QMARK: WIN_NO_SLASH,\n  STAR: `${WIN_NO_SLASH}*?`,\n  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n  NO_DOT: `(?!${DOT_LITERAL})`,\n  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\n});\n\n/**\n * POSIX Bracket Regex\n */\n\nconst POSIX_REGEX_SOURCE = {\n  alnum: 'a-zA-Z0-9',\n  alpha: 'a-zA-Z',\n  ascii: '\\\\x00-\\\\x7F',\n  blank: ' \\\\t',\n  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n  digit: '0-9',\n  graph: '\\\\x21-\\\\x7E',\n  lower: 'a-z',\n  print: '\\\\x20-\\\\x7E ',\n  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n  upper: 'A-Z',\n  word: 'A-Za-z0-9_',\n  xdigit: 'A-Fa-f0-9'\n};\nmodule.exports = {\n  MAX_LENGTH: 1024 * 64,\n  POSIX_REGEX_SOURCE,\n  // regular expressions\n  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n  REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n  // Replace globs with equivalent patterns to reduce parsing time.\n  REPLACEMENTS: {\n    '***': '*',\n    '**/**': '**',\n    '**/**/**': '**'\n  },\n  // Digits\n  CHAR_0: 48,\n  /* 0 */\n  CHAR_9: 57,\n  /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 65,\n  /* A */\n  CHAR_LOWERCASE_A: 97,\n  /* a */\n  CHAR_UPPERCASE_Z: 90,\n  /* Z */\n  CHAR_LOWERCASE_Z: 122,\n  /* z */\n\n  CHAR_LEFT_PARENTHESES: 40,\n  /* ( */\n  CHAR_RIGHT_PARENTHESES: 41,\n  /* ) */\n\n  CHAR_ASTERISK: 42,\n  /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: 38,\n  /* & */\n  CHAR_AT: 64,\n  /* @ */\n  CHAR_BACKWARD_SLASH: 92,\n  /* \\ */\n  CHAR_CARRIAGE_RETURN: 13,\n  /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: 94,\n  /* ^ */\n  CHAR_COLON: 58,\n  /* : */\n  CHAR_COMMA: 44,\n  /* , */\n  CHAR_DOT: 46,\n  /* . */\n  CHAR_DOUBLE_QUOTE: 34,\n  /* \" */\n  CHAR_EQUAL: 61,\n  /* = */\n  CHAR_EXCLAMATION_MARK: 33,\n  /* ! */\n  CHAR_FORM_FEED: 12,\n  /* \\f */\n  CHAR_FORWARD_SLASH: 47,\n  /* / */\n  CHAR_GRAVE_ACCENT: 96,\n  /* ` */\n  CHAR_HASH: 35,\n  /* # */\n  CHAR_HYPHEN_MINUS: 45,\n  /* - */\n  CHAR_LEFT_ANGLE_BRACKET: 60,\n  /* < */\n  CHAR_LEFT_CURLY_BRACE: 123,\n  /* { */\n  CHAR_LEFT_SQUARE_BRACKET: 91,\n  /* [ */\n  CHAR_LINE_FEED: 10,\n  /* \\n */\n  CHAR_NO_BREAK_SPACE: 160,\n  /* \\u00A0 */\n  CHAR_PERCENT: 37,\n  /* % */\n  CHAR_PLUS: 43,\n  /* + */\n  CHAR_QUESTION_MARK: 63,\n  /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: 62,\n  /* > */\n  CHAR_RIGHT_CURLY_BRACE: 125,\n  /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: 93,\n  /* ] */\n  CHAR_SEMICOLON: 59,\n  /* ; */\n  CHAR_SINGLE_QUOTE: 39,\n  /* ' */\n  CHAR_SPACE: 32,\n  /*   */\n  CHAR_TAB: 9,\n  /* \\t */\n  CHAR_UNDERSCORE: 95,\n  /* _ */\n  CHAR_VERTICAL_LINE: 124,\n  /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,\n  /* \\uFEFF */\n\n  SEP: path.sep,\n  /**\n   * Create EXTGLOB_CHARS\n   */\n\n  extglobChars(chars) {\n    return {\n      '!': {\n        type: 'negate',\n        open: '(?:(?!(?:',\n        close: `))${chars.STAR})`\n      },\n      '?': {\n        type: 'qmark',\n        open: '(?:',\n        close: ')?'\n      },\n      '+': {\n        type: 'plus',\n        open: '(?:',\n        close: ')+'\n      },\n      '*': {\n        type: 'star',\n        open: '(?:',\n        close: ')*'\n      },\n      '@': {\n        type: 'at',\n        open: '(?:',\n        close: ')'\n      }\n    };\n  },\n  /**\n   * Create GLOB_CHARS\n   */\n\n  globChars(win32) {\n    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n  }\n};\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\picomatch\\lib\\constants.js");

/***/ }),

/***/ "./node_modules/picomatch/lib/parse.js":
/*!*********************************************!*\
  !*** ./node_modules/picomatch/lib/parse.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nconst constants = __webpack_require__(/*! ./constants */ \"./node_modules/picomatch/lib/constants.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/picomatch/lib/utils.js\");\n\n/**\n * Constants\n */\n\nconst MAX_LENGTH = constants.MAX_LENGTH,\n  POSIX_REGEX_SOURCE = constants.POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS = constants.REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF = constants.REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS = constants.REPLACEMENTS;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n  args.sort();\n  const value = `[${args.join('-')}]`;\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n  input = REPLACEMENTS[input] || input;\n  const opts = _objectSpread({}, options);\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n  const bos = {\n    type: 'bos',\n    value: '',\n    output: opts.prepend || ''\n  };\n  const tokens = [bos];\n  const capture = opts.capture ? '' : '?:';\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(win32);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n  const DOT_LITERAL = PLATFORM_CHARS.DOT_LITERAL,\n    PLUS_LITERAL = PLATFORM_CHARS.PLUS_LITERAL,\n    SLASH_LITERAL = PLATFORM_CHARS.SLASH_LITERAL,\n    ONE_CHAR = PLATFORM_CHARS.ONE_CHAR,\n    DOTS_SLASH = PLATFORM_CHARS.DOTS_SLASH,\n    NO_DOT = PLATFORM_CHARS.NO_DOT,\n    NO_DOT_SLASH = PLATFORM_CHARS.NO_DOT_SLASH,\n    NO_DOTS_SLASH = PLATFORM_CHARS.NO_DOTS_SLASH,\n    QMARK = PLATFORM_CHARS.QMARK,\n    QMARK_NO_DOT = PLATFORM_CHARS.QMARK_NO_DOT,\n    STAR = PLATFORM_CHARS.STAR,\n    START_ANCHOR = PLATFORM_CHARS.START_ANCHOR;\n  const globstar = opts => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n  input = utils.removePrefix(input, state);\n  len = input.length;\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index] || '';\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n  const negate = () => {\n    let count = 1;\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n    if (count % 2 === 0) {\n      return false;\n    }\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || extglobs.length && (tok.type === 'pipe' || tok.type === 'paren');\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n    if (extglobs.length && tok.type !== 'paren') {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      prev.output = (prev.output || '') + tok.value;\n      return;\n    }\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n  const extglobOpen = (type, value) => {\n    const token = _objectSpread(_objectSpread({}, EXTGLOB_CHARS[value]), {}, {\n      conditions: 1,\n      inner: ''\n    });\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n    increment('parens');\n    push({\n      type,\n      value,\n      output: state.output ? '' : ONE_CHAR\n    });\n    push({\n      type: 'paren',\n      extglob: true,\n      value: advance(),\n      output\n    });\n    extglobs.push(token);\n  };\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n    let rest;\n    if (token.type === 'negate') {\n      let extglobStar = star;\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\n        // In this case, we need to parse the string and use it in the output of the original pattern.\n        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\n        //\n        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\n        const expression = parse(rest, _objectSpread(_objectSpread({}, options), {}, {\n          fastpaths: false\n        })).output;\n        output = token.close = `)${expression})${extglobStar})`;\n      }\n      if (token.prev.type === 'bos') {\n        state.negatedExtglob = true;\n      }\n    }\n    push({\n      type: 'paren',\n      extglob: true,\n      value,\n      output\n    });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : m ? '\\\\' : '';\n        });\n      }\n    }\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n      if (next === '.' || next === ';') {\n        continue;\n      }\n      if (!next) {\n        value += '\\\\';\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n      if (opts.unescape === true) {\n        value = advance();\n      } else {\n        value += advance();\n      }\n      if (state.brackets === 0) {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n      if (value === '[' && peek() !== ':' || value === '-' && peek() === ']') {\n        value = `\\\\${value}`;\n      }\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n      prev.value += value;\n      append({\n        value\n      });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({\n        value\n      });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({\n          type: 'text',\n          value\n        });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({\n        type: 'paren',\n        value\n      });\n      continue;\n    }\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n      push({\n        type: 'paren',\n        value,\n        output: state.parens ? ')' : '\\\\)'\n      });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n      push({\n        type: 'bracket',\n        value\n      });\n      continue;\n    }\n    if (value === ']') {\n      if (opts.nobracket === true || prev && prev.type === 'bracket' && prev.value.length === 1) {\n        push({\n          type: 'text',\n          value,\n          output: `\\\\${value}`\n        });\n        continue;\n      }\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n        push({\n          type: 'text',\n          value,\n          output: `\\\\${value}`\n        });\n        continue;\n      }\n      decrement('brackets');\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n      prev.value += value;\n      append({\n        value\n      });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n      braces.push(open);\n      push(open);\n      continue;\n    }\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n      if (opts.nobrace === true || !brace) {\n        push({\n          type: 'text',\n          value,\n          output: value\n        });\n        continue;\n      }\n      let output = ')';\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n        var _iterator = _createForOfIteratorHelper(toks),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            const t = _step.value;\n            state.output += t.output || t.value;\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      push({\n        type: 'brace',\n        value,\n        output\n      });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n      push({\n        type: 'comma',\n        value,\n        output\n      });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n      push({\n        type: 'slash',\n        value,\n        output: SLASH_LITERAL\n      });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n      if (state.braces + state.parens === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({\n          type: 'text',\n          value,\n          output: DOT_LITERAL\n        });\n        continue;\n      }\n      push({\n        type: 'dot',\n        value,\n        output: DOT_LITERAL\n      });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n        if (next === '<' && !utils.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n        if (prev.value === '(' && !/[!=<:]/.test(next) || next === '<' && !/<([!=]|\\w+>)/.test(remaining())) {\n          output = `\\\\${value}`;\n        }\n        push({\n          type: 'text',\n          value,\n          output\n        });\n        continue;\n      }\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({\n          type: 'qmark',\n          value,\n          output: QMARK_NO_DOT\n        });\n        continue;\n      }\n      push({\n        type: 'qmark',\n        value,\n        output: QMARK\n      });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n      if (prev && prev.value === '(' || opts.regex === false) {\n        push({\n          type: 'plus',\n          value,\n          output: PLUS_LITERAL\n        });\n        continue;\n      }\n      if (prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace') || state.parens > 0) {\n        push({\n          type: 'plus',\n          value\n        });\n        continue;\n      }\n      push({\n        type: 'plus',\n        value: PLUS_LITERAL\n      });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({\n          type: 'at',\n          extglob: true,\n          value,\n          output: ''\n        });\n        continue;\n      }\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n      if (opts.bash === true && (!isStart || rest[0] && rest[0] !== '/')) {\n        push({\n          type: 'star',\n          value,\n          output: ''\n        });\n        continue;\n      }\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({\n          type: 'star',\n          value,\n          output: ''\n        });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({\n          type: 'slash',\n          value: '/',\n          output: ''\n        });\n        continue;\n      }\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({\n          type: 'slash',\n          value: '/',\n          output: ''\n        });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n    const token = {\n      type: 'star',\n      value,\n      output: star\n    };\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n    push(token);\n  }\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({\n      type: 'maybe_slash',\n      value: '',\n      output: `${SLASH_LITERAL}?`\n    });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n    var _iterator2 = _createForOfIteratorHelper(state.tokens),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        const token = _step2.value;\n        state.output += token.output != null ? token.output : token.value;\n        if (token.suffix) {\n          state.output += token.suffix;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = _objectSpread({}, options);\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n  input = REPLACEMENTS[input] || input;\n  const win32 = utils.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const _constants$globChars = constants.globChars(win32),\n    DOT_LITERAL = _constants$globChars.DOT_LITERAL,\n    SLASH_LITERAL = _constants$globChars.SLASH_LITERAL,\n    ONE_CHAR = _constants$globChars.ONE_CHAR,\n    DOTS_SLASH = _constants$globChars.DOTS_SLASH,\n    NO_DOT = _constants$globChars.NO_DOT,\n    NO_DOTS = _constants$globChars.NO_DOTS,\n    NO_DOTS_SLASH = _constants$globChars.NO_DOTS_SLASH,\n    STAR = _constants$globChars.STAR,\n    START_ANCHOR = _constants$globChars.START_ANCHOR;\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = {\n    negated: false,\n    prefix: ''\n  };\n  let star = opts.bash === true ? '.*?' : STAR;\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n  const globstar = opts => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n      case '**':\n        return nodot + globstar(opts);\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n      default:\n        {\n          const match = /^(.*?)\\.(\\w+)$/.exec(str);\n          if (!match) return;\n          const source = create(match[1]);\n          if (!source) return;\n          return source + DOT_LITERAL + match[2];\n        }\n    }\n  };\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n  return source;\n};\nmodule.exports = parse;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\picomatch\\lib\\parse.js");

/***/ }),

/***/ "./node_modules/picomatch/lib/picomatch.js":
/*!*************************************************!*\
  !*** ./node_modules/picomatch/lib/picomatch.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nconst path = __webpack_require__(/*! path */ \"path\");\nconst scan = __webpack_require__(/*! ./scan */ \"./node_modules/picomatch/lib/scan.js\");\nconst parse = __webpack_require__(/*! ./parse */ \"./node_modules/picomatch/lib/parse.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/picomatch/lib/utils.js\");\nconst constants = __webpack_require__(/*! ./constants */ \"./node_modules/picomatch/lib/constants.js\");\nconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\n\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\n\nconst picomatch = (glob, options, returnState = false) => {\n  if (Array.isArray(glob)) {\n    const fns = glob.map(input => picomatch(input, options, returnState));\n    const arrayMatcher = str => {\n      var _iterator = _createForOfIteratorHelper(fns),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          const isMatch = _step.value;\n          const state = isMatch(str);\n          if (state) return state;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return false;\n    };\n    return arrayMatcher;\n  }\n  const isState = isObject(glob) && glob.tokens && glob.input;\n  if (glob === '' || typeof glob !== 'string' && !isState) {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n  const opts = options || {};\n  const posix = utils.isWindows(options);\n  const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);\n  const state = regex.state;\n  delete regex.state;\n  let isIgnored = () => false;\n  if (opts.ignore) {\n    const ignoreOpts = _objectSpread(_objectSpread({}, options), {}, {\n      ignore: null,\n      onMatch: null,\n      onResult: null\n    });\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n  const matcher = (input, returnObject = false) => {\n    const _picomatch$test = picomatch.test(input, regex, options, {\n        glob,\n        posix\n      }),\n      isMatch = _picomatch$test.isMatch,\n      match = _picomatch$test.match,\n      output = _picomatch$test.output;\n    const result = {\n      glob,\n      state,\n      regex,\n      posix,\n      input,\n      output,\n      match,\n      isMatch\n    };\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n    return returnObject ? result : true;\n  };\n  if (returnState) {\n    matcher.state = state;\n  }\n  return matcher;\n};\n\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\n\npicomatch.test = (input, regex, options, {\n  glob,\n  posix\n} = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n  if (input === '') {\n    return {\n      isMatch: false,\n      output: ''\n    };\n  }\n  const opts = options || {};\n  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n  let match = input === glob;\n  let output = match && format ? format(input) : input;\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n  return {\n    isMatch: Boolean(match),\n    match,\n    output\n  };\n};\n\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\n\npicomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(path.basename(input));\n};\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\n\npicomatch.parse = (pattern, options) => {\n  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n  return parse(pattern, _objectSpread(_objectSpread({}, options), {}, {\n    fastpaths: false\n  }));\n};\n\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * { prefix: '!./',\n *   input: '!./foo/*.js',\n *   start: 3,\n *   base: 'foo',\n *   glob: '*.js',\n *   isBrace: false,\n *   isBracket: false,\n *   isGlob: true,\n *   isExtglob: false,\n *   isGlobstar: false,\n *   negated: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\npicomatch.scan = (input, options) => scan(input, options);\n\n/**\n * Compile a regular expression from the `state` object returned by the\n * [parse()](#parse) method.\n *\n * @param {Object} `state`\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.\n * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.\n * @return {RegExp}\n * @api public\n */\n\npicomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {\n  if (returnOutput === true) {\n    return state.output;\n  }\n  const opts = options || {};\n  const prepend = opts.contains ? '' : '^';\n  const append = opts.contains ? '' : '$';\n  let source = `${prepend}(?:${state.output})${append}`;\n  if (state && state.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n  const regex = picomatch.toRegex(source, options);\n  if (returnState === true) {\n    regex.state = state;\n  }\n  return regex;\n};\n\n/**\n * Create a regular expression from a parsed glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const state = picomatch.parse('*.js');\n * // picomatch.compileRe(state[, options]);\n *\n * console.log(picomatch.compileRe(state));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `state` The object returned from the `.parse` method.\n * @param {Object} `options`\n * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.\n * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\npicomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n  let parsed = {\n    negated: false,\n    fastpaths: true\n  };\n  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    parsed.output = parse.fastpaths(input, options);\n  }\n  if (!parsed.output) {\n    parsed = parse(input, options);\n  }\n  return picomatch.compileRe(parsed, options, returnOutput, returnState);\n};\n\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\npicomatch.toRegex = (source, options) => {\n  try {\n    const opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n\n/**\n * Picomatch constants.\n * @return {Object}\n */\n\npicomatch.constants = constants;\n\n/**\n * Expose \"picomatch\"\n */\n\nmodule.exports = picomatch;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\picomatch\\lib\\picomatch.js");

/***/ }),

/***/ "./node_modules/picomatch/lib/scan.js":
/*!********************************************!*\
  !*** ./node_modules/picomatch/lib/scan.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst utils = __webpack_require__(/*! ./utils */ \"./node_modules/picomatch/lib/utils.js\");\nconst _require = __webpack_require__(/*! ./constants */ \"./node_modules/picomatch/lib/constants.js\"),\n  CHAR_ASTERISK = _require.CHAR_ASTERISK,\n  CHAR_AT = _require.CHAR_AT,\n  CHAR_BACKWARD_SLASH = _require.CHAR_BACKWARD_SLASH,\n  CHAR_COMMA = _require.CHAR_COMMA,\n  CHAR_DOT = _require.CHAR_DOT,\n  CHAR_EXCLAMATION_MARK = _require.CHAR_EXCLAMATION_MARK,\n  CHAR_FORWARD_SLASH = _require.CHAR_FORWARD_SLASH,\n  CHAR_LEFT_CURLY_BRACE = _require.CHAR_LEFT_CURLY_BRACE,\n  CHAR_LEFT_PARENTHESES = _require.CHAR_LEFT_PARENTHESES,\n  CHAR_LEFT_SQUARE_BRACKET = _require.CHAR_LEFT_SQUARE_BRACKET,\n  CHAR_PLUS = _require.CHAR_PLUS,\n  CHAR_QUESTION_MARK = _require.CHAR_QUESTION_MARK,\n  CHAR_RIGHT_CURLY_BRACE = _require.CHAR_RIGHT_CURLY_BRACE,\n  CHAR_RIGHT_PARENTHESES = _require.CHAR_RIGHT_PARENTHESES,\n  CHAR_RIGHT_SQUARE_BRACKET = _require.CHAR_RIGHT_SQUARE_BRACKET;\nconst isPathSeparator = code => {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\nconst depth = token => {\n  if (token.isPrefix !== true) {\n    token.depth = token.isGlobstar ? Infinity : 1;\n  }\n};\n\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not\n * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\n\nconst scan = (input, options) => {\n  const opts = options || {};\n  const length = input.length - 1;\n  const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n  const slashes = [];\n  const tokens = [];\n  const parts = [];\n  let str = input;\n  let index = -1;\n  let start = 0;\n  let lastIndex = 0;\n  let isBrace = false;\n  let isBracket = false;\n  let isGlob = false;\n  let isExtglob = false;\n  let isGlobstar = false;\n  let braceEscaped = false;\n  let backslashes = false;\n  let negated = false;\n  let negatedExtglob = false;\n  let finished = false;\n  let braces = 0;\n  let prev;\n  let code;\n  let token = {\n    value: '',\n    depth: 0,\n    isGlob: false\n  };\n  const eos = () => index >= length;\n  const peek = () => str.charCodeAt(index + 1);\n  const advance = () => {\n    prev = code;\n    return str.charCodeAt(++index);\n  };\n  while (index < length) {\n    code = advance();\n    let next;\n    if (code === CHAR_BACKWARD_SLASH) {\n      backslashes = token.backslashes = true;\n      code = advance();\n      if (code === CHAR_LEFT_CURLY_BRACE) {\n        braceEscaped = true;\n      }\n      continue;\n    }\n    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n      braces++;\n      while (eos() !== true && (code = advance())) {\n        if (code === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n        if (code === CHAR_LEFT_CURLY_BRACE) {\n          braces++;\n          continue;\n        }\n        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n          if (scanToEnd === true) {\n            continue;\n          }\n          break;\n        }\n        if (braceEscaped !== true && code === CHAR_COMMA) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n          if (scanToEnd === true) {\n            continue;\n          }\n          break;\n        }\n        if (code === CHAR_RIGHT_CURLY_BRACE) {\n          braces--;\n          if (braces === 0) {\n            braceEscaped = false;\n            isBrace = token.isBrace = true;\n            finished = true;\n            break;\n          }\n        }\n      }\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n    if (code === CHAR_FORWARD_SLASH) {\n      slashes.push(index);\n      tokens.push(token);\n      token = {\n        value: '',\n        depth: 0,\n        isGlob: false\n      };\n      if (finished === true) continue;\n      if (prev === CHAR_DOT && index === start + 1) {\n        start += 2;\n        continue;\n      }\n      lastIndex = index + 1;\n      continue;\n    }\n    if (opts.noext !== true) {\n      const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;\n      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\n        isGlob = token.isGlob = true;\n        isExtglob = token.isExtglob = true;\n        finished = true;\n        if (code === CHAR_EXCLAMATION_MARK && index === start) {\n          negatedExtglob = true;\n        }\n        if (scanToEnd === true) {\n          while (eos() !== true && (code = advance())) {\n            if (code === CHAR_BACKWARD_SLASH) {\n              backslashes = token.backslashes = true;\n              code = advance();\n              continue;\n            }\n            if (code === CHAR_RIGHT_PARENTHESES) {\n              isGlob = token.isGlob = true;\n              finished = true;\n              break;\n            }\n          }\n          continue;\n        }\n        break;\n      }\n    }\n    if (code === CHAR_ASTERISK) {\n      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\n      isGlob = token.isGlob = true;\n      finished = true;\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n    if (code === CHAR_QUESTION_MARK) {\n      isGlob = token.isGlob = true;\n      finished = true;\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n    if (code === CHAR_LEFT_SQUARE_BRACKET) {\n      while (eos() !== true && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          isBracket = token.isBracket = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n          break;\n        }\n      }\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n      negated = token.negated = true;\n      start++;\n      continue;\n    }\n    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n      isGlob = token.isGlob = true;\n      if (scanToEnd === true) {\n        while (eos() !== true && (code = advance())) {\n          if (code === CHAR_LEFT_PARENTHESES) {\n            backslashes = token.backslashes = true;\n            code = advance();\n            continue;\n          }\n          if (code === CHAR_RIGHT_PARENTHESES) {\n            finished = true;\n            break;\n          }\n        }\n        continue;\n      }\n      break;\n    }\n    if (isGlob === true) {\n      finished = true;\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n  }\n  if (opts.noext === true) {\n    isExtglob = false;\n    isGlob = false;\n  }\n  let base = str;\n  let prefix = '';\n  let glob = '';\n  if (start > 0) {\n    prefix = str.slice(0, start);\n    str = str.slice(start);\n    lastIndex -= start;\n  }\n  if (base && isGlob === true && lastIndex > 0) {\n    base = str.slice(0, lastIndex);\n    glob = str.slice(lastIndex);\n  } else if (isGlob === true) {\n    base = '';\n    glob = str;\n  } else {\n    base = str;\n  }\n  if (base && base !== '' && base !== '/' && base !== str) {\n    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n      base = base.slice(0, -1);\n    }\n  }\n  if (opts.unescape === true) {\n    if (glob) glob = utils.removeBackslashes(glob);\n    if (base && backslashes === true) {\n      base = utils.removeBackslashes(base);\n    }\n  }\n  const state = {\n    prefix,\n    input,\n    start,\n    base,\n    glob,\n    isBrace,\n    isBracket,\n    isGlob,\n    isExtglob,\n    isGlobstar,\n    negated,\n    negatedExtglob\n  };\n  if (opts.tokens === true) {\n    state.maxDepth = 0;\n    if (!isPathSeparator(code)) {\n      tokens.push(token);\n    }\n    state.tokens = tokens;\n  }\n  if (opts.parts === true || opts.tokens === true) {\n    let prevIndex;\n    for (let idx = 0; idx < slashes.length; idx++) {\n      const n = prevIndex ? prevIndex + 1 : start;\n      const i = slashes[idx];\n      const value = input.slice(n, i);\n      if (opts.tokens) {\n        if (idx === 0 && start !== 0) {\n          tokens[idx].isPrefix = true;\n          tokens[idx].value = prefix;\n        } else {\n          tokens[idx].value = value;\n        }\n        depth(tokens[idx]);\n        state.maxDepth += tokens[idx].depth;\n      }\n      if (idx !== 0 || value !== '') {\n        parts.push(value);\n      }\n      prevIndex = i;\n    }\n    if (prevIndex && prevIndex + 1 < input.length) {\n      const value = input.slice(prevIndex + 1);\n      parts.push(value);\n      if (opts.tokens) {\n        tokens[tokens.length - 1].value = value;\n        depth(tokens[tokens.length - 1]);\n        state.maxDepth += tokens[tokens.length - 1].depth;\n      }\n    }\n    state.slashes = slashes;\n    state.parts = parts;\n  }\n  return state;\n};\nmodule.exports = scan;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\picomatch\\lib\\scan.js");

/***/ }),

/***/ "./node_modules/picomatch/lib/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/picomatch/lib/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst path = __webpack_require__(/*! path */ \"path\");\nconst win32 = process.platform === 'win32';\nconst _require = __webpack_require__(/*! ./constants */ \"./node_modules/picomatch/lib/constants.js\"),\n  REGEX_BACKSLASH = _require.REGEX_BACKSLASH,\n  REGEX_REMOVE_BACKSLASH = _require.REGEX_REMOVE_BACKSLASH,\n  REGEX_SPECIAL_CHARS = _require.REGEX_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_GLOBAL = _require.REGEX_SPECIAL_CHARS_GLOBAL;\nexports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\nexports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\nexports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\nexports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\nexports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\nexports.removeBackslashes = str => {\n  return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n    return match === '\\\\' ? '' : match;\n  });\n};\nexports.supportsLookbehinds = () => {\n  const segs = process.version.slice(1).split('.').map(Number);\n  if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {\n    return true;\n  }\n  return false;\n};\nexports.isWindows = options => {\n  if (options && typeof options.windows === 'boolean') {\n    return options.windows;\n  }\n  return win32 === true || path.sep === '\\\\';\n};\nexports.escapeLast = (input, char, lastIdx) => {\n  const idx = input.lastIndexOf(char, lastIdx);\n  if (idx === -1) return input;\n  if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n  return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n};\nexports.removePrefix = (input, state = {}) => {\n  let output = input;\n  if (output.startsWith('./')) {\n    output = output.slice(2);\n    state.prefix = './';\n  }\n  return output;\n};\nexports.wrapOutput = (input, state = {}, options = {}) => {\n  const prepend = options.contains ? '' : '^';\n  const append = options.contains ? '' : '$';\n  let output = `${prepend}(?:${input})${append}`;\n  if (state.negated === true) {\n    output = `(?:^(?!${output}).*$)`;\n  }\n  return output;\n};\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\picomatch\\lib\\utils.js");

/***/ }),

/***/ "./node_modules/q/q.js":
/*!*****************************!*\
  !*** ./node_modules/q/q.js ***!
  \*****************************/
/***/ ((module) => {

"use strict";
eval("\n\n// vim:ts=4:sts=4:sw=4:\n/*!\n *\n * Copyright 2009-2017 Kris Kowal under the terms of the MIT\n * license found at https://github.com/kriskowal/q/blob/v1/LICENSE\n *\n * With parts by Tyler Close\n * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found\n * at http://www.opensource.org/licenses/mit-license.html\n * Forked at ref_send.js version: 2009-05-11\n *\n * With parts by Mark Miller\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n(function (definition) {\n  \"use strict\";\n\n  // This file will function properly as a <script> tag, or a module\n  // using CommonJS and NodeJS or RequireJS module formats.  In\n  // Common/Node/RequireJS, the module exports the Q API and when\n  // executed as a simple <script>, it creates a Q global instead.\n\n  // Montage Require\n  if (typeof bootstrap === \"function\") {\n    bootstrap(\"promise\", definition);\n\n    // CommonJS\n  } else if (true) {\n    module.exports = definition();\n\n    // RequireJS\n  } else { var previousQ, global; }\n})(function () {\n  \"use strict\";\n\n  var hasStacks = false;\n  try {\n    throw new Error();\n  } catch (e) {\n    hasStacks = !!e.stack;\n  }\n\n  // All code after this point will be filtered from stack traces reported\n  // by Q.\n  var qStartingLine = captureLine();\n  var qFileName;\n\n  // shims\n\n  // used for fallback in \"allResolved\"\n  var noop = function noop() {};\n\n  // Use the fastest possible means to execute a task in a future turn\n  // of the event loop.\n  var nextTick = function () {\n    // linked list of tasks (single, with head node)\n    var head = {\n      task: void 0,\n      next: null\n    };\n    var tail = head;\n    var flushing = false;\n    var requestTick = void 0;\n    var isNodeJS = false;\n    // queue for late tasks, used by unhandled rejection tracking\n    var laterQueue = [];\n    function flush() {\n      /* jshint loopfunc: true */\n      var task, domain;\n      while (head.next) {\n        head = head.next;\n        task = head.task;\n        head.task = void 0;\n        domain = head.domain;\n        if (domain) {\n          head.domain = void 0;\n          domain.enter();\n        }\n        runSingle(task, domain);\n      }\n      while (laterQueue.length) {\n        task = laterQueue.pop();\n        runSingle(task);\n      }\n      flushing = false;\n    }\n    // runs a single function in the async queue\n    function runSingle(task, domain) {\n      try {\n        task();\n      } catch (e) {\n        if (isNodeJS) {\n          // In node, uncaught exceptions are considered fatal errors.\n          // Re-throw them synchronously to interrupt flushing!\n\n          // Ensure continuation if the uncaught exception is suppressed\n          // listening \"uncaughtException\" events (as domains does).\n          // Continue in next event to avoid tick recursion.\n          if (domain) {\n            domain.exit();\n          }\n          setTimeout(flush, 0);\n          if (domain) {\n            domain.enter();\n          }\n          throw e;\n        } else {\n          // In browsers, uncaught exceptions are not fatal.\n          // Re-throw them asynchronously to avoid slow-downs.\n          setTimeout(function () {\n            throw e;\n          }, 0);\n        }\n      }\n      if (domain) {\n        domain.exit();\n      }\n    }\n    nextTick = function nextTick(task) {\n      tail = tail.next = {\n        task: task,\n        domain: isNodeJS && process.domain,\n        next: null\n      };\n      if (!flushing) {\n        flushing = true;\n        requestTick();\n      }\n    };\n    if (typeof process === \"object\" && process.toString() === \"[object process]\" && process.nextTick) {\n      // Ensure Q is in a real Node environment, with a `process.nextTick`.\n      // To see through fake Node environments:\n      // * Mocha test runner - exposes a `process` global without a `nextTick`\n      // * Browserify - exposes a `process.nexTick` function that uses\n      //   `setTimeout`. In this case `setImmediate` is preferred because\n      //    it is faster. Browserify's `process.toString()` yields\n      //   \"[object Object]\", while in a real Node environment\n      //   `process.toString()` yields \"[object process]\".\n      isNodeJS = true;\n      requestTick = function requestTick() {\n        process.nextTick(flush);\n      };\n    } else if (typeof setImmediate === \"function\") {\n      // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\n      if (typeof window !== \"undefined\") {\n        requestTick = setImmediate.bind(window, flush);\n      } else {\n        requestTick = function requestTick() {\n          setImmediate(flush);\n        };\n      }\n    } else if (typeof MessageChannel !== \"undefined\") {\n      // modern browsers\n      // http://www.nonblocking.io/2011/06/windownexttick.html\n      var channel = new MessageChannel();\n      // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\n      // working message ports the first time a page loads.\n      channel.port1.onmessage = function () {\n        requestTick = requestPortTick;\n        channel.port1.onmessage = flush;\n        flush();\n      };\n      var requestPortTick = function requestPortTick() {\n        // Opera requires us to provide a message payload, regardless of\n        // whether we use it.\n        channel.port2.postMessage(0);\n      };\n      requestTick = function requestTick() {\n        setTimeout(flush, 0);\n        requestPortTick();\n      };\n    } else {\n      // old browsers\n      requestTick = function requestTick() {\n        setTimeout(flush, 0);\n      };\n    }\n    // runs a task after all other tasks have been run\n    // this is useful for unhandled rejection tracking that needs to happen\n    // after all `then`d tasks have been run.\n    nextTick.runAfter = function (task) {\n      laterQueue.push(task);\n      if (!flushing) {\n        flushing = true;\n        requestTick();\n      }\n    };\n    return nextTick;\n  }();\n\n  // Attempt to make generics safe in the face of downstream\n  // modifications.\n  // There is no situation where this is necessary.\n  // If you need a security guarantee, these primordials need to be\n  // deeply frozen anyway, and if you don’t need a security guarantee,\n  // this is just plain paranoid.\n  // However, this **might** have the nice side-effect of reducing the size of\n  // the minified code by reducing x.call() to merely x()\n  // See Mark Miller’s explanation of what this does.\n  // http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n  var call = Function.call;\n  function uncurryThis(f) {\n    return function () {\n      return call.apply(f, arguments);\n    };\n  }\n  // This is equivalent, but slower:\n  // uncurryThis = Function_bind.bind(Function_bind.call);\n  // http://jsperf.com/uncurrythis\n\n  var array_slice = uncurryThis(Array.prototype.slice);\n  var array_reduce = uncurryThis(Array.prototype.reduce || function (callback, basis) {\n    var index = 0,\n      length = this.length;\n    // concerning the initial value, if one is not provided\n    if (arguments.length === 1) {\n      // seek to the first value in the array, accounting\n      // for the possibility that is is a sparse array\n      do {\n        if (index in this) {\n          basis = this[index++];\n          break;\n        }\n        if (++index >= length) {\n          throw new TypeError();\n        }\n      } while (1);\n    }\n    // reduce\n    for (; index < length; index++) {\n      // account for the possibility that the array is sparse\n      if (index in this) {\n        basis = callback(basis, this[index], index);\n      }\n    }\n    return basis;\n  });\n  var array_indexOf = uncurryThis(Array.prototype.indexOf || function (value) {\n    // not a very good shim, but good enough for our one use of it\n    for (var i = 0; i < this.length; i++) {\n      if (this[i] === value) {\n        return i;\n      }\n    }\n    return -1;\n  });\n  var array_map = uncurryThis(Array.prototype.map || function (callback, thisp) {\n    var self = this;\n    var collect = [];\n    array_reduce(self, function (undefined, value, index) {\n      collect.push(callback.call(thisp, value, index, self));\n    }, void 0);\n    return collect;\n  });\n  var object_create = Object.create || function (prototype) {\n    function Type() {}\n    Type.prototype = prototype;\n    return new Type();\n  };\n  var object_defineProperty = Object.defineProperty || function (obj, prop, descriptor) {\n    obj[prop] = descriptor.value;\n    return obj;\n  };\n  var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\n  var object_keys = Object.keys || function (object) {\n    var keys = [];\n    for (var key in object) {\n      if (object_hasOwnProperty(object, key)) {\n        keys.push(key);\n      }\n    }\n    return keys;\n  };\n  var object_toString = uncurryThis(Object.prototype.toString);\n  function isObject(value) {\n    return value === Object(value);\n  }\n\n  // generator related shims\n\n  // FIXME: Remove this function once ES6 generators are in SpiderMonkey.\n  function isStopIteration(exception) {\n    return object_toString(exception) === \"[object StopIteration]\" || exception instanceof QReturnValue;\n  }\n\n  // FIXME: Remove this helper and Q.return once ES6 generators are in\n  // SpiderMonkey.\n  var QReturnValue;\n  if (typeof ReturnValue !== \"undefined\") {\n    QReturnValue = ReturnValue;\n  } else {\n    QReturnValue = function QReturnValue(value) {\n      this.value = value;\n    };\n  }\n\n  // long stack traces\n\n  var STACK_JUMP_SEPARATOR = \"From previous event:\";\n  function makeStackTraceLong(error, promise) {\n    // If possible, transform the error stack trace by removing Node and Q\n    // cruft, then concatenating with the stack trace of `promise`. See #57.\n    if (hasStacks && promise.stack && typeof error === \"object\" && error !== null && error.stack) {\n      var stacks = [];\n      for (var p = promise; !!p; p = p.source) {\n        if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {\n          object_defineProperty(error, \"__minimumStackCounter__\", {\n            value: p.stackCounter,\n            configurable: true\n          });\n          stacks.unshift(p.stack);\n        }\n      }\n      stacks.unshift(error.stack);\n      var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n      var stack = filterStackString(concatedStacks);\n      object_defineProperty(error, \"stack\", {\n        value: stack,\n        configurable: true\n      });\n    }\n  }\n  function filterStackString(stackString) {\n    var lines = stackString.split(\"\\n\");\n    var desiredLines = [];\n    for (var i = 0; i < lines.length; ++i) {\n      var line = lines[i];\n      if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n        desiredLines.push(line);\n      }\n    }\n    return desiredLines.join(\"\\n\");\n  }\n  function isNodeFrame(stackLine) {\n    return stackLine.indexOf(\"(module.js:\") !== -1 || stackLine.indexOf(\"(node.js:\") !== -1;\n  }\n  function getFileNameAndLineNumber(stackLine) {\n    // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n    // In IE10 function name can have spaces (\"Anonymous function\") O_o\n    var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n    if (attempt1) {\n      return [attempt1[1], Number(attempt1[2])];\n    }\n\n    // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n    var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n    if (attempt2) {\n      return [attempt2[1], Number(attempt2[2])];\n    }\n\n    // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n    var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n    if (attempt3) {\n      return [attempt3[1], Number(attempt3[2])];\n    }\n  }\n  function isInternalFrame(stackLine) {\n    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n    if (!fileNameAndLineNumber) {\n      return false;\n    }\n    var fileName = fileNameAndLineNumber[0];\n    var lineNumber = fileNameAndLineNumber[1];\n    return fileName === qFileName && lineNumber >= qStartingLine && lineNumber <= qEndingLine;\n  }\n\n  // discover own file name and line number range for filtering stack\n  // traces\n  function captureLine() {\n    if (!hasStacks) {\n      return;\n    }\n    try {\n      throw new Error();\n    } catch (e) {\n      var lines = e.stack.split(\"\\n\");\n      var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n      var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n      if (!fileNameAndLineNumber) {\n        return;\n      }\n      qFileName = fileNameAndLineNumber[0];\n      return fileNameAndLineNumber[1];\n    }\n  }\n  function deprecate(callback, name, alternative) {\n    return function () {\n      if (typeof console !== \"undefined\" && typeof console.warn === \"function\") {\n        console.warn(name + \" is deprecated, use \" + alternative + \" instead.\", new Error(\"\").stack);\n      }\n      return callback.apply(callback, arguments);\n    };\n  }\n\n  // end of shims\n  // beginning of real work\n\n  /**\n   * Constructs a promise for an immediate reference, passes promises through, or\n   * coerces promises from different systems.\n   * @param value immediate reference or promise\n   */\n  function Q(value) {\n    // If the object is already a Promise, return it directly.  This enables\n    // the resolve function to both be used to created references from objects,\n    // but to tolerably coerce non-promises to promises.\n    if (value instanceof Promise) {\n      return value;\n    }\n\n    // assimilate thenables\n    if (isPromiseAlike(value)) {\n      return coerce(value);\n    } else {\n      return fulfill(value);\n    }\n  }\n  Q.resolve = Q;\n\n  /**\n   * Performs a task in a future turn of the event loop.\n   * @param {Function} task\n   */\n  Q.nextTick = nextTick;\n\n  /**\n   * Controls whether or not long stack traces will be on\n   */\n  Q.longStackSupport = false;\n\n  /**\n   * The counter is used to determine the stopping point for building\n   * long stack traces. In makeStackTraceLong we walk backwards through\n   * the linked list of promises, only stacks which were created before\n   * the rejection are concatenated.\n   */\n  var longStackCounter = 1;\n\n  // enable long stacks if Q_DEBUG is set\n  if (typeof process === \"object\" && process && process.env && process.env.Q_DEBUG) {\n    Q.longStackSupport = true;\n  }\n\n  /**\n   * Constructs a {promise, resolve, reject} object.\n   *\n   * `resolve` is a callback to invoke with a more resolved value for the\n   * promise. To fulfill the promise, invoke `resolve` with any value that is\n   * not a thenable. To reject the promise, invoke `resolve` with a rejected\n   * thenable, or invoke `reject` with the reason directly. To resolve the\n   * promise to another thenable, thus putting it in the same state, invoke\n   * `resolve` with that other thenable.\n   */\n  Q.defer = defer;\n  function defer() {\n    // if \"messages\" is an \"Array\", that indicates that the promise has not yet\n    // been resolved.  If it is \"undefined\", it has been resolved.  Each\n    // element of the messages array is itself an array of complete arguments to\n    // forward to the resolved promise.  We coerce the resolution value to a\n    // promise using the `resolve` function because it handles both fully\n    // non-thenable values and other thenables gracefully.\n    var messages = [],\n      progressListeners = [],\n      resolvedPromise;\n    var deferred = object_create(defer.prototype);\n    var promise = object_create(Promise.prototype);\n    promise.promiseDispatch = function (resolve, op, operands) {\n      var args = array_slice(arguments);\n      if (messages) {\n        messages.push(args);\n        if (op === \"when\" && operands[1]) {\n          // progress operand\n          progressListeners.push(operands[1]);\n        }\n      } else {\n        Q.nextTick(function () {\n          resolvedPromise.promiseDispatch.apply(resolvedPromise, args);\n        });\n      }\n    };\n\n    // XXX deprecated\n    promise.valueOf = function () {\n      if (messages) {\n        return promise;\n      }\n      var nearerValue = nearer(resolvedPromise);\n      if (isPromise(nearerValue)) {\n        resolvedPromise = nearerValue; // shorten chain\n      }\n\n      return nearerValue;\n    };\n    promise.inspect = function () {\n      if (!resolvedPromise) {\n        return {\n          state: \"pending\"\n        };\n      }\n      return resolvedPromise.inspect();\n    };\n    if (Q.longStackSupport && hasStacks) {\n      try {\n        throw new Error();\n      } catch (e) {\n        // NOTE: don't try to use `Error.captureStackTrace` or transfer the\n        // accessor around; that causes memory leaks as per GH-111. Just\n        // reify the stack trace as a string ASAP.\n        //\n        // At the same time, cut off the first line; it's always just\n        // \"[object Promise]\\n\", as per the `toString`.\n        promise.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n        promise.stackCounter = longStackCounter++;\n      }\n    }\n\n    // NOTE: we do the checks for `resolvedPromise` in each method, instead of\n    // consolidating them into `become`, since otherwise we'd create new\n    // promises with the lines `become(whatever(value))`. See e.g. GH-252.\n\n    function become(newPromise) {\n      resolvedPromise = newPromise;\n      if (Q.longStackSupport && hasStacks) {\n        // Only hold a reference to the new promise if long stacks\n        // are enabled to reduce memory usage\n        promise.source = newPromise;\n      }\n      array_reduce(messages, function (undefined, message) {\n        Q.nextTick(function () {\n          newPromise.promiseDispatch.apply(newPromise, message);\n        });\n      }, void 0);\n      messages = void 0;\n      progressListeners = void 0;\n    }\n    deferred.promise = promise;\n    deferred.resolve = function (value) {\n      if (resolvedPromise) {\n        return;\n      }\n      become(Q(value));\n    };\n    deferred.fulfill = function (value) {\n      if (resolvedPromise) {\n        return;\n      }\n      become(fulfill(value));\n    };\n    deferred.reject = function (reason) {\n      if (resolvedPromise) {\n        return;\n      }\n      become(reject(reason));\n    };\n    deferred.notify = function (progress) {\n      if (resolvedPromise) {\n        return;\n      }\n      array_reduce(progressListeners, function (undefined, progressListener) {\n        Q.nextTick(function () {\n          progressListener(progress);\n        });\n      }, void 0);\n    };\n    return deferred;\n  }\n\n  /**\n   * Creates a Node-style callback that will resolve or reject the deferred\n   * promise.\n   * @returns a nodeback\n   */\n  defer.prototype.makeNodeResolver = function () {\n    var self = this;\n    return function (error, value) {\n      if (error) {\n        self.reject(error);\n      } else if (arguments.length > 2) {\n        self.resolve(array_slice(arguments, 1));\n      } else {\n        self.resolve(value);\n      }\n    };\n  };\n\n  /**\n   * @param resolver {Function} a function that returns nothing and accepts\n   * the resolve, reject, and notify functions for a deferred.\n   * @returns a promise that may be resolved with the given resolve and reject\n   * functions, or rejected by a thrown exception in resolver\n   */\n  Q.Promise = promise; // ES6\n  Q.promise = promise;\n  function promise(resolver) {\n    if (typeof resolver !== \"function\") {\n      throw new TypeError(\"resolver must be a function.\");\n    }\n    var deferred = defer();\n    try {\n      resolver(deferred.resolve, deferred.reject, deferred.notify);\n    } catch (reason) {\n      deferred.reject(reason);\n    }\n    return deferred.promise;\n  }\n  promise.race = race; // ES6\n  promise.all = all; // ES6\n  promise.reject = reject; // ES6\n  promise.resolve = Q; // ES6\n\n  // XXX experimental.  This method is a way to denote that a local value is\n  // serializable and should be immediately dispatched to a remote upon request,\n  // instead of passing a reference.\n  Q.passByCopy = function (object) {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return object;\n  };\n  Promise.prototype.passByCopy = function () {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return this;\n  };\n\n  /**\n   * If two promises eventually fulfill to the same value, promises that value,\n   * but otherwise rejects.\n   * @param x {Any*}\n   * @param y {Any*}\n   * @returns {Any*} a promise for x and y if they are the same, but a rejection\n   * otherwise.\n   *\n   */\n  Q.join = function (x, y) {\n    return Q(x).join(y);\n  };\n  Promise.prototype.join = function (that) {\n    return Q([this, that]).spread(function (x, y) {\n      if (x === y) {\n        // TODO: \"===\" should be Object.is or equiv\n        return x;\n      } else {\n        throw new Error(\"Q can't join: not the same: \" + x + \" \" + y);\n      }\n    });\n  };\n\n  /**\n   * Returns a promise for the first of an array of promises to become settled.\n   * @param answers {Array[Any*]} promises to race\n   * @returns {Any*} the first promise to be settled\n   */\n  Q.race = race;\n  function race(answerPs) {\n    return promise(function (resolve, reject) {\n      // Switch to this once we can assume at least ES5\n      // answerPs.forEach(function (answerP) {\n      //     Q(answerP).then(resolve, reject);\n      // });\n      // Use this in the meantime\n      for (var i = 0, len = answerPs.length; i < len; i++) {\n        Q(answerPs[i]).then(resolve, reject);\n      }\n    });\n  }\n  Promise.prototype.race = function () {\n    return this.then(Q.race);\n  };\n\n  /**\n   * Constructs a Promise with a promise descriptor object and optional fallback\n   * function.  The descriptor contains methods like when(rejected), get(name),\n   * set(name, value), post(name, args), and delete(name), which all\n   * return either a value, a promise for a value, or a rejection.  The fallback\n   * accepts the operation name, a resolver, and any further arguments that would\n   * have been forwarded to the appropriate method above had a method been\n   * provided with the proper name.  The API makes no guarantees about the nature\n   * of the returned object, apart from that it is usable whereever promises are\n   * bought and sold.\n   */\n  Q.makePromise = Promise;\n  function Promise(descriptor, fallback, inspect) {\n    if (fallback === void 0) {\n      fallback = function fallback(op) {\n        return reject(new Error(\"Promise does not support operation: \" + op));\n      };\n    }\n    if (inspect === void 0) {\n      inspect = function inspect() {\n        return {\n          state: \"unknown\"\n        };\n      };\n    }\n    var promise = object_create(Promise.prototype);\n    promise.promiseDispatch = function (resolve, op, args) {\n      var result;\n      try {\n        if (descriptor[op]) {\n          result = descriptor[op].apply(promise, args);\n        } else {\n          result = fallback.call(promise, op, args);\n        }\n      } catch (exception) {\n        result = reject(exception);\n      }\n      if (resolve) {\n        resolve(result);\n      }\n    };\n    promise.inspect = inspect;\n\n    // XXX deprecated `valueOf` and `exception` support\n    if (inspect) {\n      var inspected = inspect();\n      if (inspected.state === \"rejected\") {\n        promise.exception = inspected.reason;\n      }\n      promise.valueOf = function () {\n        var inspected = inspect();\n        if (inspected.state === \"pending\" || inspected.state === \"rejected\") {\n          return promise;\n        }\n        return inspected.value;\n      };\n    }\n    return promise;\n  }\n  Promise.prototype.toString = function () {\n    return \"[object Promise]\";\n  };\n  Promise.prototype.then = function (fulfilled, rejected, progressed) {\n    var self = this;\n    var deferred = defer();\n    var done = false; // ensure the untrusted promise makes at most a\n    // single call to one of the callbacks\n\n    function _fulfilled(value) {\n      try {\n        return typeof fulfilled === \"function\" ? fulfilled(value) : value;\n      } catch (exception) {\n        return reject(exception);\n      }\n    }\n    function _rejected(exception) {\n      if (typeof rejected === \"function\") {\n        makeStackTraceLong(exception, self);\n        try {\n          return rejected(exception);\n        } catch (newException) {\n          return reject(newException);\n        }\n      }\n      return reject(exception);\n    }\n    function _progressed(value) {\n      return typeof progressed === \"function\" ? progressed(value) : value;\n    }\n    Q.nextTick(function () {\n      self.promiseDispatch(function (value) {\n        if (done) {\n          return;\n        }\n        done = true;\n        deferred.resolve(_fulfilled(value));\n      }, \"when\", [function (exception) {\n        if (done) {\n          return;\n        }\n        done = true;\n        deferred.resolve(_rejected(exception));\n      }]);\n    });\n\n    // Progress propagator need to be attached in the current tick.\n    self.promiseDispatch(void 0, \"when\", [void 0, function (value) {\n      var newValue;\n      var threw = false;\n      try {\n        newValue = _progressed(value);\n      } catch (e) {\n        threw = true;\n        if (Q.onerror) {\n          Q.onerror(e);\n        } else {\n          throw e;\n        }\n      }\n      if (!threw) {\n        deferred.notify(newValue);\n      }\n    }]);\n    return deferred.promise;\n  };\n  Q.tap = function (promise, callback) {\n    return Q(promise).tap(callback);\n  };\n\n  /**\n   * Works almost like \"finally\", but not called for rejections.\n   * Original resolution value is passed through callback unaffected.\n   * Callback may return a promise that will be awaited for.\n   * @param {Function} callback\n   * @returns {Q.Promise}\n   * @example\n   * doSomething()\n   *   .then(...)\n   *   .tap(console.log)\n   *   .then(...);\n   */\n  Promise.prototype.tap = function (callback) {\n    callback = Q(callback);\n    return this.then(function (value) {\n      return callback.fcall(value).thenResolve(value);\n    });\n  };\n\n  /**\n   * Registers an observer on a promise.\n   *\n   * Guarantees:\n   *\n   * 1. that fulfilled and rejected will be called only once.\n   * 2. that either the fulfilled callback or the rejected callback will be\n   *    called, but not both.\n   * 3. that fulfilled and rejected will not be called in this turn.\n   *\n   * @param value      promise or immediate reference to observe\n   * @param fulfilled  function to be called with the fulfilled value\n   * @param rejected   function to be called with the rejection exception\n   * @param progressed function to be called on any progress notifications\n   * @return promise for the return value from the invoked callback\n   */\n  Q.when = when;\n  function when(value, fulfilled, rejected, progressed) {\n    return Q(value).then(fulfilled, rejected, progressed);\n  }\n  Promise.prototype.thenResolve = function (value) {\n    return this.then(function () {\n      return value;\n    });\n  };\n  Q.thenResolve = function (promise, value) {\n    return Q(promise).thenResolve(value);\n  };\n  Promise.prototype.thenReject = function (reason) {\n    return this.then(function () {\n      throw reason;\n    });\n  };\n  Q.thenReject = function (promise, reason) {\n    return Q(promise).thenReject(reason);\n  };\n\n  /**\n   * If an object is not a promise, it is as \"near\" as possible.\n   * If a promise is rejected, it is as \"near\" as possible too.\n   * If it’s a fulfilled promise, the fulfillment value is nearer.\n   * If it’s a deferred promise and the deferred has been resolved, the\n   * resolution is \"nearer\".\n   * @param object\n   * @returns most resolved (nearest) form of the object\n   */\n\n  // XXX should we re-do this?\n  Q.nearer = nearer;\n  function nearer(value) {\n    if (isPromise(value)) {\n      var inspected = value.inspect();\n      if (inspected.state === \"fulfilled\") {\n        return inspected.value;\n      }\n    }\n    return value;\n  }\n\n  /**\n   * @returns whether the given object is a promise.\n   * Otherwise it is a fulfilled value.\n   */\n  Q.isPromise = isPromise;\n  function isPromise(object) {\n    return object instanceof Promise;\n  }\n  Q.isPromiseAlike = isPromiseAlike;\n  function isPromiseAlike(object) {\n    return isObject(object) && typeof object.then === \"function\";\n  }\n\n  /**\n   * @returns whether the given object is a pending promise, meaning not\n   * fulfilled or rejected.\n   */\n  Q.isPending = isPending;\n  function isPending(object) {\n    return isPromise(object) && object.inspect().state === \"pending\";\n  }\n  Promise.prototype.isPending = function () {\n    return this.inspect().state === \"pending\";\n  };\n\n  /**\n   * @returns whether the given object is a value or fulfilled\n   * promise.\n   */\n  Q.isFulfilled = isFulfilled;\n  function isFulfilled(object) {\n    return !isPromise(object) || object.inspect().state === \"fulfilled\";\n  }\n  Promise.prototype.isFulfilled = function () {\n    return this.inspect().state === \"fulfilled\";\n  };\n\n  /**\n   * @returns whether the given object is a rejected promise.\n   */\n  Q.isRejected = isRejected;\n  function isRejected(object) {\n    return isPromise(object) && object.inspect().state === \"rejected\";\n  }\n  Promise.prototype.isRejected = function () {\n    return this.inspect().state === \"rejected\";\n  };\n\n  //// BEGIN UNHANDLED REJECTION TRACKING\n\n  // This promise library consumes exceptions thrown in handlers so they can be\n  // handled by a subsequent promise.  The exceptions get added to this array when\n  // they are created, and removed when they are handled.  Note that in ES6 or\n  // shimmed environments, this would naturally be a `Set`.\n  var unhandledReasons = [];\n  var unhandledRejections = [];\n  var reportedUnhandledRejections = [];\n  var trackUnhandledRejections = true;\n  function resetUnhandledRejections() {\n    unhandledReasons.length = 0;\n    unhandledRejections.length = 0;\n    if (!trackUnhandledRejections) {\n      trackUnhandledRejections = true;\n    }\n  }\n  function trackRejection(promise, reason) {\n    if (!trackUnhandledRejections) {\n      return;\n    }\n    if (typeof process === \"object\" && typeof process.emit === \"function\") {\n      Q.nextTick.runAfter(function () {\n        if (array_indexOf(unhandledRejections, promise) !== -1) {\n          process.emit(\"unhandledRejection\", reason, promise);\n          reportedUnhandledRejections.push(promise);\n        }\n      });\n    }\n    unhandledRejections.push(promise);\n    if (reason && typeof reason.stack !== \"undefined\") {\n      unhandledReasons.push(reason.stack);\n    } else {\n      unhandledReasons.push(\"(no stack) \" + reason);\n    }\n  }\n  function untrackRejection(promise) {\n    if (!trackUnhandledRejections) {\n      return;\n    }\n    var at = array_indexOf(unhandledRejections, promise);\n    if (at !== -1) {\n      if (typeof process === \"object\" && typeof process.emit === \"function\") {\n        Q.nextTick.runAfter(function () {\n          var atReport = array_indexOf(reportedUnhandledRejections, promise);\n          if (atReport !== -1) {\n            process.emit(\"rejectionHandled\", unhandledReasons[at], promise);\n            reportedUnhandledRejections.splice(atReport, 1);\n          }\n        });\n      }\n      unhandledRejections.splice(at, 1);\n      unhandledReasons.splice(at, 1);\n    }\n  }\n  Q.resetUnhandledRejections = resetUnhandledRejections;\n  Q.getUnhandledReasons = function () {\n    // Make a copy so that consumers can't interfere with our internal state.\n    return unhandledReasons.slice();\n  };\n  Q.stopUnhandledRejectionTracking = function () {\n    resetUnhandledRejections();\n    trackUnhandledRejections = false;\n  };\n  resetUnhandledRejections();\n\n  //// END UNHANDLED REJECTION TRACKING\n\n  /**\n   * Constructs a rejected promise.\n   * @param reason value describing the failure\n   */\n  Q.reject = reject;\n  function reject(reason) {\n    var rejection = Promise({\n      \"when\": function when(rejected) {\n        // note that the error has been handled\n        if (rejected) {\n          untrackRejection(this);\n        }\n        return rejected ? rejected(reason) : this;\n      }\n    }, function fallback() {\n      return this;\n    }, function inspect() {\n      return {\n        state: \"rejected\",\n        reason: reason\n      };\n    });\n\n    // Note that the reason has not been handled.\n    trackRejection(rejection, reason);\n    return rejection;\n  }\n\n  /**\n   * Constructs a fulfilled promise for an immediate reference.\n   * @param value immediate reference\n   */\n  Q.fulfill = fulfill;\n  function fulfill(value) {\n    return Promise({\n      \"when\": function when() {\n        return value;\n      },\n      \"get\": function get(name) {\n        return value[name];\n      },\n      \"set\": function set(name, rhs) {\n        value[name] = rhs;\n      },\n      \"delete\": function _delete(name) {\n        delete value[name];\n      },\n      \"post\": function post(name, args) {\n        // Mark Miller proposes that post with no name should apply a\n        // promised function.\n        if (name === null || name === void 0) {\n          return value.apply(void 0, args);\n        } else {\n          return value[name].apply(value, args);\n        }\n      },\n      \"apply\": function apply(thisp, args) {\n        return value.apply(thisp, args);\n      },\n      \"keys\": function keys() {\n        return object_keys(value);\n      }\n    }, void 0, function inspect() {\n      return {\n        state: \"fulfilled\",\n        value: value\n      };\n    });\n  }\n\n  /**\n   * Converts thenables to Q promises.\n   * @param promise thenable promise\n   * @returns a Q promise\n   */\n  function coerce(promise) {\n    var deferred = defer();\n    Q.nextTick(function () {\n      try {\n        promise.then(deferred.resolve, deferred.reject, deferred.notify);\n      } catch (exception) {\n        deferred.reject(exception);\n      }\n    });\n    return deferred.promise;\n  }\n\n  /**\n   * Annotates an object such that it will never be\n   * transferred away from this process over any promise\n   * communication channel.\n   * @param object\n   * @returns promise a wrapping of that object that\n   * additionally responds to the \"isDef\" message\n   * without a rejection.\n   */\n  Q.master = master;\n  function master(object) {\n    return Promise({\n      \"isDef\": function isDef() {}\n    }, function fallback(op, args) {\n      return dispatch(object, op, args);\n    }, function () {\n      return Q(object).inspect();\n    });\n  }\n\n  /**\n   * Spreads the values of a promised array of arguments into the\n   * fulfillment callback.\n   * @param fulfilled callback that receives variadic arguments from the\n   * promised array\n   * @param rejected callback that receives the exception if the promise\n   * is rejected.\n   * @returns a promise for the return value or thrown exception of\n   * either callback.\n   */\n  Q.spread = spread;\n  function spread(value, fulfilled, rejected) {\n    return Q(value).spread(fulfilled, rejected);\n  }\n  Promise.prototype.spread = function (fulfilled, rejected) {\n    return this.all().then(function (array) {\n      return fulfilled.apply(void 0, array);\n    }, rejected);\n  };\n\n  /**\n   * The async function is a decorator for generator functions, turning\n   * them into asynchronous generators.  Although generators are only part\n   * of the newest ECMAScript 6 drafts, this code does not cause syntax\n   * errors in older engines.  This code should continue to work and will\n   * in fact improve over time as the language improves.\n   *\n   * ES6 generators are currently part of V8 version 3.19 with the\n   * --harmony-generators runtime flag enabled.  SpiderMonkey has had them\n   * for longer, but under an older Python-inspired form.  This function\n   * works on both kinds of generators.\n   *\n   * Decorates a generator function such that:\n   *  - it may yield promises\n   *  - execution will continue when that promise is fulfilled\n   *  - the value of the yield expression will be the fulfilled value\n   *  - it returns a promise for the return value (when the generator\n   *    stops iterating)\n   *  - the decorated function returns a promise for the return value\n   *    of the generator or the first rejected promise among those\n   *    yielded.\n   *  - if an error is thrown in the generator, it propagates through\n   *    every following yield until it is caught, or until it escapes\n   *    the generator function altogether, and is translated into a\n   *    rejection for the promise returned by the decorated generator.\n   */\n  Q.async = async;\n  function async(makeGenerator) {\n    return function () {\n      // when verb is \"send\", arg is a value\n      // when verb is \"throw\", arg is an exception\n      function continuer(verb, arg) {\n        var result;\n\n        // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only\n        // engine that has a deployed base of browsers that support generators.\n        // However, SM's generators use the Python-inspired semantics of\n        // outdated ES6 drafts.  We would like to support ES6, but we'd also\n        // like to make it possible to use generators in deployed browsers, so\n        // we also support Python-style generators.  At some point we can remove\n        // this block.\n\n        if (typeof StopIteration === \"undefined\") {\n          // ES6 Generators\n          try {\n            result = generator[verb](arg);\n          } catch (exception) {\n            return reject(exception);\n          }\n          if (result.done) {\n            return Q(result.value);\n          } else {\n            return when(result.value, callback, errback);\n          }\n        } else {\n          // SpiderMonkey Generators\n          // FIXME: Remove this case when SM does ES6 generators.\n          try {\n            result = generator[verb](arg);\n          } catch (exception) {\n            if (isStopIteration(exception)) {\n              return Q(exception.value);\n            } else {\n              return reject(exception);\n            }\n          }\n          return when(result, callback, errback);\n        }\n      }\n      var generator = makeGenerator.apply(this, arguments);\n      var callback = continuer.bind(continuer, \"next\");\n      var errback = continuer.bind(continuer, \"throw\");\n      return callback();\n    };\n  }\n\n  /**\n   * The spawn function is a small wrapper around async that immediately\n   * calls the generator and also ends the promise chain, so that any\n   * unhandled errors are thrown instead of forwarded to the error\n   * handler. This is useful because it's extremely common to run\n   * generators at the top-level to work with libraries.\n   */\n  Q.spawn = spawn;\n  function spawn(makeGenerator) {\n    Q.done(Q.async(makeGenerator)());\n  }\n\n  // FIXME: Remove this interface once ES6 generators are in SpiderMonkey.\n  /**\n   * Throws a ReturnValue exception to stop an asynchronous generator.\n   *\n   * This interface is a stop-gap measure to support generator return\n   * values in older Firefox/SpiderMonkey.  In browsers that support ES6\n   * generators like Chromium 29, just use \"return\" in your generator\n   * functions.\n   *\n   * @param value the return value for the surrounding generator\n   * @throws ReturnValue exception with the value.\n   * @example\n   * // ES6 style\n   * Q.async(function* () {\n   *      var foo = yield getFooPromise();\n   *      var bar = yield getBarPromise();\n   *      return foo + bar;\n   * })\n   * // Older SpiderMonkey style\n   * Q.async(function () {\n   *      var foo = yield getFooPromise();\n   *      var bar = yield getBarPromise();\n   *      Q.return(foo + bar);\n   * })\n   */\n  Q[\"return\"] = _return;\n  function _return(value) {\n    throw new QReturnValue(value);\n  }\n\n  /**\n   * The promised function decorator ensures that any promise arguments\n   * are settled and passed as values (`this` is also settled and passed\n   * as a value).  It will also ensure that the result of a function is\n   * always a promise.\n   *\n   * @example\n   * var add = Q.promised(function (a, b) {\n   *     return a + b;\n   * });\n   * add(Q(a), Q(B));\n   *\n   * @param {function} callback The function to decorate\n   * @returns {function} a function that has been decorated.\n   */\n  Q.promised = promised;\n  function promised(callback) {\n    return function () {\n      return spread([this, all(arguments)], function (self, args) {\n        return callback.apply(self, args);\n      });\n    };\n  }\n\n  /**\n   * sends a message to a value in a future turn\n   * @param object* the recipient\n   * @param op the name of the message operation, e.g., \"when\",\n   * @param args further arguments to be forwarded to the operation\n   * @returns result {Promise} a promise for the result of the operation\n   */\n  Q.dispatch = dispatch;\n  function dispatch(object, op, args) {\n    return Q(object).dispatch(op, args);\n  }\n  Promise.prototype.dispatch = function (op, args) {\n    var self = this;\n    var deferred = defer();\n    Q.nextTick(function () {\n      self.promiseDispatch(deferred.resolve, op, args);\n    });\n    return deferred.promise;\n  };\n\n  /**\n   * Gets the value of a property in a future turn.\n   * @param object    promise or immediate reference for target object\n   * @param name      name of property to get\n   * @return promise for the property value\n   */\n  Q.get = function (object, key) {\n    return Q(object).dispatch(\"get\", [key]);\n  };\n  Promise.prototype.get = function (key) {\n    return this.dispatch(\"get\", [key]);\n  };\n\n  /**\n   * Sets the value of a property in a future turn.\n   * @param object    promise or immediate reference for object object\n   * @param name      name of property to set\n   * @param value     new value of property\n   * @return promise for the return value\n   */\n  Q.set = function (object, key, value) {\n    return Q(object).dispatch(\"set\", [key, value]);\n  };\n  Promise.prototype.set = function (key, value) {\n    return this.dispatch(\"set\", [key, value]);\n  };\n\n  /**\n   * Deletes a property in a future turn.\n   * @param object    promise or immediate reference for target object\n   * @param name      name of property to delete\n   * @return promise for the return value\n   */\n  Q.del =\n  // XXX legacy\n  Q[\"delete\"] = function (object, key) {\n    return Q(object).dispatch(\"delete\", [key]);\n  };\n  Promise.prototype.del =\n  // XXX legacy\n  Promise.prototype[\"delete\"] = function (key) {\n    return this.dispatch(\"delete\", [key]);\n  };\n\n  /**\n   * Invokes a method in a future turn.\n   * @param object    promise or immediate reference for target object\n   * @param name      name of method to invoke\n   * @param value     a value to post, typically an array of\n   *                  invocation arguments for promises that\n   *                  are ultimately backed with `resolve` values,\n   *                  as opposed to those backed with URLs\n   *                  wherein the posted value can be any\n   *                  JSON serializable object.\n   * @return promise for the return value\n   */\n  // bound locally because it is used by other methods\n  Q.mapply =\n  // XXX As proposed by \"Redsandro\"\n  Q.post = function (object, name, args) {\n    return Q(object).dispatch(\"post\", [name, args]);\n  };\n  Promise.prototype.mapply =\n  // XXX As proposed by \"Redsandro\"\n  Promise.prototype.post = function (name, args) {\n    return this.dispatch(\"post\", [name, args]);\n  };\n\n  /**\n   * Invokes a method in a future turn.\n   * @param object    promise or immediate reference for target object\n   * @param name      name of method to invoke\n   * @param ...args   array of invocation arguments\n   * @return promise for the return value\n   */\n  Q.send =\n  // XXX Mark Miller's proposed parlance\n  Q.mcall =\n  // XXX As proposed by \"Redsandro\"\n  Q.invoke = function (object, name /*...args*/) {\n    return Q(object).dispatch(\"post\", [name, array_slice(arguments, 2)]);\n  };\n  Promise.prototype.send =\n  // XXX Mark Miller's proposed parlance\n  Promise.prototype.mcall =\n  // XXX As proposed by \"Redsandro\"\n  Promise.prototype.invoke = function (name /*...args*/) {\n    return this.dispatch(\"post\", [name, array_slice(arguments, 1)]);\n  };\n\n  /**\n   * Applies the promised function in a future turn.\n   * @param object    promise or immediate reference for target function\n   * @param args      array of application arguments\n   */\n  Q.fapply = function (object, args) {\n    return Q(object).dispatch(\"apply\", [void 0, args]);\n  };\n  Promise.prototype.fapply = function (args) {\n    return this.dispatch(\"apply\", [void 0, args]);\n  };\n\n  /**\n   * Calls the promised function in a future turn.\n   * @param object    promise or immediate reference for target function\n   * @param ...args   array of application arguments\n   */\n  Q[\"try\"] = Q.fcall = function (object /* ...args*/) {\n    return Q(object).dispatch(\"apply\", [void 0, array_slice(arguments, 1)]);\n  };\n  Promise.prototype.fcall = function /*...args*/\n  () {\n    return this.dispatch(\"apply\", [void 0, array_slice(arguments)]);\n  };\n\n  /**\n   * Binds the promised function, transforming return values into a fulfilled\n   * promise and thrown errors into a rejected one.\n   * @param object    promise or immediate reference for target function\n   * @param ...args   array of application arguments\n   */\n  Q.fbind = function (object /*...args*/) {\n    var promise = Q(object);\n    var args = array_slice(arguments, 1);\n    return function fbound() {\n      return promise.dispatch(\"apply\", [this, args.concat(array_slice(arguments))]);\n    };\n  };\n  Promise.prototype.fbind = function /*...args*/\n  () {\n    var promise = this;\n    var args = array_slice(arguments);\n    return function fbound() {\n      return promise.dispatch(\"apply\", [this, args.concat(array_slice(arguments))]);\n    };\n  };\n\n  /**\n   * Requests the names of the owned properties of a promised\n   * object in a future turn.\n   * @param object    promise or immediate reference for target object\n   * @return promise for the keys of the eventually settled object\n   */\n  Q.keys = function (object) {\n    return Q(object).dispatch(\"keys\", []);\n  };\n  Promise.prototype.keys = function () {\n    return this.dispatch(\"keys\", []);\n  };\n\n  /**\n   * Turns an array of promises into a promise for an array.  If any of\n   * the promises gets rejected, the whole array is rejected immediately.\n   * @param {Array*} an array (or promise for an array) of values (or\n   * promises for values)\n   * @returns a promise for an array of the corresponding values\n   */\n  // By Mark Miller\n  // http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\n  Q.all = all;\n  function all(promises) {\n    return when(promises, function (promises) {\n      var pendingCount = 0;\n      var deferred = defer();\n      array_reduce(promises, function (undefined, promise, index) {\n        var snapshot;\n        if (isPromise(promise) && (snapshot = promise.inspect()).state === \"fulfilled\") {\n          promises[index] = snapshot.value;\n        } else {\n          ++pendingCount;\n          when(promise, function (value) {\n            promises[index] = value;\n            if (--pendingCount === 0) {\n              deferred.resolve(promises);\n            }\n          }, deferred.reject, function (progress) {\n            deferred.notify({\n              index: index,\n              value: progress\n            });\n          });\n        }\n      }, void 0);\n      if (pendingCount === 0) {\n        deferred.resolve(promises);\n      }\n      return deferred.promise;\n    });\n  }\n  Promise.prototype.all = function () {\n    return all(this);\n  };\n\n  /**\n   * Returns the first resolved promise of an array. Prior rejected promises are\n   * ignored.  Rejects only if all promises are rejected.\n   * @param {Array*} an array containing values or promises for values\n   * @returns a promise fulfilled with the value of the first resolved promise,\n   * or a rejected promise if all promises are rejected.\n   */\n  Q.any = any;\n  function any(promises) {\n    if (promises.length === 0) {\n      return Q.resolve();\n    }\n    var deferred = Q.defer();\n    var pendingCount = 0;\n    array_reduce(promises, function (prev, current, index) {\n      var promise = promises[index];\n      pendingCount++;\n      when(promise, onFulfilled, onRejected, onProgress);\n      function onFulfilled(result) {\n        deferred.resolve(result);\n      }\n      function onRejected(err) {\n        pendingCount--;\n        if (pendingCount === 0) {\n          var rejection = err || new Error(\"\" + err);\n          rejection.message = \"Q can't get fulfillment value from any promise, all \" + \"promises were rejected. Last error message: \" + rejection.message;\n          deferred.reject(rejection);\n        }\n      }\n      function onProgress(progress) {\n        deferred.notify({\n          index: index,\n          value: progress\n        });\n      }\n    }, undefined);\n    return deferred.promise;\n  }\n  Promise.prototype.any = function () {\n    return any(this);\n  };\n\n  /**\n   * Waits for all promises to be settled, either fulfilled or\n   * rejected.  This is distinct from `all` since that would stop\n   * waiting at the first rejection.  The promise returned by\n   * `allResolved` will never be rejected.\n   * @param promises a promise for an array (or an array) of promises\n   * (or values)\n   * @return a promise for an array of promises\n   */\n  Q.allResolved = deprecate(allResolved, \"allResolved\", \"allSettled\");\n  function allResolved(promises) {\n    return when(promises, function (promises) {\n      promises = array_map(promises, Q);\n      return when(all(array_map(promises, function (promise) {\n        return when(promise, noop, noop);\n      })), function () {\n        return promises;\n      });\n    });\n  }\n  Promise.prototype.allResolved = function () {\n    return allResolved(this);\n  };\n\n  /**\n   * @see Promise#allSettled\n   */\n  Q.allSettled = allSettled;\n  function allSettled(promises) {\n    return Q(promises).allSettled();\n  }\n\n  /**\n   * Turns an array of promises into a promise for an array of their states (as\n   * returned by `inspect`) when they have all settled.\n   * @param {Array[Any*]} values an array (or promise for an array) of values (or\n   * promises for values)\n   * @returns {Array[State]} an array of states for the respective values.\n   */\n  Promise.prototype.allSettled = function () {\n    return this.then(function (promises) {\n      return all(array_map(promises, function (promise) {\n        promise = Q(promise);\n        function regardless() {\n          return promise.inspect();\n        }\n        return promise.then(regardless, regardless);\n      }));\n    });\n  };\n\n  /**\n   * Captures the failure of a promise, giving an oportunity to recover\n   * with a callback.  If the given promise is fulfilled, the returned\n   * promise is fulfilled.\n   * @param {Any*} promise for something\n   * @param {Function} callback to fulfill the returned promise if the\n   * given promise is rejected\n   * @returns a promise for the return value of the callback\n   */\n  Q.fail =\n  // XXX legacy\n  Q[\"catch\"] = function (object, rejected) {\n    return Q(object).then(void 0, rejected);\n  };\n  Promise.prototype.fail =\n  // XXX legacy\n  Promise.prototype[\"catch\"] = function (rejected) {\n    return this.then(void 0, rejected);\n  };\n\n  /**\n   * Attaches a listener that can respond to progress notifications from a\n   * promise's originating deferred. This listener receives the exact arguments\n   * passed to ``deferred.notify``.\n   * @param {Any*} promise for something\n   * @param {Function} callback to receive any progress notifications\n   * @returns the given promise, unchanged\n   */\n  Q.progress = progress;\n  function progress(object, progressed) {\n    return Q(object).then(void 0, void 0, progressed);\n  }\n  Promise.prototype.progress = function (progressed) {\n    return this.then(void 0, void 0, progressed);\n  };\n\n  /**\n   * Provides an opportunity to observe the settling of a promise,\n   * regardless of whether the promise is fulfilled or rejected.  Forwards\n   * the resolution to the returned promise when the callback is done.\n   * The callback can return a promise to defer completion.\n   * @param {Any*} promise\n   * @param {Function} callback to observe the resolution of the given\n   * promise, takes no arguments.\n   * @returns a promise for the resolution of the given promise when\n   * ``fin`` is done.\n   */\n  Q.fin =\n  // XXX legacy\n  Q[\"finally\"] = function (object, callback) {\n    return Q(object)[\"finally\"](callback);\n  };\n  Promise.prototype.fin =\n  // XXX legacy\n  Promise.prototype[\"finally\"] = function (callback) {\n    if (!callback || typeof callback.apply !== \"function\") {\n      throw new Error(\"Q can't apply finally callback\");\n    }\n    callback = Q(callback);\n    return this.then(function (value) {\n      return callback.fcall().then(function () {\n        return value;\n      });\n    }, function (reason) {\n      // TODO attempt to recycle the rejection with \"this\".\n      return callback.fcall().then(function () {\n        throw reason;\n      });\n    });\n  };\n\n  /**\n   * Terminates a chain of promises, forcing rejections to be\n   * thrown as exceptions.\n   * @param {Any*} promise at the end of a chain of promises\n   * @returns nothing\n   */\n  Q.done = function (object, fulfilled, rejected, progress) {\n    return Q(object).done(fulfilled, rejected, progress);\n  };\n  Promise.prototype.done = function (fulfilled, rejected, progress) {\n    var onUnhandledError = function onUnhandledError(error) {\n      // forward to a future turn so that ``when``\n      // does not catch it and turn it into a rejection.\n      Q.nextTick(function () {\n        makeStackTraceLong(error, promise);\n        if (Q.onerror) {\n          Q.onerror(error);\n        } else {\n          throw error;\n        }\n      });\n    };\n\n    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.\n    var promise = fulfilled || rejected || progress ? this.then(fulfilled, rejected, progress) : this;\n    if (typeof process === \"object\" && process && process.domain) {\n      onUnhandledError = process.domain.bind(onUnhandledError);\n    }\n    promise.then(void 0, onUnhandledError);\n  };\n\n  /**\n   * Causes a promise to be rejected if it does not get fulfilled before\n   * some milliseconds time out.\n   * @param {Any*} promise\n   * @param {Number} milliseconds timeout\n   * @param {Any*} custom error message or Error object (optional)\n   * @returns a promise for the resolution of the given promise if it is\n   * fulfilled before the timeout, otherwise rejected.\n   */\n  Q.timeout = function (object, ms, error) {\n    return Q(object).timeout(ms, error);\n  };\n  Promise.prototype.timeout = function (ms, error) {\n    var deferred = defer();\n    var timeoutId = setTimeout(function () {\n      if (!error || \"string\" === typeof error) {\n        error = new Error(error || \"Timed out after \" + ms + \" ms\");\n        error.code = \"ETIMEDOUT\";\n      }\n      deferred.reject(error);\n    }, ms);\n    this.then(function (value) {\n      clearTimeout(timeoutId);\n      deferred.resolve(value);\n    }, function (exception) {\n      clearTimeout(timeoutId);\n      deferred.reject(exception);\n    }, deferred.notify);\n    return deferred.promise;\n  };\n\n  /**\n   * Returns a promise for the given value (or promised value), some\n   * milliseconds after it resolved. Passes rejections immediately.\n   * @param {Any*} promise\n   * @param {Number} milliseconds\n   * @returns a promise for the resolution of the given promise after milliseconds\n   * time has elapsed since the resolution of the given promise.\n   * If the given promise rejects, that is passed immediately.\n   */\n  Q.delay = function (object, timeout) {\n    if (timeout === void 0) {\n      timeout = object;\n      object = void 0;\n    }\n    return Q(object).delay(timeout);\n  };\n  Promise.prototype.delay = function (timeout) {\n    return this.then(function (value) {\n      var deferred = defer();\n      setTimeout(function () {\n        deferred.resolve(value);\n      }, timeout);\n      return deferred.promise;\n    });\n  };\n\n  /**\n   * Passes a continuation to a Node function, which is called with the given\n   * arguments provided as an array, and returns a promise.\n   *\n   *      Q.nfapply(FS.readFile, [__filename])\n   *      .then(function (content) {\n   *      })\n   *\n   */\n  Q.nfapply = function (callback, args) {\n    return Q(callback).nfapply(args);\n  };\n  Promise.prototype.nfapply = function (args) {\n    var deferred = defer();\n    var nodeArgs = array_slice(args);\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n  };\n\n  /**\n   * Passes a continuation to a Node function, which is called with the given\n   * arguments provided individually, and returns a promise.\n   * @example\n   * Q.nfcall(FS.readFile, __filename)\n   * .then(function (content) {\n   * })\n   *\n   */\n  Q.nfcall = function (callback /*...args*/) {\n    var args = array_slice(arguments, 1);\n    return Q(callback).nfapply(args);\n  };\n  Promise.prototype.nfcall = function /*...args*/\n  () {\n    var nodeArgs = array_slice(arguments);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n  };\n\n  /**\n   * Wraps a NodeJS continuation passing function and returns an equivalent\n   * version that returns a promise.\n   * @example\n   * Q.nfbind(FS.readFile, __filename)(\"utf-8\")\n   * .then(console.log)\n   * .done()\n   */\n  Q.nfbind = Q.denodeify = function (callback /*...args*/) {\n    if (callback === undefined) {\n      throw new Error(\"Q can't wrap an undefined function\");\n    }\n    var baseArgs = array_slice(arguments, 1);\n    return function () {\n      var nodeArgs = baseArgs.concat(array_slice(arguments));\n      var deferred = defer();\n      nodeArgs.push(deferred.makeNodeResolver());\n      Q(callback).fapply(nodeArgs).fail(deferred.reject);\n      return deferred.promise;\n    };\n  };\n  Promise.prototype.nfbind = Promise.prototype.denodeify = function /*...args*/\n  () {\n    var args = array_slice(arguments);\n    args.unshift(this);\n    return Q.denodeify.apply(void 0, args);\n  };\n  Q.nbind = function (callback, thisp /*...args*/) {\n    var baseArgs = array_slice(arguments, 2);\n    return function () {\n      var nodeArgs = baseArgs.concat(array_slice(arguments));\n      var deferred = defer();\n      nodeArgs.push(deferred.makeNodeResolver());\n      function bound() {\n        return callback.apply(thisp, arguments);\n      }\n      Q(bound).fapply(nodeArgs).fail(deferred.reject);\n      return deferred.promise;\n    };\n  };\n  Promise.prototype.nbind = function /*thisp, ...args*/\n  () {\n    var args = array_slice(arguments, 0);\n    args.unshift(this);\n    return Q.nbind.apply(void 0, args);\n  };\n\n  /**\n   * Calls a method of a Node-style object that accepts a Node-style\n   * callback with a given array of arguments, plus a provided callback.\n   * @param object an object that has the named method\n   * @param {String} name name of the method of object\n   * @param {Array} args arguments to pass to the method; the callback\n   * will be provided by Q and appended to these arguments.\n   * @returns a promise for the value or error\n   */\n  Q.nmapply =\n  // XXX As proposed by \"Redsandro\"\n  Q.npost = function (object, name, args) {\n    return Q(object).npost(name, args);\n  };\n  Promise.prototype.nmapply =\n  // XXX As proposed by \"Redsandro\"\n  Promise.prototype.npost = function (name, args) {\n    var nodeArgs = array_slice(args || []);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n  };\n\n  /**\n   * Calls a method of a Node-style object that accepts a Node-style\n   * callback, forwarding the given variadic arguments, plus a provided\n   * callback argument.\n   * @param object an object that has the named method\n   * @param {String} name name of the method of object\n   * @param ...args arguments to pass to the method; the callback will\n   * be provided by Q and appended to these arguments.\n   * @returns a promise for the value or error\n   */\n  Q.nsend =\n  // XXX Based on Mark Miller's proposed \"send\"\n  Q.nmcall =\n  // XXX Based on \"Redsandro's\" proposal\n  Q.ninvoke = function (object, name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 2);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    Q(object).dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n  };\n  Promise.prototype.nsend =\n  // XXX Based on Mark Miller's proposed \"send\"\n  Promise.prototype.nmcall =\n  // XXX Based on \"Redsandro's\" proposal\n  Promise.prototype.ninvoke = function (name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 1);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n  };\n\n  /**\n   * If a function would like to support both Node continuation-passing-style and\n   * promise-returning-style, it can end its internal promise chain with\n   * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user\n   * elects to use a nodeback, the result will be sent there.  If they do not\n   * pass a nodeback, they will receive the result promise.\n   * @param object a result (or a promise for a result)\n   * @param {Function} nodeback a Node.js-style callback\n   * @returns either the promise or nothing\n   */\n  Q.nodeify = nodeify;\n  function nodeify(object, nodeback) {\n    return Q(object).nodeify(nodeback);\n  }\n  Promise.prototype.nodeify = function (nodeback) {\n    if (nodeback) {\n      this.then(function (value) {\n        Q.nextTick(function () {\n          nodeback(null, value);\n        });\n      }, function (error) {\n        Q.nextTick(function () {\n          nodeback(error);\n        });\n      });\n    } else {\n      return this;\n    }\n  };\n  Q.noConflict = function () {\n    throw new Error(\"Q.noConflict only works when Q is used as a global\");\n  };\n\n  // All code before this point will be filtered from stack traces.\n  var qEndingLine = captureLine();\n  return Q;\n});\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\q\\q.js");

/***/ }),

/***/ "./node_modules/queue-microtask/index.js":
/*!***********************************************!*\
  !*** ./node_modules/queue-microtask/index.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nlet promise;\nmodule.exports = typeof queueMicrotask === 'function' ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global)\n// reuse resolved promise, and allocate it lazily\n: cb => (promise || (promise = Promise.resolve())).then(cb).catch(err => setTimeout(() => {\n  throw err;\n}, 0));\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\queue-microtask\\index.js");

/***/ }),

/***/ "./node_modules/reusify/reusify.js":
/*!*****************************************!*\
  !*** ./node_modules/reusify/reusify.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
eval("\n\nfunction reusify(Constructor) {\n  var head = new Constructor();\n  var tail = head;\n  function get() {\n    var current = head;\n    if (current.next) {\n      head = current.next;\n    } else {\n      head = new Constructor();\n      tail = head;\n    }\n    current.next = null;\n    return current;\n  }\n  function release(obj) {\n    tail.next = obj;\n    tail = obj;\n  }\n  return {\n    get: get,\n    release: release\n  };\n}\nmodule.exports = reusify;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\reusify\\reusify.js");

/***/ }),

/***/ "./node_modules/run-parallel/index.js":
/*!********************************************!*\
  !*** ./node_modules/run-parallel/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nmodule.exports = runParallel;\nconst queueMicrotask = __webpack_require__(/*! queue-microtask */ \"./node_modules/queue-microtask/index.js\");\nfunction runParallel(tasks, cb) {\n  let results, pending, keys;\n  let isSync = true;\n  if (Array.isArray(tasks)) {\n    results = [];\n    pending = tasks.length;\n  } else {\n    keys = Object.keys(tasks);\n    results = {};\n    pending = keys.length;\n  }\n  function done(err) {\n    function end() {\n      if (cb) cb(err, results);\n      cb = null;\n    }\n    if (isSync) queueMicrotask(end);else end();\n  }\n  function each(i, err, result) {\n    results[i] = result;\n    if (--pending === 0 || err) {\n      done(err);\n    }\n  }\n  if (!pending) {\n    // empty\n    done(null);\n  } else if (keys) {\n    // object\n    keys.forEach(function (key) {\n      tasks[key](function (err, result) {\n        each(key, err, result);\n      });\n    });\n  } else {\n    // array\n    tasks.forEach(function (task, i) {\n      task(function (err, result) {\n        each(i, err, result);\n      });\n    });\n  }\n  isSync = false;\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\run-parallel\\index.js");

/***/ }),

/***/ "./node_modules/shelljs/commands.js":
/*!******************************************!*\
  !*** ./node_modules/shelljs/commands.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = ['cat', 'cd', 'chmod', 'cp', 'dirs', 'echo', 'exec', 'find', 'grep', 'head', 'ln', 'ls', 'mkdir', 'mv', 'pwd', 'rm', 'sed', 'set', 'sort', 'tail', 'tempdir', 'test', 'to', 'toEnd', 'touch', 'uniq', 'which'];\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\commands.js");

/***/ }),

/***/ "./node_modules/shelljs/node_modules/brace-expansion/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/shelljs/node_modules/brace-expansion/index.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar concatMap = __webpack_require__(/*! concat-map */ \"./node_modules/concat-map/index.js\");\nvar balanced = __webpack_require__(/*! balanced-match */ \"./node_modules/balanced-match/index.js\");\nmodule.exports = expandTop;\nvar escSlash = '\\0SLASH' + Math.random() + '\\0';\nvar escOpen = '\\0OPEN' + Math.random() + '\\0';\nvar escClose = '\\0CLOSE' + Math.random() + '\\0';\nvar escComma = '\\0COMMA' + Math.random() + '\\0';\nvar escPeriod = '\\0PERIOD' + Math.random() + '\\0';\nfunction numeric(str) {\n  return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);\n}\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash).split('\\\\{').join(escOpen).split('\\\\}').join(escClose).split('\\\\,').join(escComma).split('\\\\.').join(escPeriod);\n}\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\').split(escOpen).join('{').split(escClose).join('}').split(escComma).join(',').split(escPeriod).join('.');\n}\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str) return [''];\n  var parts = [];\n  var m = balanced('{', '}', str);\n  if (!m) return str.split(',');\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n  p[p.length - 1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length - 1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n  parts.push.apply(parts, p);\n  return parts;\n}\nfunction expandTop(str) {\n  if (!str) return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\nfunction identity(e) {\n  return e;\n}\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\nfunction expand(str, isTop) {\n  var expansions = [];\n  var m = balanced('{', '}', str);\n  if (!m || /\\$$/.test(m.pre)) return [str];\n  var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isSequence = isNumericSequence || isAlphaSequence;\n  var isOptions = m.body.indexOf(',') >= 0;\n  if (!isSequence && !isOptions) {\n    // {a},b}\n    if (m.post.match(/,.*\\}/)) {\n      str = m.pre + '{' + m.body + escClose + m.post;\n      return expand(str);\n    }\n    return [str];\n  }\n  var n;\n  if (isSequence) {\n    n = m.body.split(/\\.\\./);\n  } else {\n    n = parseCommaParts(m.body);\n    if (n.length === 1) {\n      // x{{a,b}}y ==> x{a}y x{b}y\n      n = expand(n[0], false).map(embrace);\n      if (n.length === 1) {\n        var post = m.post.length ? expand(m.post, false) : [''];\n        return post.map(function (p) {\n          return m.pre + n[0] + p;\n        });\n      }\n    }\n  }\n\n  // at this point, n is the parts, and we know it's not a comma set\n  // with a single entry.\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length ? expand(m.post, false) : [''];\n  var N;\n  if (isSequence) {\n    var x = numeric(n[0]);\n    var y = numeric(n[1]);\n    var width = Math.max(n[0].length, n[1].length);\n    var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;\n    var test = lte;\n    var reverse = y < x;\n    if (reverse) {\n      incr *= -1;\n      test = gte;\n    }\n    var pad = n.some(isPadded);\n    N = [];\n    for (var i = x; test(i, y); i += incr) {\n      var c;\n      if (isAlphaSequence) {\n        c = String.fromCharCode(i);\n        if (c === '\\\\') c = '';\n      } else {\n        c = String(i);\n        if (pad) {\n          var need = width - c.length;\n          if (need > 0) {\n            var z = new Array(need + 1).join('0');\n            if (i < 0) c = '-' + z + c.slice(1);else c = z + c;\n          }\n        }\n      }\n      N.push(c);\n    }\n  } else {\n    N = concatMap(n, function (el) {\n      return expand(el, false);\n    });\n  }\n  for (var j = 0; j < N.length; j++) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + N[j] + post[k];\n      if (!isTop || isSequence || expansion) expansions.push(expansion);\n    }\n  }\n  return expansions;\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\node_modules\\brace-expansion\\index.js");

/***/ }),

/***/ "./node_modules/shelljs/node_modules/glob/common.js":
/*!**********************************************************!*\
  !*** ./node_modules/shelljs/node_modules/glob/common.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.setopts = setopts;\nexports.ownProp = ownProp;\nexports.makeAbs = makeAbs;\nexports.finish = finish;\nexports.mark = mark;\nexports.isIgnored = isIgnored;\nexports.childrenIgnored = childrenIgnored;\nfunction ownProp(obj, field) {\n  return Object.prototype.hasOwnProperty.call(obj, field);\n}\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar minimatch = __webpack_require__(/*! minimatch */ \"./node_modules/shelljs/node_modules/minimatch/minimatch.js\");\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"./node_modules/path-is-absolute/index.js\");\nvar Minimatch = minimatch.Minimatch;\nfunction alphasort(a, b) {\n  return a.localeCompare(b, 'en');\n}\nfunction setupIgnores(self, options) {\n  self.ignore = options.ignore || [];\n  if (!Array.isArray(self.ignore)) self.ignore = [self.ignore];\n  if (self.ignore.length) {\n    self.ignore = self.ignore.map(ignoreMap);\n  }\n}\n\n// ignore patterns are always in dot:true mode.\nfunction ignoreMap(pattern) {\n  var gmatcher = null;\n  if (pattern.slice(-3) === '/**') {\n    var gpattern = pattern.replace(/(\\/\\*\\*)+$/, '');\n    gmatcher = new Minimatch(gpattern, {\n      dot: true\n    });\n  }\n  return {\n    matcher: new Minimatch(pattern, {\n      dot: true\n    }),\n    gmatcher: gmatcher\n  };\n}\nfunction setopts(self, pattern, options) {\n  if (!options) options = {};\n\n  // base-matching: just use globstar for that.\n  if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\n    if (options.noglobstar) {\n      throw new Error(\"base matching requires globstar\");\n    }\n    pattern = \"**/\" + pattern;\n  }\n  self.silent = !!options.silent;\n  self.pattern = pattern;\n  self.strict = options.strict !== false;\n  self.realpath = !!options.realpath;\n  self.realpathCache = options.realpathCache || Object.create(null);\n  self.follow = !!options.follow;\n  self.dot = !!options.dot;\n  self.mark = !!options.mark;\n  self.nodir = !!options.nodir;\n  if (self.nodir) self.mark = true;\n  self.sync = !!options.sync;\n  self.nounique = !!options.nounique;\n  self.nonull = !!options.nonull;\n  self.nosort = !!options.nosort;\n  self.nocase = !!options.nocase;\n  self.stat = !!options.stat;\n  self.noprocess = !!options.noprocess;\n  self.absolute = !!options.absolute;\n  self.fs = options.fs || fs;\n  self.maxLength = options.maxLength || Infinity;\n  self.cache = options.cache || Object.create(null);\n  self.statCache = options.statCache || Object.create(null);\n  self.symlinks = options.symlinks || Object.create(null);\n  setupIgnores(self, options);\n  self.changedCwd = false;\n  var cwd = process.cwd();\n  if (!ownProp(options, \"cwd\")) self.cwd = cwd;else {\n    self.cwd = path.resolve(options.cwd);\n    self.changedCwd = self.cwd !== cwd;\n  }\n  self.root = options.root || path.resolve(self.cwd, \"/\");\n  self.root = path.resolve(self.root);\n  if (process.platform === \"win32\") self.root = self.root.replace(/\\\\/g, \"/\");\n\n  // TODO: is an absolute `cwd` supposed to be resolved against `root`?\n  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')\n  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd);\n  if (process.platform === \"win32\") self.cwdAbs = self.cwdAbs.replace(/\\\\/g, \"/\");\n  self.nomount = !!options.nomount;\n\n  // disable comments and negation in Minimatch.\n  // Note that they are not supported in Glob itself anyway.\n  options.nonegate = true;\n  options.nocomment = true;\n  // always treat \\ in patterns as escapes, not path separators\n  options.allowWindowsEscape = false;\n  self.minimatch = new Minimatch(pattern, options);\n  self.options = self.minimatch.options;\n}\nfunction finish(self) {\n  var nou = self.nounique;\n  var all = nou ? [] : Object.create(null);\n  for (var i = 0, l = self.matches.length; i < l; i++) {\n    var matches = self.matches[i];\n    if (!matches || Object.keys(matches).length === 0) {\n      if (self.nonull) {\n        // do like the shell, and spit out the literal glob\n        var literal = self.minimatch.globSet[i];\n        if (nou) all.push(literal);else all[literal] = true;\n      }\n    } else {\n      // had matches\n      var m = Object.keys(matches);\n      if (nou) all.push.apply(all, m);else m.forEach(function (m) {\n        all[m] = true;\n      });\n    }\n  }\n  if (!nou) all = Object.keys(all);\n  if (!self.nosort) all = all.sort(alphasort);\n\n  // at *some* point we statted all of these\n  if (self.mark) {\n    for (var i = 0; i < all.length; i++) {\n      all[i] = self._mark(all[i]);\n    }\n    if (self.nodir) {\n      all = all.filter(function (e) {\n        var notDir = !/\\/$/.test(e);\n        var c = self.cache[e] || self.cache[makeAbs(self, e)];\n        if (notDir && c) notDir = c !== 'DIR' && !Array.isArray(c);\n        return notDir;\n      });\n    }\n  }\n  if (self.ignore.length) all = all.filter(function (m) {\n    return !isIgnored(self, m);\n  });\n  self.found = all;\n}\nfunction mark(self, p) {\n  var abs = makeAbs(self, p);\n  var c = self.cache[abs];\n  var m = p;\n  if (c) {\n    var isDir = c === 'DIR' || Array.isArray(c);\n    var slash = p.slice(-1) === '/';\n    if (isDir && !slash) m += '/';else if (!isDir && slash) m = m.slice(0, -1);\n    if (m !== p) {\n      var mabs = makeAbs(self, m);\n      self.statCache[mabs] = self.statCache[abs];\n      self.cache[mabs] = self.cache[abs];\n    }\n  }\n  return m;\n}\n\n// lotta situps...\nfunction makeAbs(self, f) {\n  var abs = f;\n  if (f.charAt(0) === '/') {\n    abs = path.join(self.root, f);\n  } else if (isAbsolute(f) || f === '') {\n    abs = f;\n  } else if (self.changedCwd) {\n    abs = path.resolve(self.cwd, f);\n  } else {\n    abs = path.resolve(f);\n  }\n  if (process.platform === 'win32') abs = abs.replace(/\\\\/g, '/');\n  return abs;\n}\n\n// Return true, if pattern ends with globstar '**', for the accompanying parent directory.\n// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents\nfunction isIgnored(self, path) {\n  if (!self.ignore.length) return false;\n  return self.ignore.some(function (item) {\n    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path));\n  });\n}\nfunction childrenIgnored(self, path) {\n  if (!self.ignore.length) return false;\n  return self.ignore.some(function (item) {\n    return !!(item.gmatcher && item.gmatcher.match(path));\n  });\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\node_modules\\glob\\common.js");

/***/ }),

/***/ "./node_modules/shelljs/node_modules/glob/glob.js":
/*!********************************************************!*\
  !*** ./node_modules/shelljs/node_modules/glob/glob.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// Approach:\n//\n// 1. Get the minimatch set\n// 2. For each pattern in the set, PROCESS(pattern, false)\n// 3. Store matches per-set, then uniq them\n//\n// PROCESS(pattern, inGlobStar)\n// Get the first [n] items from pattern that are all strings\n// Join these together.  This is PREFIX.\n//   If there is no more remaining, then stat(PREFIX) and\n//   add to matches if it succeeds.  END.\n//\n// If inGlobStar and PREFIX is symlink and points to dir\n//   set ENTRIES = []\n// else readdir(PREFIX) as ENTRIES\n//   If fail, END\n//\n// with ENTRIES\n//   If pattern[n] is GLOBSTAR\n//     // handle the case where the globstar match is empty\n//     // by pruning it out, and testing the resulting pattern\n//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)\n//     // handle other cases.\n//     for ENTRY in ENTRIES (not dotfiles)\n//       // attach globstar + tail onto the entry\n//       // Mark that this entry is a globstar match\n//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)\n//\n//   else // not globstar\n//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)\n//       Test ENTRY against pattern[n]\n//       If fails, continue\n//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])\n//\n// Caveat:\n//   Cache all stats and readdirs results to minimize syscall.  Since all\n//   we ever care about is existence and directory-ness, we can just keep\n//   `true` for files, and [children,...] for directories, or `false` for\n//   things that don't exist.\n\nmodule.exports = glob;\nvar rp = __webpack_require__(/*! fs.realpath */ \"./node_modules/fs.realpath/index.js\");\nvar minimatch = __webpack_require__(/*! minimatch */ \"./node_modules/shelljs/node_modules/minimatch/minimatch.js\");\nvar Minimatch = minimatch.Minimatch;\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits.js\");\nvar EE = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar path = __webpack_require__(/*! path */ \"path\");\nvar assert = __webpack_require__(/*! assert */ \"assert\");\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"./node_modules/path-is-absolute/index.js\");\nvar globSync = __webpack_require__(/*! ./sync.js */ \"./node_modules/shelljs/node_modules/glob/sync.js\");\nvar common = __webpack_require__(/*! ./common.js */ \"./node_modules/shelljs/node_modules/glob/common.js\");\nvar setopts = common.setopts;\nvar ownProp = common.ownProp;\nvar inflight = __webpack_require__(/*! inflight */ \"./node_modules/inflight/inflight.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar childrenIgnored = common.childrenIgnored;\nvar isIgnored = common.isIgnored;\nvar once = __webpack_require__(/*! once */ \"./node_modules/once/once.js\");\nfunction glob(pattern, options, cb) {\n  if (typeof options === 'function') cb = options, options = {};\n  if (!options) options = {};\n  if (options.sync) {\n    if (cb) throw new TypeError('callback provided to sync glob');\n    return globSync(pattern, options);\n  }\n  return new Glob(pattern, options, cb);\n}\nglob.sync = globSync;\nvar GlobSync = glob.GlobSync = globSync.GlobSync;\n\n// old api surface\nglob.glob = glob;\nfunction extend(origin, add) {\n  if (add === null || typeof add !== 'object') {\n    return origin;\n  }\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n}\nglob.hasMagic = function (pattern, options_) {\n  var options = extend({}, options_);\n  options.noprocess = true;\n  var g = new Glob(pattern, options);\n  var set = g.minimatch.set;\n  if (!pattern) return false;\n  if (set.length > 1) return true;\n  for (var j = 0; j < set[0].length; j++) {\n    if (typeof set[0][j] !== 'string') return true;\n  }\n  return false;\n};\nglob.Glob = Glob;\ninherits(Glob, EE);\nfunction Glob(pattern, options, cb) {\n  if (typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n  if (options && options.sync) {\n    if (cb) throw new TypeError('callback provided to sync glob');\n    return new GlobSync(pattern, options);\n  }\n  if (!(this instanceof Glob)) return new Glob(pattern, options, cb);\n  setopts(this, pattern, options);\n  this._didRealPath = false;\n\n  // process each pattern in the minimatch set\n  var n = this.minimatch.set.length;\n\n  // The matches are stored as {<filename>: true,...} so that\n  // duplicates are automagically pruned.\n  // Later, we do an Object.keys() on these.\n  // Keep them as a list so we can fill in when nonull is set.\n  this.matches = new Array(n);\n  if (typeof cb === 'function') {\n    cb = once(cb);\n    this.on('error', cb);\n    this.on('end', function (matches) {\n      cb(null, matches);\n    });\n  }\n  var self = this;\n  this._processing = 0;\n  this._emitQueue = [];\n  this._processQueue = [];\n  this.paused = false;\n  if (this.noprocess) return this;\n  if (n === 0) return done();\n  var sync = true;\n  for (var i = 0; i < n; i++) {\n    this._process(this.minimatch.set[i], i, false, done);\n  }\n  sync = false;\n  function done() {\n    --self._processing;\n    if (self._processing <= 0) {\n      if (sync) {\n        process.nextTick(function () {\n          self._finish();\n        });\n      } else {\n        self._finish();\n      }\n    }\n  }\n}\nGlob.prototype._finish = function () {\n  assert(this instanceof Glob);\n  if (this.aborted) return;\n  if (this.realpath && !this._didRealpath) return this._realpath();\n  common.finish(this);\n  this.emit('end', this.found);\n};\nGlob.prototype._realpath = function () {\n  if (this._didRealpath) return;\n  this._didRealpath = true;\n  var n = this.matches.length;\n  if (n === 0) return this._finish();\n  var self = this;\n  for (var i = 0; i < this.matches.length; i++) this._realpathSet(i, next);\n  function next() {\n    if (--n === 0) self._finish();\n  }\n};\nGlob.prototype._realpathSet = function (index, cb) {\n  var matchset = this.matches[index];\n  if (!matchset) return cb();\n  var found = Object.keys(matchset);\n  var self = this;\n  var n = found.length;\n  if (n === 0) return cb();\n  var set = this.matches[index] = Object.create(null);\n  found.forEach(function (p, i) {\n    // If there's a problem with the stat, then it means that\n    // one or more of the links in the realpath couldn't be\n    // resolved.  just return the abs value in that case.\n    p = self._makeAbs(p);\n    rp.realpath(p, self.realpathCache, function (er, real) {\n      if (!er) set[real] = true;else if (er.syscall === 'stat') set[p] = true;else self.emit('error', er); // srsly wtf right here\n\n      if (--n === 0) {\n        self.matches[index] = set;\n        cb();\n      }\n    });\n  });\n};\nGlob.prototype._mark = function (p) {\n  return common.mark(this, p);\n};\nGlob.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f);\n};\nGlob.prototype.abort = function () {\n  this.aborted = true;\n  this.emit('abort');\n};\nGlob.prototype.pause = function () {\n  if (!this.paused) {\n    this.paused = true;\n    this.emit('pause');\n  }\n};\nGlob.prototype.resume = function () {\n  if (this.paused) {\n    this.emit('resume');\n    this.paused = false;\n    if (this._emitQueue.length) {\n      var eq = this._emitQueue.slice(0);\n      this._emitQueue.length = 0;\n      for (var i = 0; i < eq.length; i++) {\n        var e = eq[i];\n        this._emitMatch(e[0], e[1]);\n      }\n    }\n    if (this._processQueue.length) {\n      var pq = this._processQueue.slice(0);\n      this._processQueue.length = 0;\n      for (var i = 0; i < pq.length; i++) {\n        var p = pq[i];\n        this._processing--;\n        this._process(p[0], p[1], p[2], p[3]);\n      }\n    }\n  }\n};\nGlob.prototype._process = function (pattern, index, inGlobStar, cb) {\n  assert(this instanceof Glob);\n  assert(typeof cb === 'function');\n  if (this.aborted) return;\n  this._processing++;\n  if (this.paused) {\n    this._processQueue.push([pattern, index, inGlobStar, cb]);\n    return;\n  }\n\n  //console.error('PROCESS %d', this._processing, pattern)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0;\n  while (typeof pattern[n] === 'string') {\n    n++;\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // see if there's anything else\n  var prefix;\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index, cb);\n      return;\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null;\n      break;\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/');\n      break;\n  }\n  var remain = pattern.slice(n);\n\n  // get the list of entries.\n  var read;\n  if (prefix === null) read = '.';else if (isAbsolute(prefix) || isAbsolute(pattern.map(function (p) {\n    return typeof p === 'string' ? p : '[*]';\n  }).join('/'))) {\n    if (!prefix || !isAbsolute(prefix)) prefix = '/' + prefix;\n    read = prefix;\n  } else read = prefix;\n  var abs = this._makeAbs(read);\n\n  //if ignored, skip _processing\n  if (childrenIgnored(this, read)) return cb();\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR;\n  if (isGlobStar) this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);else this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);\n};\nGlob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this;\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);\n  });\n};\nGlob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries) return cb();\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0];\n  var negate = !!this.minimatch.negate;\n  var rawGlob = pn._glob;\n  var dotOk = this.dot || rawGlob.charAt(0) === '.';\n  var matchedEntries = [];\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i];\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m;\n      if (negate && !prefix) {\n        m = !e.match(pn);\n      } else {\n        m = e.match(pn);\n      }\n      if (m) matchedEntries.push(e);\n    }\n  }\n\n  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)\n\n  var len = matchedEntries.length;\n  // If there are no matched entries, then nothing matches.\n  if (len === 0) return cb();\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index]) this.matches[index] = Object.create(null);\n    for (var i = 0; i < len; i++) {\n      var e = matchedEntries[i];\n      if (prefix) {\n        if (prefix !== '/') e = prefix + '/' + e;else e = prefix + e;\n      }\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e);\n      }\n      this._emitMatch(index, e);\n    }\n    // This was the last one, and no stats were needed\n    return cb();\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift();\n  for (var i = 0; i < len; i++) {\n    var e = matchedEntries[i];\n    var newPattern;\n    if (prefix) {\n      if (prefix !== '/') e = prefix + '/' + e;else e = prefix + e;\n    }\n    this._process([e].concat(remain), index, inGlobStar, cb);\n  }\n  cb();\n};\nGlob.prototype._emitMatch = function (index, e) {\n  if (this.aborted) return;\n  if (isIgnored(this, e)) return;\n  if (this.paused) {\n    this._emitQueue.push([index, e]);\n    return;\n  }\n  var abs = isAbsolute(e) ? e : this._makeAbs(e);\n  if (this.mark) e = this._mark(e);\n  if (this.absolute) e = abs;\n  if (this.matches[index][e]) return;\n  if (this.nodir) {\n    var c = this.cache[abs];\n    if (c === 'DIR' || Array.isArray(c)) return;\n  }\n  this.matches[index][e] = true;\n  var st = this.statCache[abs];\n  if (st) this.emit('stat', e, st);\n  this.emit('match', e);\n};\nGlob.prototype._readdirInGlobStar = function (abs, cb) {\n  if (this.aborted) return;\n\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow) return this._readdir(abs, false, cb);\n  var lstatkey = 'lstat\\0' + abs;\n  var self = this;\n  var lstatcb = inflight(lstatkey, lstatcb_);\n  if (lstatcb) self.fs.lstat(abs, lstatcb);\n  function lstatcb_(er, lstat) {\n    if (er && er.code === 'ENOENT') return cb();\n    var isSym = lstat && lstat.isSymbolicLink();\n    self.symlinks[abs] = isSym;\n\n    // If it's not a symlink or a dir, then it's definitely a regular file.\n    // don't bother doing a readdir in that case.\n    if (!isSym && lstat && !lstat.isDirectory()) {\n      self.cache[abs] = 'FILE';\n      cb();\n    } else self._readdir(abs, false, cb);\n  }\n};\nGlob.prototype._readdir = function (abs, inGlobStar, cb) {\n  if (this.aborted) return;\n  cb = inflight('readdir\\0' + abs + '\\0' + inGlobStar, cb);\n  if (!cb) return;\n\n  //console.error('RD %j %j', +inGlobStar, abs)\n  if (inGlobStar && !ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs, cb);\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs];\n    if (!c || c === 'FILE') return cb();\n    if (Array.isArray(c)) return cb(null, c);\n  }\n  var self = this;\n  self.fs.readdir(abs, readdirCb(this, abs, cb));\n};\nfunction readdirCb(self, abs, cb) {\n  return function (er, entries) {\n    if (er) self._readdirError(abs, er, cb);else self._readdirEntries(abs, entries, cb);\n  };\n}\nGlob.prototype._readdirEntries = function (abs, entries, cb) {\n  if (this.aborted) return;\n\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i++) {\n      var e = entries[i];\n      if (abs === '/') e = abs + e;else e = abs + '/' + e;\n      this.cache[e] = true;\n    }\n  }\n  this.cache[abs] = entries;\n  return cb(null, entries);\n};\nGlob.prototype._readdirError = function (f, er, cb) {\n  if (this.aborted) return;\n\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR':\n      // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f);\n      this.cache[abs] = 'FILE';\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd);\n        error.path = this.cwd;\n        error.code = er.code;\n        this.emit('error', error);\n        this.abort();\n      }\n      break;\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false;\n      break;\n    default:\n      // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false;\n      if (this.strict) {\n        this.emit('error', er);\n        // If the error is handled, then we abort\n        // if not, we threw out of here\n        this.abort();\n      }\n      if (!this.silent) console.error('glob error', er);\n      break;\n  }\n  return cb();\n};\nGlob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this;\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);\n  });\n};\nGlob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n  //console.error('pgs2', prefix, remain[0], entries)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries) return cb();\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1);\n  var gspref = prefix ? [prefix] : [];\n  var noGlobStar = gspref.concat(remainWithoutGlobStar);\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false, cb);\n  var isSym = this.symlinks[abs];\n  var len = entries.length;\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar) return cb();\n  for (var i = 0; i < len; i++) {\n    var e = entries[i];\n    if (e.charAt(0) === '.' && !this.dot) continue;\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar);\n    this._process(instead, index, true, cb);\n    var below = gspref.concat(entries[i], remain);\n    this._process(below, index, true, cb);\n  }\n  cb();\n};\nGlob.prototype._processSimple = function (prefix, index, cb) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var self = this;\n  this._stat(prefix, function (er, exists) {\n    self._processSimple2(prefix, index, er, exists, cb);\n  });\n};\nGlob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {\n  //console.error('ps2', prefix, exists)\n\n  if (!this.matches[index]) this.matches[index] = Object.create(null);\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists) return cb();\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix);\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix);\n    } else {\n      prefix = path.resolve(this.root, prefix);\n      if (trail) prefix += '/';\n    }\n  }\n  if (process.platform === 'win32') prefix = prefix.replace(/\\\\/g, '/');\n\n  // Mark this as a match\n  this._emitMatch(index, prefix);\n  cb();\n};\n\n// Returns either 'DIR', 'FILE', or false\nGlob.prototype._stat = function (f, cb) {\n  var abs = this._makeAbs(f);\n  var needDir = f.slice(-1) === '/';\n  if (f.length > this.maxLength) return cb();\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs];\n    if (Array.isArray(c)) c = 'DIR';\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR') return cb(null, c);\n    if (needDir && c === 'FILE') return cb();\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists;\n  var stat = this.statCache[abs];\n  if (stat !== undefined) {\n    if (stat === false) return cb(null, stat);else {\n      var type = stat.isDirectory() ? 'DIR' : 'FILE';\n      if (needDir && type === 'FILE') return cb();else return cb(null, type, stat);\n    }\n  }\n  var self = this;\n  var statcb = inflight('stat\\0' + abs, lstatcb_);\n  if (statcb) self.fs.lstat(abs, statcb);\n  function lstatcb_(er, lstat) {\n    if (lstat && lstat.isSymbolicLink()) {\n      // If it's a symlink, then treat it as the target, unless\n      // the target does not exist, then treat it as a file.\n      return self.fs.stat(abs, function (er, stat) {\n        if (er) self._stat2(f, abs, null, lstat, cb);else self._stat2(f, abs, er, stat, cb);\n      });\n    } else {\n      self._stat2(f, abs, er, lstat, cb);\n    }\n  }\n};\nGlob.prototype._stat2 = function (f, abs, er, stat, cb) {\n  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n    this.statCache[abs] = false;\n    return cb();\n  }\n  var needDir = f.slice(-1) === '/';\n  this.statCache[abs] = stat;\n  if (abs.slice(-1) === '/' && stat && !stat.isDirectory()) return cb(null, false, stat);\n  var c = true;\n  if (stat) c = stat.isDirectory() ? 'DIR' : 'FILE';\n  this.cache[abs] = this.cache[abs] || c;\n  if (needDir && c === 'FILE') return cb();\n  return cb(null, c, stat);\n};\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\node_modules\\glob\\glob.js");

/***/ }),

/***/ "./node_modules/shelljs/node_modules/glob/sync.js":
/*!********************************************************!*\
  !*** ./node_modules/shelljs/node_modules/glob/sync.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = globSync;\nglobSync.GlobSync = GlobSync;\nvar rp = __webpack_require__(/*! fs.realpath */ \"./node_modules/fs.realpath/index.js\");\nvar minimatch = __webpack_require__(/*! minimatch */ \"./node_modules/shelljs/node_modules/minimatch/minimatch.js\");\nvar Minimatch = minimatch.Minimatch;\nvar Glob = (__webpack_require__(/*! ./glob.js */ \"./node_modules/shelljs/node_modules/glob/glob.js\").Glob);\nvar util = __webpack_require__(/*! util */ \"util\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar assert = __webpack_require__(/*! assert */ \"assert\");\nvar isAbsolute = __webpack_require__(/*! path-is-absolute */ \"./node_modules/path-is-absolute/index.js\");\nvar common = __webpack_require__(/*! ./common.js */ \"./node_modules/shelljs/node_modules/glob/common.js\");\nvar setopts = common.setopts;\nvar ownProp = common.ownProp;\nvar childrenIgnored = common.childrenIgnored;\nvar isIgnored = common.isIgnored;\nfunction globSync(pattern, options) {\n  if (typeof options === 'function' || arguments.length === 3) throw new TypeError('callback provided to sync glob\\n' + 'See: https://github.com/isaacs/node-glob/issues/167');\n  return new GlobSync(pattern, options).found;\n}\nfunction GlobSync(pattern, options) {\n  if (!pattern) throw new Error('must provide pattern');\n  if (typeof options === 'function' || arguments.length === 3) throw new TypeError('callback provided to sync glob\\n' + 'See: https://github.com/isaacs/node-glob/issues/167');\n  if (!(this instanceof GlobSync)) return new GlobSync(pattern, options);\n  setopts(this, pattern, options);\n  if (this.noprocess) return this;\n  var n = this.minimatch.set.length;\n  this.matches = new Array(n);\n  for (var i = 0; i < n; i++) {\n    this._process(this.minimatch.set[i], i, false);\n  }\n  this._finish();\n}\nGlobSync.prototype._finish = function () {\n  assert.ok(this instanceof GlobSync);\n  if (this.realpath) {\n    var self = this;\n    this.matches.forEach(function (matchset, index) {\n      var set = self.matches[index] = Object.create(null);\n      for (var p in matchset) {\n        try {\n          p = self._makeAbs(p);\n          var real = rp.realpathSync(p, self.realpathCache);\n          set[real] = true;\n        } catch (er) {\n          if (er.syscall === 'stat') set[self._makeAbs(p)] = true;else throw er;\n        }\n      }\n    });\n  }\n  common.finish(this);\n};\nGlobSync.prototype._process = function (pattern, index, inGlobStar) {\n  assert.ok(this instanceof GlobSync);\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0;\n  while (typeof pattern[n] === 'string') {\n    n++;\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // See if there's anything else\n  var prefix;\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index);\n      return;\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null;\n      break;\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/');\n      break;\n  }\n  var remain = pattern.slice(n);\n\n  // get the list of entries.\n  var read;\n  if (prefix === null) read = '.';else if (isAbsolute(prefix) || isAbsolute(pattern.map(function (p) {\n    return typeof p === 'string' ? p : '[*]';\n  }).join('/'))) {\n    if (!prefix || !isAbsolute(prefix)) prefix = '/' + prefix;\n    read = prefix;\n  } else read = prefix;\n  var abs = this._makeAbs(read);\n\n  //if ignored, skip processing\n  if (childrenIgnored(this, read)) return;\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR;\n  if (isGlobStar) this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);else this._processReaddir(prefix, read, abs, remain, index, inGlobStar);\n};\nGlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {\n  var entries = this._readdir(abs, inGlobStar);\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries) return;\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0];\n  var negate = !!this.minimatch.negate;\n  var rawGlob = pn._glob;\n  var dotOk = this.dot || rawGlob.charAt(0) === '.';\n  var matchedEntries = [];\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i];\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m;\n      if (negate && !prefix) {\n        m = !e.match(pn);\n      } else {\n        m = e.match(pn);\n      }\n      if (m) matchedEntries.push(e);\n    }\n  }\n  var len = matchedEntries.length;\n  // If there are no matched entries, then nothing matches.\n  if (len === 0) return;\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index]) this.matches[index] = Object.create(null);\n    for (var i = 0; i < len; i++) {\n      var e = matchedEntries[i];\n      if (prefix) {\n        if (prefix.slice(-1) !== '/') e = prefix + '/' + e;else e = prefix + e;\n      }\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e);\n      }\n      this._emitMatch(index, e);\n    }\n    // This was the last one, and no stats were needed\n    return;\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift();\n  for (var i = 0; i < len; i++) {\n    var e = matchedEntries[i];\n    var newPattern;\n    if (prefix) newPattern = [prefix, e];else newPattern = [e];\n    this._process(newPattern.concat(remain), index, inGlobStar);\n  }\n};\nGlobSync.prototype._emitMatch = function (index, e) {\n  if (isIgnored(this, e)) return;\n  var abs = this._makeAbs(e);\n  if (this.mark) e = this._mark(e);\n  if (this.absolute) {\n    e = abs;\n  }\n  if (this.matches[index][e]) return;\n  if (this.nodir) {\n    var c = this.cache[abs];\n    if (c === 'DIR' || Array.isArray(c)) return;\n  }\n  this.matches[index][e] = true;\n  if (this.stat) this._stat(e);\n};\nGlobSync.prototype._readdirInGlobStar = function (abs) {\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow) return this._readdir(abs, false);\n  var entries;\n  var lstat;\n  var stat;\n  try {\n    lstat = this.fs.lstatSync(abs);\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      // lstat failed, doesn't exist\n      return null;\n    }\n  }\n  var isSym = lstat && lstat.isSymbolicLink();\n  this.symlinks[abs] = isSym;\n\n  // If it's not a symlink or a dir, then it's definitely a regular file.\n  // don't bother doing a readdir in that case.\n  if (!isSym && lstat && !lstat.isDirectory()) this.cache[abs] = 'FILE';else entries = this._readdir(abs, false);\n  return entries;\n};\nGlobSync.prototype._readdir = function (abs, inGlobStar) {\n  var entries;\n  if (inGlobStar && !ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs);\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs];\n    if (!c || c === 'FILE') return null;\n    if (Array.isArray(c)) return c;\n  }\n  try {\n    return this._readdirEntries(abs, this.fs.readdirSync(abs));\n  } catch (er) {\n    this._readdirError(abs, er);\n    return null;\n  }\n};\nGlobSync.prototype._readdirEntries = function (abs, entries) {\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i++) {\n      var e = entries[i];\n      if (abs === '/') e = abs + e;else e = abs + '/' + e;\n      this.cache[e] = true;\n    }\n  }\n  this.cache[abs] = entries;\n\n  // mark and cache dir-ness\n  return entries;\n};\nGlobSync.prototype._readdirError = function (f, er) {\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR':\n      // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f);\n      this.cache[abs] = 'FILE';\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd);\n        error.path = this.cwd;\n        error.code = er.code;\n        throw error;\n      }\n      break;\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false;\n      break;\n    default:\n      // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false;\n      if (this.strict) throw er;\n      if (!this.silent) console.error('glob error', er);\n      break;\n  }\n};\nGlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {\n  var entries = this._readdir(abs, inGlobStar);\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries) return;\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1);\n  var gspref = prefix ? [prefix] : [];\n  var noGlobStar = gspref.concat(remainWithoutGlobStar);\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false);\n  var len = entries.length;\n  var isSym = this.symlinks[abs];\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar) return;\n  for (var i = 0; i < len; i++) {\n    var e = entries[i];\n    if (e.charAt(0) === '.' && !this.dot) continue;\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar);\n    this._process(instead, index, true);\n    var below = gspref.concat(entries[i], remain);\n    this._process(below, index, true);\n  }\n};\nGlobSync.prototype._processSimple = function (prefix, index) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var exists = this._stat(prefix);\n  if (!this.matches[index]) this.matches[index] = Object.create(null);\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists) return;\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix);\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix);\n    } else {\n      prefix = path.resolve(this.root, prefix);\n      if (trail) prefix += '/';\n    }\n  }\n  if (process.platform === 'win32') prefix = prefix.replace(/\\\\/g, '/');\n\n  // Mark this as a match\n  this._emitMatch(index, prefix);\n};\n\n// Returns either 'DIR', 'FILE', or false\nGlobSync.prototype._stat = function (f) {\n  var abs = this._makeAbs(f);\n  var needDir = f.slice(-1) === '/';\n  if (f.length > this.maxLength) return false;\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs];\n    if (Array.isArray(c)) c = 'DIR';\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR') return c;\n    if (needDir && c === 'FILE') return false;\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists;\n  var stat = this.statCache[abs];\n  if (!stat) {\n    var lstat;\n    try {\n      lstat = this.fs.lstatSync(abs);\n    } catch (er) {\n      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n        this.statCache[abs] = false;\n        return false;\n      }\n    }\n    if (lstat && lstat.isSymbolicLink()) {\n      try {\n        stat = this.fs.statSync(abs);\n      } catch (er) {\n        stat = lstat;\n      }\n    } else {\n      stat = lstat;\n    }\n  }\n  this.statCache[abs] = stat;\n  var c = true;\n  if (stat) c = stat.isDirectory() ? 'DIR' : 'FILE';\n  this.cache[abs] = this.cache[abs] || c;\n  if (needDir && c === 'FILE') return false;\n  return c;\n};\nGlobSync.prototype._mark = function (p) {\n  return common.mark(this, p);\n};\nGlobSync.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f);\n};\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\node_modules\\glob\\sync.js");

/***/ }),

/***/ "./node_modules/shelljs/node_modules/minimatch/minimatch.js":
/*!******************************************************************!*\
  !*** ./node_modules/shelljs/node_modules/minimatch/minimatch.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = minimatch;\nminimatch.Minimatch = Minimatch;\nvar path = function () {\n  try {\n    return __webpack_require__(/*! path */ \"path\");\n  } catch (e) {}\n}() || {\n  sep: '/'\n};\nminimatch.sep = path.sep;\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};\nvar expand = __webpack_require__(/*! brace-expansion */ \"./node_modules/shelljs/node_modules/brace-expansion/index.js\");\nvar plTypes = {\n  '!': {\n    open: '(?:(?!(?:',\n    close: '))[^/]*?)'\n  },\n  '?': {\n    open: '(?:',\n    close: ')?'\n  },\n  '+': {\n    open: '(?:',\n    close: ')+'\n  },\n  '*': {\n    open: '(?:',\n    close: ')*'\n  },\n  '@': {\n    open: '(?:',\n    close: ')'\n  }\n};\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]';\n\n// * => any number of characters\nvar star = qmark + '*?';\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?';\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?';\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!');\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet(s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true;\n    return set;\n  }, {});\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/;\nminimatch.filter = filter;\nfunction filter(pattern, options) {\n  options = options || {};\n  return function (p, i, list) {\n    return minimatch(p, pattern, options);\n  };\n}\nfunction ext(a, b) {\n  b = b || {};\n  var t = {};\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k];\n  });\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k];\n  });\n  return t;\n}\nminimatch.defaults = function (def) {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch;\n  }\n  var orig = minimatch;\n  var m = function minimatch(p, pattern, options) {\n    return orig(p, pattern, ext(def, options));\n  };\n  m.Minimatch = function Minimatch(pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options));\n  };\n  m.Minimatch.defaults = function defaults(options) {\n    return orig.defaults(ext(def, options)).Minimatch;\n  };\n  m.filter = function filter(pattern, options) {\n    return orig.filter(pattern, ext(def, options));\n  };\n  m.defaults = function defaults(options) {\n    return orig.defaults(ext(def, options));\n  };\n  m.makeRe = function makeRe(pattern, options) {\n    return orig.makeRe(pattern, ext(def, options));\n  };\n  m.braceExpand = function braceExpand(pattern, options) {\n    return orig.braceExpand(pattern, ext(def, options));\n  };\n  m.match = function (list, pattern, options) {\n    return orig.match(list, pattern, ext(def, options));\n  };\n  return m;\n};\nMinimatch.defaults = function (def) {\n  return minimatch.defaults(def).Minimatch;\n};\nfunction minimatch(p, pattern, options) {\n  assertValidPattern(pattern);\n  if (!options) options = {};\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false;\n  }\n  return new Minimatch(pattern, options).match(p);\n}\nfunction Minimatch(pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options);\n  }\n  assertValidPattern(pattern);\n  if (!options) options = {};\n  pattern = pattern.trim();\n\n  // windows support: need to use /, not \\\n  if (!options.allowWindowsEscape && path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/');\n  }\n  this.options = options;\n  this.set = [];\n  this.pattern = pattern;\n  this.regexp = null;\n  this.negate = false;\n  this.comment = false;\n  this.empty = false;\n  this.partial = !!options.partial;\n\n  // make the set of regexps etc.\n  this.make();\n}\nMinimatch.prototype.debug = function () {};\nMinimatch.prototype.make = make;\nfunction make() {\n  var pattern = this.pattern;\n  var options = this.options;\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true;\n    return;\n  }\n  if (!pattern) {\n    this.empty = true;\n    return;\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate();\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand();\n  if (options.debug) this.debug = function debug() {\n    console.error.apply(console, arguments);\n  };\n  this.debug(this.pattern, set);\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit);\n  });\n  this.debug(this.pattern, set);\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this);\n  }, this);\n  this.debug(this.pattern, set);\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1;\n  });\n  this.debug(this.pattern, set);\n  this.set = set;\n}\nMinimatch.prototype.parseNegate = parseNegate;\nfunction parseNegate() {\n  var pattern = this.pattern;\n  var negate = false;\n  var options = this.options;\n  var negateOffset = 0;\n  if (options.nonegate) return;\n  for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === '!'; i++) {\n    negate = !negate;\n    negateOffset++;\n  }\n  if (negateOffset) this.pattern = pattern.substr(negateOffset);\n  this.negate = negate;\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options);\n};\nMinimatch.prototype.braceExpand = braceExpand;\nfunction braceExpand(pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options;\n    } else {\n      options = {};\n    }\n  }\n  pattern = typeof pattern === 'undefined' ? this.pattern : pattern;\n  assertValidPattern(pattern);\n\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern];\n  }\n  return expand(pattern);\n}\nvar MAX_PATTERN_LENGTH = 1024 * 64;\nvar assertValidPattern = function assertValidPattern(pattern) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern');\n  }\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long');\n  }\n};\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse;\nvar SUBPARSE = {};\nfunction parse(pattern, isSub) {\n  assertValidPattern(pattern);\n  var options = this.options;\n\n  // shortcuts\n  if (pattern === '**') {\n    if (!options.noglobstar) return GLOBSTAR;else pattern = '*';\n  }\n  if (pattern === '') return '';\n  var re = '';\n  var hasMagic = !!options.nocase;\n  var escaping = false;\n  // ? => one single character\n  var patternListStack = [];\n  var negativeLists = [];\n  var stateChar;\n  var inClass = false;\n  var reClassStart = -1;\n  var classStart = -1;\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))' : '(?!\\\\.)';\n  var self = this;\n  function clearStateChar() {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star;\n          hasMagic = true;\n          break;\n        case '?':\n          re += qmark;\n          hasMagic = true;\n          break;\n        default:\n          re += '\\\\' + stateChar;\n          break;\n      }\n      self.debug('clearStateChar %j %j', stateChar, re);\n      stateChar = false;\n    }\n  }\n  for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c);\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c;\n      escaping = false;\n      continue;\n    }\n    switch (c) {\n      /* istanbul ignore next */\n      case '/':\n        {\n          // completely not allowed, even escaped.\n          // Should already be path-split by now.\n          return false;\n        }\n      case '\\\\':\n        clearStateChar();\n        escaping = true;\n        continue;\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c);\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class');\n          if (c === '!' && i === classStart + 1) c = '^';\n          re += c;\n          continue;\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar);\n        clearStateChar();\n        stateChar = c;\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar();\n        continue;\n      case '(':\n        if (inClass) {\n          re += '(';\n          continue;\n        }\n        if (!stateChar) {\n          re += '\\\\(';\n          continue;\n        }\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        });\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:';\n        this.debug('plType %j %j', stateChar, re);\n        stateChar = false;\n        continue;\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)';\n          continue;\n        }\n        clearStateChar();\n        hasMagic = true;\n        var pl = patternListStack.pop();\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close;\n        if (pl.type === '!') {\n          negativeLists.push(pl);\n        }\n        pl.reEnd = re.length;\n        continue;\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|';\n          escaping = false;\n          continue;\n        }\n        clearStateChar();\n        re += '|';\n        continue;\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar();\n        if (inClass) {\n          re += '\\\\' + c;\n          continue;\n        }\n        inClass = true;\n        classStart = i;\n        reClassStart = re.length;\n        re += c;\n        continue;\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c;\n          escaping = false;\n          continue;\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        // split where the last [ was, make sure we don't have\n        // an invalid re. if so, re-walk the contents of the\n        // would-be class to re-translate any characters that\n        // were passed through as-is\n        // TODO: It would probably be faster to determine this\n        // without a try/catch and a new RegExp, but it's tricky\n        // to do safely.  For now, this is safe and works.\n        var cs = pattern.substring(classStart + 1, i);\n        try {\n          RegExp('[' + cs + ']');\n        } catch (er) {\n          // not a valid class!\n          var sp = this.parse(cs, SUBPARSE);\n          re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]';\n          hasMagic = hasMagic || sp[1];\n          inClass = false;\n          continue;\n        }\n\n        // finish up the class.\n        hasMagic = true;\n        inClass = false;\n        re += c;\n        continue;\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar();\n        if (escaping) {\n          // no need\n          escaping = false;\n        } else if (reSpecials[c] && !(c === '^' && inClass)) {\n          re += '\\\\';\n        }\n        re += c;\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1);\n    sp = this.parse(cs, SUBPARSE);\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0];\n    hasMagic = hasMagic || sp[1];\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length);\n    this.debug('setting tail', re, pl);\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\';\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|';\n    });\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re);\n    var t = pl.type === '*' ? star : pl.type === '?' ? qmark : '\\\\' + pl.type;\n    hasMagic = true;\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail;\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar();\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\';\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false;\n  switch (re.charAt(0)) {\n    case '[':\n    case '.':\n    case '(':\n      addPatternStart = true;\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n];\n    var nlBefore = re.slice(0, nl.reStart);\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);\n    var nlAfter = re.slice(nl.reEnd);\n    nlLast += nlAfter;\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1;\n    var cleanAfter = nlAfter;\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '');\n    }\n    nlAfter = cleanAfter;\n    var dollar = '';\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$';\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;\n    re = newRe;\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re;\n  }\n  if (addPatternStart) {\n    re = patternStart + re;\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic];\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern);\n  }\n  var flags = options.nocase ? 'i' : '';\n  try {\n    var regExp = new RegExp('^' + re + '$', flags);\n  } catch (er) /* istanbul ignore next - should be impossible */{\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.');\n  }\n  regExp._glob = pattern;\n  regExp._src = re;\n  return regExp;\n}\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe();\n};\nMinimatch.prototype.makeRe = makeRe;\nfunction makeRe() {\n  if (this.regexp || this.regexp === false) return this.regexp;\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set;\n  if (!set.length) {\n    this.regexp = false;\n    return this.regexp;\n  }\n  var options = this.options;\n  var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;\n  var flags = options.nocase ? 'i' : '';\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return p === GLOBSTAR ? twoStar : typeof p === 'string' ? regExpEscape(p) : p._src;\n    }).join('\\\\\\/');\n  }).join('|');\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$';\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$';\n  try {\n    this.regexp = new RegExp(re, flags);\n  } catch (ex) /* istanbul ignore next - should be impossible */{\n    this.regexp = false;\n  }\n  return this.regexp;\n}\nminimatch.match = function (list, pattern, options) {\n  options = options || {};\n  var mm = new Minimatch(pattern, options);\n  list = list.filter(function (f) {\n    return mm.match(f);\n  });\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern);\n  }\n  return list;\n};\nMinimatch.prototype.match = function match(f, partial) {\n  if (typeof partial === 'undefined') partial = this.partial;\n  this.debug('match', f, this.pattern);\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false;\n  if (this.empty) return f === '';\n  if (f === '/' && partial) return true;\n  var options = this.options;\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/');\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit);\n  this.debug(this.pattern, 'split', f);\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set;\n  this.debug(this.pattern, 'set', set);\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename;\n  var i;\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i];\n    if (filename) break;\n  }\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i];\n    var file = f;\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename];\n    }\n    var hit = this.matchOne(file, pattern, partial);\n    if (hit) {\n      if (options.flipNegate) return true;\n      return !this.negate;\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false;\n  return this.negate;\n};\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options;\n  this.debug('matchOne', {\n    'this': this,\n    file: file,\n    pattern: pattern\n  });\n  this.debug('matchOne', file.length, pattern.length);\n  for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n    this.debug('matchOne loop');\n    var p = pattern[pi];\n    var f = file[fi];\n    this.debug(pattern, p, f);\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    /* istanbul ignore if */\n    if (p === false) return false;\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f]);\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi;\n      var pr = pi + 1;\n      if (pr === pl) {\n        this.debug('** at the end');\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' || !options.dot && file[fi].charAt(0) === '.') return false;\n        }\n        return true;\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr];\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee);\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee);\n          // found a match.\n          return true;\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' || !options.dot && swallowee.charAt(0) === '.') {\n            this.debug('dot detected!', file, fr, pattern, pr);\n            break;\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue');\n          fr++;\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      /* istanbul ignore if */\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n        if (fr === fl) return true;\n      }\n      return false;\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit;\n    if (typeof p === 'string') {\n      hit = f === p;\n      this.debug('string match', p, f, hit);\n    } else {\n      hit = f.match(p);\n      this.debug('pattern match', p, f, hit);\n    }\n    if (!hit) return false;\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true;\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial;\n  } else /* istanbul ignore else */if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      return fi === fl - 1 && file[fi] === '';\n    }\n\n  // should be unreachable.\n  /* istanbul ignore next */\n  throw new Error('wtf?');\n};\n\n// replace stuff like \\* with *\nfunction globUnescape(s) {\n  return s.replace(/\\\\(.)/g, '$1');\n}\nfunction regExpEscape(s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\node_modules\\minimatch\\minimatch.js");

/***/ }),

/***/ "./node_modules/shelljs/shell.js":
/*!***************************************!*\
  !*** ./node_modules/shelljs/shell.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n//\n// ShellJS\n// Unix shell commands on top of Node's API\n//\n// Copyright (c) 2012 Artur Adib\n// http://github.com/shelljs/shelljs\n//\n\nvar common = __webpack_require__(/*! ./src/common */ \"./node_modules/shelljs/src/common.js\");\n\n//@\n//@ All commands run synchronously, unless otherwise stated.\n//@ All commands accept standard bash globbing characters (`*`, `?`, etc.),\n//@ compatible with the [node `glob` module](https://github.com/isaacs/node-glob).\n//@\n//@ For less-commonly used commands and features, please check out our [wiki\n//@ page](https://github.com/shelljs/shelljs/wiki).\n//@\n\n// Include the docs for all the default commands\n//@commands\n\n// Load all default commands\n(__webpack_require__(/*! ./commands */ \"./node_modules/shelljs/commands.js\").forEach)(function (command) {\n  __webpack_require__(\"./node_modules/shelljs/src sync recursive ^\\\\.\\\\/.*$\")(\"./\" + command);\n});\n\n//@\n//@ ### exit(code)\n//@\n//@ Exits the current process with the given exit `code`.\nexports.exit = process.exit;\n\n//@include ./src/error\nexports.error = __webpack_require__(/*! ./src/error */ \"./node_modules/shelljs/src/error.js\");\n\n//@include ./src/common\nexports.ShellString = common.ShellString;\n\n//@\n//@ ### env['VAR_NAME']\n//@\n//@ Object containing environment variables (both getter and setter). Shortcut\n//@ to `process.env`.\nexports.env = process.env;\n\n//@\n//@ ### Pipes\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ grep('foo', 'file1.txt', 'file2.txt').sed(/o/g, 'a').to('output.txt');\n//@ echo('files with o\\'s in the name:\\n' + ls().grep('o'));\n//@ cat('test.js').exec('node'); // pipe to exec() call\n//@ ```\n//@\n//@ Commands can send their output to another command in a pipe-like fashion.\n//@ `sed`, `grep`, `cat`, `exec`, `to`, and `toEnd` can appear on the right-hand\n//@ side of a pipe. Pipes can be chained.\n\n//@\n//@ ## Configuration\n//@\n\nexports.config = common.config;\n\n//@\n//@ ### config.silent\n//@\n//@ Example:\n//@\n//@ ```javascript\n//@ var sh = require('shelljs');\n//@ var silentState = sh.config.silent; // save old silent state\n//@ sh.config.silent = true;\n//@ /* ... */\n//@ sh.config.silent = silentState; // restore old silent state\n//@ ```\n//@\n//@ Suppresses all command output if `true`, except for `echo()` calls.\n//@ Default is `false`.\n\n//@\n//@ ### config.fatal\n//@\n//@ Example:\n//@\n//@ ```javascript\n//@ require('shelljs/global');\n//@ config.fatal = true; // or set('-e');\n//@ cp('this_file_does_not_exist', '/dev/null'); // throws Error here\n//@ /* more commands... */\n//@ ```\n//@\n//@ If `true`, the script will throw a Javascript error when any shell.js\n//@ command encounters an error. Default is `false`. This is analogous to\n//@ Bash's `set -e`.\n\n//@\n//@ ### config.verbose\n//@\n//@ Example:\n//@\n//@ ```javascript\n//@ config.verbose = true; // or set('-v');\n//@ cd('dir/');\n//@ rm('-rf', 'foo.txt', 'bar.txt');\n//@ exec('echo hello');\n//@ ```\n//@\n//@ Will print each command as follows:\n//@\n//@ ```\n//@ cd dir/\n//@ rm -rf foo.txt bar.txt\n//@ exec echo hello\n//@ ```\n\n//@\n//@ ### config.globOptions\n//@\n//@ Example:\n//@\n//@ ```javascript\n//@ config.globOptions = {nodir: true};\n//@ ```\n//@\n//@ Use this value for calls to `glob.sync()` instead of the default options.\n\n//@\n//@ ### config.reset()\n//@\n//@ Example:\n//@\n//@ ```javascript\n//@ var shell = require('shelljs');\n//@ // Make changes to shell.config, and do stuff...\n//@ /* ... */\n//@ shell.config.reset(); // reset to original state\n//@ // Do more stuff, but with original settings\n//@ /* ... */\n//@ ```\n//@\n//@ Reset `shell.config` to the defaults:\n//@\n//@ ```javascript\n//@ {\n//@   fatal: false,\n//@   globOptions: {},\n//@   maxdepth: 255,\n//@   noglob: false,\n//@   silent: false,\n//@   verbose: false,\n//@ }\n//@ ```\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\shell.js");

/***/ }),

/***/ "./node_modules/shelljs/src/cat.js":
/*!*****************************************!*\
  !*** ./node_modules/shelljs/src/cat.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/shelljs/src/common.js\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\ncommon.register('cat', _cat, {\n  canReceivePipe: true,\n  cmdOptions: {\n    'n': 'number'\n  }\n});\n\n//@\n//@ ### cat([options,] file [, file ...])\n//@ ### cat([options,] file_array)\n//@\n//@ Available options:\n//@\n//@ + `-n`: number all output lines\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ var str = cat('file*.txt');\n//@ var str = cat('file1', 'file2');\n//@ var str = cat(['file1', 'file2']); // same as above\n//@ ```\n//@\n//@ Returns a string containing the given file, or a concatenated string\n//@ containing the files if more than one file is given (a new line character is\n//@ introduced between each file).\nfunction _cat(options, files) {\n  var cat = common.readFromPipe();\n  if (!files && !cat) common.error('no paths given');\n  files = [].slice.call(arguments, 1);\n  files.forEach(function (file) {\n    if (!fs.existsSync(file)) {\n      common.error('no such file or directory: ' + file);\n    } else if (common.statFollowLinks(file).isDirectory()) {\n      common.error(file + ': Is a directory');\n    }\n    cat += fs.readFileSync(file, 'utf8');\n  });\n  if (options.number) {\n    cat = addNumbers(cat);\n  }\n  return cat;\n}\nmodule.exports = _cat;\nfunction addNumbers(cat) {\n  var lines = cat.split('\\n');\n  var lastLine = lines.pop();\n  lines = lines.map(function (line, i) {\n    return numberedLine(i + 1, line);\n  });\n  if (lastLine.length) {\n    lastLine = numberedLine(lines.length + 1, lastLine);\n  }\n  lines.push(lastLine);\n  return lines.join('\\n');\n}\nfunction numberedLine(n, line) {\n  // GNU cat use six pad start number + tab. See http://lingrok.org/xref/coreutils/src/cat.c#57\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart\n  var number = ('     ' + n).slice(-6) + '\\t';\n  return number + line;\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\cat.js");

/***/ }),

/***/ "./node_modules/shelljs/src/cd.js":
/*!****************************************!*\
  !*** ./node_modules/shelljs/src/cd.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar os = __webpack_require__(/*! os */ \"os\");\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/shelljs/src/common.js\");\ncommon.register('cd', _cd, {});\n\n//@\n//@ ### cd([dir])\n//@\n//@ Changes to directory `dir` for the duration of the script. Changes to home\n//@ directory if no argument is supplied.\nfunction _cd(options, dir) {\n  if (!dir) dir = os.homedir();\n  if (dir === '-') {\n    if (!process.env.OLDPWD) {\n      common.error('could not find previous directory');\n    } else {\n      dir = process.env.OLDPWD;\n    }\n  }\n  try {\n    var curDir = process.cwd();\n    process.chdir(dir);\n    process.env.OLDPWD = curDir;\n  } catch (e) {\n    // something went wrong, let's figure out the error\n    var err;\n    try {\n      common.statFollowLinks(dir); // if this succeeds, it must be some sort of file\n      err = 'not a directory: ' + dir;\n    } catch (e2) {\n      err = 'no such file or directory: ' + dir;\n    }\n    if (err) common.error(err);\n  }\n  return '';\n}\nmodule.exports = _cd;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\cd.js");

/***/ }),

/***/ "./node_modules/shelljs/src/chmod.js":
/*!*******************************************!*\
  !*** ./node_modules/shelljs/src/chmod.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/shelljs/src/common.js\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar PERMS = function (base) {\n  return {\n    OTHER_EXEC: base.EXEC,\n    OTHER_WRITE: base.WRITE,\n    OTHER_READ: base.READ,\n    GROUP_EXEC: base.EXEC << 3,\n    GROUP_WRITE: base.WRITE << 3,\n    GROUP_READ: base.READ << 3,\n    OWNER_EXEC: base.EXEC << 6,\n    OWNER_WRITE: base.WRITE << 6,\n    OWNER_READ: base.READ << 6,\n    // Literal octal numbers are apparently not allowed in \"strict\" javascript.\n    STICKY: parseInt('01000', 8),\n    SETGID: parseInt('02000', 8),\n    SETUID: parseInt('04000', 8),\n    TYPE_MASK: parseInt('0770000', 8)\n  };\n}({\n  EXEC: 1,\n  WRITE: 2,\n  READ: 4\n});\ncommon.register('chmod', _chmod, {});\n\n//@\n//@ ### chmod([options,] octal_mode || octal_string, file)\n//@ ### chmod([options,] symbolic_mode, file)\n//@\n//@ Available options:\n//@\n//@ + `-v`: output a diagnostic for every file processed//@\n//@ + `-c`: like verbose, but report only when a change is made//@\n//@ + `-R`: change files and directories recursively//@\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ chmod(755, '/Users/brandon');\n//@ chmod('755', '/Users/brandon'); // same as above\n//@ chmod('u+x', '/Users/brandon');\n//@ chmod('-R', 'a-w', '/Users/brandon');\n//@ ```\n//@\n//@ Alters the permissions of a file or directory by either specifying the\n//@ absolute permissions in octal form or expressing the changes in symbols.\n//@ This command tries to mimic the POSIX behavior as much as possible.\n//@ Notable exceptions:\n//@\n//@ + In symbolic modes, `a-r` and `-r` are identical.  No consideration is\n//@   given to the `umask`.\n//@ + There is no \"quiet\" option, since default behavior is to run silent.\nfunction _chmod(options, mode, filePattern) {\n  if (!filePattern) {\n    if (options.length > 0 && options.charAt(0) === '-') {\n      // Special case where the specified file permissions started with - to subtract perms, which\n      // get picked up by the option parser as command flags.\n      // If we are down by one argument and options starts with -, shift everything over.\n      [].unshift.call(arguments, '');\n    } else {\n      common.error('You must specify a file.');\n    }\n  }\n  options = common.parseOptions(options, {\n    'R': 'recursive',\n    'c': 'changes',\n    'v': 'verbose'\n  });\n  filePattern = [].slice.call(arguments, 2);\n  var files;\n\n  // TODO: replace this with a call to common.expand()\n  if (options.recursive) {\n    files = [];\n    filePattern.forEach(function addFile(expandedFile) {\n      var stat = common.statNoFollowLinks(expandedFile);\n      if (!stat.isSymbolicLink()) {\n        files.push(expandedFile);\n        if (stat.isDirectory()) {\n          // intentionally does not follow symlinks.\n          fs.readdirSync(expandedFile).forEach(function (child) {\n            addFile(expandedFile + '/' + child);\n          });\n        }\n      }\n    });\n  } else {\n    files = filePattern;\n  }\n  files.forEach(function innerChmod(file) {\n    file = path.resolve(file);\n    if (!fs.existsSync(file)) {\n      common.error('File not found: ' + file);\n    }\n\n    // When recursing, don't follow symlinks.\n    if (options.recursive && common.statNoFollowLinks(file).isSymbolicLink()) {\n      return;\n    }\n    var stat = common.statFollowLinks(file);\n    var isDir = stat.isDirectory();\n    var perms = stat.mode;\n    var type = perms & PERMS.TYPE_MASK;\n    var newPerms = perms;\n    if (isNaN(parseInt(mode, 8))) {\n      // parse options\n      mode.split(',').forEach(function (symbolicMode) {\n        var pattern = /([ugoa]*)([=\\+-])([rwxXst]*)/i;\n        var matches = pattern.exec(symbolicMode);\n        if (matches) {\n          var applyTo = matches[1];\n          var operator = matches[2];\n          var change = matches[3];\n          var changeOwner = applyTo.indexOf('u') !== -1 || applyTo === 'a' || applyTo === '';\n          var changeGroup = applyTo.indexOf('g') !== -1 || applyTo === 'a' || applyTo === '';\n          var changeOther = applyTo.indexOf('o') !== -1 || applyTo === 'a' || applyTo === '';\n          var changeRead = change.indexOf('r') !== -1;\n          var changeWrite = change.indexOf('w') !== -1;\n          var changeExec = change.indexOf('x') !== -1;\n          var changeExecDir = change.indexOf('X') !== -1;\n          var changeSticky = change.indexOf('t') !== -1;\n          var changeSetuid = change.indexOf('s') !== -1;\n          if (changeExecDir && isDir) {\n            changeExec = true;\n          }\n          var mask = 0;\n          if (changeOwner) {\n            mask |= (changeRead ? PERMS.OWNER_READ : 0) + (changeWrite ? PERMS.OWNER_WRITE : 0) + (changeExec ? PERMS.OWNER_EXEC : 0) + (changeSetuid ? PERMS.SETUID : 0);\n          }\n          if (changeGroup) {\n            mask |= (changeRead ? PERMS.GROUP_READ : 0) + (changeWrite ? PERMS.GROUP_WRITE : 0) + (changeExec ? PERMS.GROUP_EXEC : 0) + (changeSetuid ? PERMS.SETGID : 0);\n          }\n          if (changeOther) {\n            mask |= (changeRead ? PERMS.OTHER_READ : 0) + (changeWrite ? PERMS.OTHER_WRITE : 0) + (changeExec ? PERMS.OTHER_EXEC : 0);\n          }\n\n          // Sticky bit is special - it's not tied to user, group or other.\n          if (changeSticky) {\n            mask |= PERMS.STICKY;\n          }\n          switch (operator) {\n            case '+':\n              newPerms |= mask;\n              break;\n            case '-':\n              newPerms &= ~mask;\n              break;\n            case '=':\n              newPerms = type + mask;\n\n              // According to POSIX, when using = to explicitly set the\n              // permissions, setuid and setgid can never be cleared.\n              if (common.statFollowLinks(file).isDirectory()) {\n                newPerms |= PERMS.SETUID + PERMS.SETGID & perms;\n              }\n              break;\n            default:\n              common.error('Could not recognize operator: `' + operator + '`');\n          }\n          if (options.verbose) {\n            console.log(file + ' -> ' + newPerms.toString(8));\n          }\n          if (perms !== newPerms) {\n            if (!options.verbose && options.changes) {\n              console.log(file + ' -> ' + newPerms.toString(8));\n            }\n            fs.chmodSync(file, newPerms);\n            perms = newPerms; // for the next round of changes!\n          }\n        } else {\n          common.error('Invalid symbolic mode change: ' + symbolicMode);\n        }\n      });\n    } else {\n      // they gave us a full number\n      newPerms = type + parseInt(mode, 8);\n\n      // POSIX rules are that setuid and setgid can only be added using numeric\n      // form, but not cleared.\n      if (common.statFollowLinks(file).isDirectory()) {\n        newPerms |= PERMS.SETUID + PERMS.SETGID & perms;\n      }\n      fs.chmodSync(file, newPerms);\n    }\n  });\n  return '';\n}\nmodule.exports = _chmod;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\chmod.js");

/***/ }),

/***/ "./node_modules/shelljs/src/common.js":
/*!********************************************!*\
  !*** ./node_modules/shelljs/src/common.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("// Ignore warning about 'new String()'\n/* eslint no-new-wrappers: 0 */\n\n\nvar os = __webpack_require__(/*! os */ \"os\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar glob = __webpack_require__(/*! glob */ \"./node_modules/shelljs/node_modules/glob/glob.js\");\nvar shell = __webpack_require__(/*! .. */ \"./node_modules/shelljs/shell.js\");\nvar shellMethods = Object.create(shell);\nexports.extend = Object.assign;\n\n// Check if we're running under electron\nvar isElectron = Boolean(process.versions.electron);\n\n// Module globals (assume no execPath by default)\nvar DEFAULT_CONFIG = {\n  fatal: false,\n  globOptions: {},\n  maxdepth: 255,\n  noglob: false,\n  silent: false,\n  verbose: false,\n  execPath: null,\n  bufLength: 64 * 1024 // 64KB\n};\n\nvar config = {\n  reset: function reset() {\n    Object.assign(this, DEFAULT_CONFIG);\n    if (!isElectron) {\n      this.execPath = process.execPath;\n    }\n  },\n  resetForTesting: function resetForTesting() {\n    this.reset();\n    this.silent = true;\n  }\n};\nconfig.reset();\nexports.config = config;\n\n// Note: commands should generally consider these as read-only values.\nvar state = {\n  error: null,\n  errorCode: 0,\n  currentCmd: 'shell.js'\n};\nexports.state = state;\ndelete process.env.OLDPWD; // initially, there's no previous directory\n\n// Reliably test if something is any sort of javascript object\nfunction isObject(a) {\n  return typeof a === 'object' && a !== null;\n}\nexports.isObject = isObject;\nfunction log() {\n  /* istanbul ignore next */\n  if (!config.silent) {\n    console.error.apply(console, arguments);\n  }\n}\nexports.log = log;\n\n// Converts strings to be equivalent across all platforms. Primarily responsible\n// for making sure we use '/' instead of '\\' as path separators, but this may be\n// expanded in the future if necessary\nfunction convertErrorOutput(msg) {\n  if (typeof msg !== 'string') {\n    throw new TypeError('input must be a string');\n  }\n  return msg.replace(/\\\\/g, '/');\n}\nexports.convertErrorOutput = convertErrorOutput;\n\n// Shows error message. Throws if config.fatal is true\nfunction error(msg, _code, options) {\n  // Validate input\n  if (typeof msg !== 'string') throw new Error('msg must be a string');\n  var DEFAULT_OPTIONS = {\n    continue: false,\n    code: 1,\n    prefix: state.currentCmd + ': ',\n    silent: false\n  };\n  if (typeof _code === 'number' && isObject(options)) {\n    options.code = _code;\n  } else if (isObject(_code)) {\n    // no 'code'\n    options = _code;\n  } else if (typeof _code === 'number') {\n    // no 'options'\n    options = {\n      code: _code\n    };\n  } else if (typeof _code !== 'number') {\n    // only 'msg'\n    options = {};\n  }\n  options = Object.assign({}, DEFAULT_OPTIONS, options);\n  if (!state.errorCode) state.errorCode = options.code;\n  var logEntry = convertErrorOutput(options.prefix + msg);\n  state.error = state.error ? state.error + '\\n' : '';\n  state.error += logEntry;\n\n  // Throw an error, or log the entry\n  if (config.fatal) throw new Error(logEntry);\n  if (msg.length > 0 && !options.silent) log(logEntry);\n  if (!options.continue) {\n    throw {\n      msg: 'earlyExit',\n      retValue: new ShellString('', state.error, state.errorCode)\n    };\n  }\n}\nexports.error = error;\n\n//@\n//@ ### ShellString(str)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ var foo = ShellString('hello world');\n//@ ```\n//@\n//@ Turns a regular string into a string-like object similar to what each\n//@ command returns. This has special methods, like `.to()` and `.toEnd()`.\nfunction ShellString(stdout, stderr, code) {\n  var that;\n  if (stdout instanceof Array) {\n    that = stdout;\n    that.stdout = stdout.join('\\n');\n    if (stdout.length > 0) that.stdout += '\\n';\n  } else {\n    that = new String(stdout);\n    that.stdout = stdout;\n  }\n  that.stderr = stderr;\n  that.code = code;\n  // A list of all commands that can appear on the right-hand side of a pipe\n  // (populated by calls to common.wrap())\n  pipeMethods.forEach(function (cmd) {\n    that[cmd] = shellMethods[cmd].bind(that);\n  });\n  return that;\n}\nexports.ShellString = ShellString;\n\n// Returns {'alice': true, 'bob': false} when passed a string and dictionary as follows:\n//   parseOptions('-a', {'a':'alice', 'b':'bob'});\n// Returns {'reference': 'string-value', 'bob': false} when passed two dictionaries of the form:\n//   parseOptions({'-r': 'string-value'}, {'r':'reference', 'b':'bob'});\n// Throws an error when passed a string that does not start with '-':\n//   parseOptions('a', {'a':'alice'}); // throws\nfunction parseOptions(opt, map, errorOptions) {\n  // Validate input\n  if (typeof opt !== 'string' && !isObject(opt)) {\n    throw new Error('options must be strings or key-value pairs');\n  } else if (!isObject(map)) {\n    throw new Error('parseOptions() internal error: map must be an object');\n  } else if (errorOptions && !isObject(errorOptions)) {\n    throw new Error('parseOptions() internal error: errorOptions must be object');\n  }\n  if (opt === '--') {\n    // This means there are no options.\n    return {};\n  }\n\n  // All options are false by default\n  var options = {};\n  Object.keys(map).forEach(function (letter) {\n    var optName = map[letter];\n    if (optName[0] !== '!') {\n      options[optName] = false;\n    }\n  });\n  if (opt === '') return options; // defaults\n\n  if (typeof opt === 'string') {\n    if (opt[0] !== '-') {\n      throw new Error(\"Options string must start with a '-'\");\n    }\n\n    // e.g. chars = ['R', 'f']\n    var chars = opt.slice(1).split('');\n    chars.forEach(function (c) {\n      if (c in map) {\n        var optionName = map[c];\n        if (optionName[0] === '!') {\n          options[optionName.slice(1)] = false;\n        } else {\n          options[optionName] = true;\n        }\n      } else {\n        error('option not recognized: ' + c, errorOptions || {});\n      }\n    });\n  } else {\n    // opt is an Object\n    Object.keys(opt).forEach(function (key) {\n      // key is a string of the form '-r', '-d', etc.\n      var c = key[1];\n      if (c in map) {\n        var optionName = map[c];\n        options[optionName] = opt[key]; // assign the given value\n      } else {\n        error('option not recognized: ' + c, errorOptions || {});\n      }\n    });\n  }\n  return options;\n}\nexports.parseOptions = parseOptions;\n\n// Expands wildcards with matching (ie. existing) file names.\n// For example:\n//   expand(['file*.js']) = ['file1.js', 'file2.js', ...]\n//   (if the files 'file1.js', 'file2.js', etc, exist in the current dir)\nfunction expand(list) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('must be an array');\n  }\n  var expanded = [];\n  list.forEach(function (listEl) {\n    // Don't expand non-strings\n    if (typeof listEl !== 'string') {\n      expanded.push(listEl);\n    } else {\n      var ret;\n      try {\n        ret = glob.sync(listEl, config.globOptions);\n        // if nothing matched, interpret the string literally\n        ret = ret.length > 0 ? ret : [listEl];\n      } catch (e) {\n        // if glob fails, interpret the string literally\n        ret = [listEl];\n      }\n      expanded = expanded.concat(ret);\n    }\n  });\n  return expanded;\n}\nexports.expand = expand;\n\n// Normalizes Buffer creation, using Buffer.alloc if possible.\n// Also provides a good default buffer length for most use cases.\nvar buffer = typeof Buffer.alloc === 'function' ? function (len) {\n  return Buffer.alloc(len || config.bufLength);\n} : function (len) {\n  return new Buffer(len || config.bufLength);\n};\nexports.buffer = buffer;\n\n// Normalizes _unlinkSync() across platforms to match Unix behavior, i.e.\n// file can be unlinked even if it's read-only, see https://github.com/joyent/node/issues/3006\nfunction unlinkSync(file) {\n  try {\n    fs.unlinkSync(file);\n  } catch (e) {\n    // Try to override file permission\n    /* istanbul ignore next */\n    if (e.code === 'EPERM') {\n      fs.chmodSync(file, '0666');\n      fs.unlinkSync(file);\n    } else {\n      throw e;\n    }\n  }\n}\nexports.unlinkSync = unlinkSync;\n\n// wrappers around common.statFollowLinks and common.statNoFollowLinks that clarify intent\n// and improve readability\nfunction statFollowLinks() {\n  return fs.statSync.apply(fs, arguments);\n}\nexports.statFollowLinks = statFollowLinks;\nfunction statNoFollowLinks() {\n  return fs.lstatSync.apply(fs, arguments);\n}\nexports.statNoFollowLinks = statNoFollowLinks;\n\n// e.g. 'shelljs_a5f185d0443ca...'\nfunction randomFileName() {\n  function randomHash(count) {\n    if (count === 1) {\n      return parseInt(16 * Math.random(), 10).toString(16);\n    }\n    var hash = '';\n    for (var i = 0; i < count; i++) {\n      hash += randomHash(1);\n    }\n    return hash;\n  }\n  return 'shelljs_' + randomHash(20);\n}\nexports.randomFileName = randomFileName;\n\n// Common wrapper for all Unix-like commands that performs glob expansion,\n// command-logging, and other nice things\nfunction wrap(cmd, fn, options) {\n  options = options || {};\n  return function () {\n    var retValue = null;\n    state.currentCmd = cmd;\n    state.error = null;\n    state.errorCode = 0;\n    try {\n      var args = [].slice.call(arguments, 0);\n\n      // Log the command to stderr, if appropriate\n      if (config.verbose) {\n        console.error.apply(console, [cmd].concat(args));\n      }\n\n      // If this is coming from a pipe, let's set the pipedValue (otherwise, set\n      // it to the empty string)\n      state.pipedValue = this && typeof this.stdout === 'string' ? this.stdout : '';\n      if (options.unix === false) {\n        // this branch is for exec()\n        retValue = fn.apply(this, args);\n      } else {\n        // and this branch is for everything else\n        if (isObject(args[0]) && args[0].constructor.name === 'Object') {\n          // a no-op, allowing the syntax `touch({'-r': file}, ...)`\n        } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length <= 1 || args[0][0] !== '-') {\n          args.unshift(''); // only add dummy option if '-option' not already present\n        }\n\n        // flatten out arrays that are arguments, to make the syntax:\n        //    `cp([file1, file2, file3], dest);`\n        // equivalent to:\n        //    `cp(file1, file2, file3, dest);`\n        args = args.reduce(function (accum, cur) {\n          if (Array.isArray(cur)) {\n            return accum.concat(cur);\n          }\n          accum.push(cur);\n          return accum;\n        }, []);\n\n        // Convert ShellStrings (basically just String objects) to regular strings\n        args = args.map(function (arg) {\n          if (isObject(arg) && arg.constructor.name === 'String') {\n            return arg.toString();\n          }\n          return arg;\n        });\n\n        // Expand the '~' if appropriate\n        var homeDir = os.homedir();\n        args = args.map(function (arg) {\n          if (typeof arg === 'string' && arg.slice(0, 2) === '~/' || arg === '~') {\n            return arg.replace(/^~/, homeDir);\n          }\n          return arg;\n        });\n\n        // Perform glob-expansion on all arguments after globStart, but preserve\n        // the arguments before it (like regexes for sed and grep)\n        if (!config.noglob && options.allowGlobbing === true) {\n          args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));\n        }\n        try {\n          // parse options if options are provided\n          if (isObject(options.cmdOptions)) {\n            args[0] = parseOptions(args[0], options.cmdOptions);\n          }\n          retValue = fn.apply(this, args);\n        } catch (e) {\n          /* istanbul ignore else */\n          if (e.msg === 'earlyExit') {\n            retValue = e.retValue;\n          } else {\n            throw e; // this is probably a bug that should be thrown up the call stack\n          }\n        }\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      if (!state.error) {\n        // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...\n        e.name = 'ShellJSInternalError';\n        throw e;\n      }\n      if (config.fatal) throw e;\n    }\n    if (options.wrapOutput && (typeof retValue === 'string' || Array.isArray(retValue))) {\n      retValue = new ShellString(retValue, state.error, state.errorCode);\n    }\n    state.currentCmd = 'shell.js';\n    return retValue;\n  };\n} // wrap\nexports.wrap = wrap;\n\n// This returns all the input that is piped into the current command (or the\n// empty string, if this isn't on the right-hand side of a pipe\nfunction _readFromPipe() {\n  return state.pipedValue;\n}\nexports.readFromPipe = _readFromPipe;\nvar DEFAULT_WRAP_OPTIONS = {\n  allowGlobbing: true,\n  canReceivePipe: false,\n  cmdOptions: null,\n  globStart: 1,\n  pipeOnly: false,\n  wrapOutput: true,\n  unix: true\n};\n\n// This is populated during plugin registration\nvar pipeMethods = [];\n\n// Register a new ShellJS command\nfunction _register(name, implementation, wrapOptions) {\n  wrapOptions = wrapOptions || {};\n\n  // Validate options\n  Object.keys(wrapOptions).forEach(function (option) {\n    if (!DEFAULT_WRAP_OPTIONS.hasOwnProperty(option)) {\n      throw new Error(\"Unknown option '\" + option + \"'\");\n    }\n    if (typeof wrapOptions[option] !== typeof DEFAULT_WRAP_OPTIONS[option]) {\n      throw new TypeError(\"Unsupported type '\" + typeof wrapOptions[option] + \"' for option '\" + option + \"'\");\n    }\n  });\n\n  // If an option isn't specified, use the default\n  wrapOptions = Object.assign({}, DEFAULT_WRAP_OPTIONS, wrapOptions);\n  if (shell.hasOwnProperty(name)) {\n    throw new Error('Command `' + name + '` already exists');\n  }\n  if (wrapOptions.pipeOnly) {\n    wrapOptions.canReceivePipe = true;\n    shellMethods[name] = wrap(name, implementation, wrapOptions);\n  } else {\n    shell[name] = wrap(name, implementation, wrapOptions);\n  }\n  if (wrapOptions.canReceivePipe) {\n    pipeMethods.push(name);\n  }\n}\nexports.register = _register;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\common.js");

/***/ }),

/***/ "./node_modules/shelljs/src/cp.js":
/*!****************************************!*\
  !*** ./node_modules/shelljs/src/cp.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/shelljs/src/common.js\");\ncommon.register('cp', _cp, {\n  cmdOptions: {\n    'f': '!no_force',\n    'n': 'no_force',\n    'u': 'update',\n    'R': 'recursive',\n    'r': 'recursive',\n    'L': 'followsymlink',\n    'P': 'noFollowsymlink'\n  },\n  wrapOutput: false\n});\n\n// Buffered file copy, synchronous\n// (Using readFileSync() + writeFileSync() could easily cause a memory overflow\n//  with large files)\nfunction copyFileSync(srcFile, destFile, options) {\n  if (!fs.existsSync(srcFile)) {\n    common.error('copyFileSync: no such file or directory: ' + srcFile);\n  }\n  var isWindows = process.platform === 'win32';\n\n  // Check the mtimes of the files if the '-u' flag is provided\n  try {\n    if (options.update && common.statFollowLinks(srcFile).mtime < fs.statSync(destFile).mtime) {\n      return;\n    }\n  } catch (e) {\n    // If we're here, destFile probably doesn't exist, so just do a normal copy\n  }\n  if (common.statNoFollowLinks(srcFile).isSymbolicLink() && !options.followsymlink) {\n    try {\n      common.statNoFollowLinks(destFile);\n      common.unlinkSync(destFile); // re-link it\n    } catch (e) {\n      // it doesn't exist, so no work needs to be done\n    }\n    var symlinkFull = fs.readlinkSync(srcFile);\n    fs.symlinkSync(symlinkFull, destFile, isWindows ? 'junction' : null);\n  } else {\n    var buf = common.buffer();\n    var bufLength = buf.length;\n    var bytesRead = bufLength;\n    var pos = 0;\n    var fdr = null;\n    var fdw = null;\n    try {\n      fdr = fs.openSync(srcFile, 'r');\n    } catch (e) {\n      /* istanbul ignore next */\n      common.error('copyFileSync: could not read src file (' + srcFile + ')');\n    }\n    try {\n      fdw = fs.openSync(destFile, 'w');\n    } catch (e) {\n      /* istanbul ignore next */\n      common.error('copyFileSync: could not write to dest file (code=' + e.code + '):' + destFile);\n    }\n    while (bytesRead === bufLength) {\n      bytesRead = fs.readSync(fdr, buf, 0, bufLength, pos);\n      fs.writeSync(fdw, buf, 0, bytesRead);\n      pos += bytesRead;\n    }\n    fs.closeSync(fdr);\n    fs.closeSync(fdw);\n    fs.chmodSync(destFile, common.statFollowLinks(srcFile).mode);\n  }\n}\n\n// Recursively copies 'sourceDir' into 'destDir'\n// Adapted from https://github.com/ryanmcgrath/wrench-js\n//\n// Copyright (c) 2010 Ryan McGrath\n// Copyright (c) 2012 Artur Adib\n//\n// Licensed under the MIT License\n// http://www.opensource.org/licenses/mit-license.php\nfunction cpdirSyncRecursive(sourceDir, destDir, currentDepth, opts) {\n  if (!opts) opts = {};\n\n  // Ensure there is not a run away recursive copy\n  if (currentDepth >= common.config.maxdepth) return;\n  currentDepth++;\n  var isWindows = process.platform === 'win32';\n\n  // Create the directory where all our junk is moving to; read the mode of the\n  // source directory and mirror it\n  try {\n    fs.mkdirSync(destDir);\n  } catch (e) {\n    // if the directory already exists, that's okay\n    if (e.code !== 'EEXIST') throw e;\n  }\n  var files = fs.readdirSync(sourceDir);\n  for (var i = 0; i < files.length; i++) {\n    var srcFile = sourceDir + '/' + files[i];\n    var destFile = destDir + '/' + files[i];\n    var srcFileStat = common.statNoFollowLinks(srcFile);\n    var symlinkFull;\n    if (opts.followsymlink) {\n      if (cpcheckcycle(sourceDir, srcFile)) {\n        // Cycle link found.\n        console.error('Cycle link found.');\n        symlinkFull = fs.readlinkSync(srcFile);\n        fs.symlinkSync(symlinkFull, destFile, isWindows ? 'junction' : null);\n        continue;\n      }\n    }\n    if (srcFileStat.isDirectory()) {\n      /* recursion this thing right on back. */\n      cpdirSyncRecursive(srcFile, destFile, currentDepth, opts);\n    } else if (srcFileStat.isSymbolicLink() && !opts.followsymlink) {\n      symlinkFull = fs.readlinkSync(srcFile);\n      try {\n        common.statNoFollowLinks(destFile);\n        common.unlinkSync(destFile); // re-link it\n      } catch (e) {\n        // it doesn't exist, so no work needs to be done\n      }\n      fs.symlinkSync(symlinkFull, destFile, isWindows ? 'junction' : null);\n    } else if (srcFileStat.isSymbolicLink() && opts.followsymlink) {\n      srcFileStat = common.statFollowLinks(srcFile);\n      if (srcFileStat.isDirectory()) {\n        cpdirSyncRecursive(srcFile, destFile, currentDepth, opts);\n      } else {\n        copyFileSync(srcFile, destFile, opts);\n      }\n    } else {\n      /* At this point, we've hit a file actually worth copying... so copy it on over. */\n      if (fs.existsSync(destFile) && opts.no_force) {\n        common.log('skipping existing file: ' + files[i]);\n      } else {\n        copyFileSync(srcFile, destFile, opts);\n      }\n    }\n  } // for files\n\n  // finally change the mode for the newly created directory (otherwise, we\n  // couldn't add files to a read-only directory).\n  var checkDir = common.statFollowLinks(sourceDir);\n  fs.chmodSync(destDir, checkDir.mode);\n} // cpdirSyncRecursive\n\n// Checks if cureent file was created recently\nfunction checkRecentCreated(sources, index) {\n  var lookedSource = sources[index];\n  return sources.slice(0, index).some(function (src) {\n    return path.basename(src) === path.basename(lookedSource);\n  });\n}\nfunction cpcheckcycle(sourceDir, srcFile) {\n  var srcFileStat = common.statNoFollowLinks(srcFile);\n  if (srcFileStat.isSymbolicLink()) {\n    // Do cycle check. For example:\n    //   $ mkdir -p 1/2/3/4\n    //   $ cd  1/2/3/4\n    //   $ ln -s ../../3 link\n    //   $ cd ../../../..\n    //   $ cp -RL 1 copy\n    var cyclecheck = common.statFollowLinks(srcFile);\n    if (cyclecheck.isDirectory()) {\n      var sourcerealpath = fs.realpathSync(sourceDir);\n      var symlinkrealpath = fs.realpathSync(srcFile);\n      var re = new RegExp(symlinkrealpath);\n      if (re.test(sourcerealpath)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n//@\n//@ ### cp([options,] source [, source ...], dest)\n//@ ### cp([options,] source_array, dest)\n//@\n//@ Available options:\n//@\n//@ + `-f`: force (default behavior)\n//@ + `-n`: no-clobber\n//@ + `-u`: only copy if `source` is newer than `dest`\n//@ + `-r`, `-R`: recursive\n//@ + `-L`: follow symlinks\n//@ + `-P`: don't follow symlinks\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ cp('file1', 'dir1');\n//@ cp('-R', 'path/to/dir/', '~/newCopy/');\n//@ cp('-Rf', '/tmp/*', '/usr/local/*', '/home/tmp');\n//@ cp('-Rf', ['/tmp/*', '/usr/local/*'], '/home/tmp'); // same as above\n//@ ```\n//@\n//@ Copies files.\nfunction _cp(options, sources, dest) {\n  // If we're missing -R, it actually implies -L (unless -P is explicit)\n  if (options.followsymlink) {\n    options.noFollowsymlink = false;\n  }\n  if (!options.recursive && !options.noFollowsymlink) {\n    options.followsymlink = true;\n  }\n\n  // Get sources, dest\n  if (arguments.length < 3) {\n    common.error('missing <source> and/or <dest>');\n  } else {\n    sources = [].slice.call(arguments, 1, arguments.length - 1);\n    dest = arguments[arguments.length - 1];\n  }\n  var destExists = fs.existsSync(dest);\n  var destStat = destExists && common.statFollowLinks(dest);\n\n  // Dest is not existing dir, but multiple sources given\n  if ((!destExists || !destStat.isDirectory()) && sources.length > 1) {\n    common.error('dest is not a directory (too many sources)');\n  }\n\n  // Dest is an existing file, but -n is given\n  if (destExists && destStat.isFile() && options.no_force) {\n    return new common.ShellString('', '', 0);\n  }\n  sources.forEach(function (src, srcIndex) {\n    if (!fs.existsSync(src)) {\n      if (src === '') src = \"''\"; // if src was empty string, display empty string\n      common.error('no such file or directory: ' + src, {\n        continue: true\n      });\n      return; // skip file\n    }\n\n    var srcStat = common.statFollowLinks(src);\n    if (!options.noFollowsymlink && srcStat.isDirectory()) {\n      if (!options.recursive) {\n        // Non-Recursive\n        common.error(\"omitting directory '\" + src + \"'\", {\n          continue: true\n        });\n      } else {\n        // Recursive\n        // 'cp /a/source dest' should create 'source' in 'dest'\n        var newDest = destStat && destStat.isDirectory() ? path.join(dest, path.basename(src)) : dest;\n        try {\n          common.statFollowLinks(path.dirname(dest));\n          cpdirSyncRecursive(src, newDest, 0, {\n            no_force: options.no_force,\n            followsymlink: options.followsymlink\n          });\n        } catch (e) {\n          /* istanbul ignore next */\n          common.error(\"cannot create directory '\" + dest + \"': No such file or directory\");\n        }\n      }\n    } else {\n      // If here, src is a file\n\n      // When copying to '/path/dir':\n      //    thisDest = '/path/dir/file1'\n      var thisDest = dest;\n      if (destStat && destStat.isDirectory()) {\n        thisDest = path.normalize(dest + '/' + path.basename(src));\n      }\n      var thisDestExists = fs.existsSync(thisDest);\n      if (thisDestExists && checkRecentCreated(sources, srcIndex)) {\n        // cannot overwrite file created recently in current execution, but we want to continue copying other files\n        if (!options.no_force) {\n          common.error(\"will not overwrite just-created '\" + thisDest + \"' with '\" + src + \"'\", {\n            continue: true\n          });\n        }\n        return;\n      }\n      if (thisDestExists && options.no_force) {\n        return; // skip file\n      }\n\n      if (path.relative(src, thisDest) === '') {\n        // a file cannot be copied to itself, but we want to continue copying other files\n        common.error(\"'\" + thisDest + \"' and '\" + src + \"' are the same file\", {\n          continue: true\n        });\n        return;\n      }\n      copyFileSync(src, thisDest, options);\n    }\n  }); // forEach(src)\n\n  return new common.ShellString('', common.state.error, common.state.errorCode);\n}\nmodule.exports = _cp;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\cp.js");

/***/ }),

/***/ "./node_modules/shelljs/src/dirs.js":
/*!******************************************!*\
  !*** ./node_modules/shelljs/src/dirs.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/shelljs/src/common.js\");\nvar _cd = __webpack_require__(/*! ./cd */ \"./node_modules/shelljs/src/cd.js\");\nvar path = __webpack_require__(/*! path */ \"path\");\ncommon.register('dirs', _dirs, {\n  wrapOutput: false\n});\ncommon.register('pushd', _pushd, {\n  wrapOutput: false\n});\ncommon.register('popd', _popd, {\n  wrapOutput: false\n});\n\n// Pushd/popd/dirs internals\nvar _dirStack = [];\nfunction _isStackIndex(index) {\n  return /^[\\-+]\\d+$/.test(index);\n}\nfunction _parseStackIndex(index) {\n  if (_isStackIndex(index)) {\n    if (Math.abs(index) < _dirStack.length + 1) {\n      // +1 for pwd\n      return /^-/.test(index) ? Number(index) - 1 : Number(index);\n    }\n    common.error(index + ': directory stack index out of range');\n  } else {\n    common.error(index + ': invalid number');\n  }\n}\nfunction _actualDirStack() {\n  return [process.cwd()].concat(_dirStack);\n}\n\n//@\n//@ ### pushd([options,] [dir | '-N' | '+N'])\n//@\n//@ Available options:\n//@\n//@ + `-n`: Suppresses the normal change of directory when adding directories to the stack, so that only the stack is manipulated.\n//@ + `-q`: Supresses output to the console.\n//@\n//@ Arguments:\n//@\n//@ + `dir`: Sets the current working directory to the top of the stack, then executes the equivalent of `cd dir`.\n//@ + `+N`: Brings the Nth directory (counting from the left of the list printed by dirs, starting with zero) to the top of the list by rotating the stack.\n//@ + `-N`: Brings the Nth directory (counting from the right of the list printed by dirs, starting with zero) to the top of the list by rotating the stack.\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ // process.cwd() === '/usr'\n//@ pushd('/etc'); // Returns /etc /usr\n//@ pushd('+1');   // Returns /usr /etc\n//@ ```\n//@\n//@ Save the current directory on the top of the directory stack and then `cd` to `dir`. With no arguments, `pushd` exchanges the top two directories. Returns an array of paths in the stack.\nfunction _pushd(options, dir) {\n  if (_isStackIndex(options)) {\n    dir = options;\n    options = '';\n  }\n  options = common.parseOptions(options, {\n    'n': 'no-cd',\n    'q': 'quiet'\n  });\n  var dirs = _actualDirStack();\n  if (dir === '+0') {\n    return dirs; // +0 is a noop\n  } else if (!dir) {\n    if (dirs.length > 1) {\n      dirs = dirs.splice(1, 1).concat(dirs);\n    } else {\n      return common.error('no other directory');\n    }\n  } else if (_isStackIndex(dir)) {\n    var n = _parseStackIndex(dir);\n    dirs = dirs.slice(n).concat(dirs.slice(0, n));\n  } else {\n    if (options['no-cd']) {\n      dirs.splice(1, 0, dir);\n    } else {\n      dirs.unshift(dir);\n    }\n  }\n  if (options['no-cd']) {\n    dirs = dirs.slice(1);\n  } else {\n    dir = path.resolve(dirs.shift());\n    _cd('', dir);\n  }\n  _dirStack = dirs;\n  return _dirs(options.quiet ? '-q' : '');\n}\nexports.pushd = _pushd;\n\n//@\n//@\n//@ ### popd([options,] ['-N' | '+N'])\n//@\n//@ Available options:\n//@\n//@ + `-n`: Suppress the normal directory change when removing directories from the stack, so that only the stack is manipulated.\n//@ + `-q`: Supresses output to the console.\n//@\n//@ Arguments:\n//@\n//@ + `+N`: Removes the Nth directory (counting from the left of the list printed by dirs), starting with zero.\n//@ + `-N`: Removes the Nth directory (counting from the right of the list printed by dirs), starting with zero.\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ echo(process.cwd()); // '/usr'\n//@ pushd('/etc');       // '/etc /usr'\n//@ echo(process.cwd()); // '/etc'\n//@ popd();              // '/usr'\n//@ echo(process.cwd()); // '/usr'\n//@ ```\n//@\n//@ When no arguments are given, `popd` removes the top directory from the stack and performs a `cd` to the new top directory. The elements are numbered from 0, starting at the first directory listed with dirs (i.e., `popd` is equivalent to `popd +0`). Returns an array of paths in the stack.\nfunction _popd(options, index) {\n  if (_isStackIndex(options)) {\n    index = options;\n    options = '';\n  }\n  options = common.parseOptions(options, {\n    'n': 'no-cd',\n    'q': 'quiet'\n  });\n  if (!_dirStack.length) {\n    return common.error('directory stack empty');\n  }\n  index = _parseStackIndex(index || '+0');\n  if (options['no-cd'] || index > 0 || _dirStack.length + index === 0) {\n    index = index > 0 ? index - 1 : index;\n    _dirStack.splice(index, 1);\n  } else {\n    var dir = path.resolve(_dirStack.shift());\n    _cd('', dir);\n  }\n  return _dirs(options.quiet ? '-q' : '');\n}\nexports.popd = _popd;\n\n//@\n//@\n//@ ### dirs([options | '+N' | '-N'])\n//@\n//@ Available options:\n//@\n//@ + `-c`: Clears the directory stack by deleting all of the elements.\n//@ + `-q`: Supresses output to the console.\n//@\n//@ Arguments:\n//@\n//@ + `+N`: Displays the Nth directory (counting from the left of the list printed by dirs when invoked without options), starting with zero.\n//@ + `-N`: Displays the Nth directory (counting from the right of the list printed by dirs when invoked without options), starting with zero.\n//@\n//@ Display the list of currently remembered directories. Returns an array of paths in the stack, or a single path if `+N` or `-N` was specified.\n//@\n//@ See also: `pushd`, `popd`\nfunction _dirs(options, index) {\n  if (_isStackIndex(options)) {\n    index = options;\n    options = '';\n  }\n  options = common.parseOptions(options, {\n    'c': 'clear',\n    'q': 'quiet'\n  });\n  if (options.clear) {\n    _dirStack = [];\n    return _dirStack;\n  }\n  var stack = _actualDirStack();\n  if (index) {\n    index = _parseStackIndex(index);\n    if (index < 0) {\n      index = stack.length + index;\n    }\n    if (!options.quiet) {\n      common.log(stack[index]);\n    }\n    return stack[index];\n  }\n  if (!options.quiet) {\n    common.log(stack.join(' '));\n  }\n  return stack;\n}\nexports.dirs = _dirs;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\dirs.js");

/***/ }),

/***/ "./node_modules/shelljs/src/echo.js":
/*!******************************************!*\
  !*** ./node_modules/shelljs/src/echo.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar format = (__webpack_require__(/*! util */ \"util\").format);\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/shelljs/src/common.js\");\ncommon.register('echo', _echo, {\n  allowGlobbing: false\n});\n\n//@\n//@ ### echo([options,] string [, string ...])\n//@\n//@ Available options:\n//@\n//@ + `-e`: interpret backslash escapes (default)\n//@ + `-n`: remove trailing newline from output\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ echo('hello world');\n//@ var str = echo('hello world');\n//@ echo('-n', 'no newline at end');\n//@ ```\n//@\n//@ Prints `string` to stdout, and returns string with additional utility methods\n//@ like `.to()`.\nfunction _echo(opts) {\n  // allow strings starting with '-', see issue #20\n  var messages = [].slice.call(arguments, opts ? 0 : 1);\n  var options = {};\n\n  // If the first argument starts with '-', parse it as options string.\n  // If parseOptions throws, it wasn't an options string.\n  try {\n    options = common.parseOptions(messages[0], {\n      'e': 'escapes',\n      'n': 'no_newline'\n    }, {\n      silent: true\n    });\n\n    // Allow null to be echoed\n    if (messages[0]) {\n      messages.shift();\n    }\n  } catch (_) {\n    // Clear out error if an error occurred\n    common.state.error = null;\n  }\n  var output = format.apply(null, messages);\n\n  // Add newline if -n is not passed.\n  if (!options.no_newline) {\n    output += '\\n';\n  }\n  process.stdout.write(output);\n  return output;\n}\nmodule.exports = _echo;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\echo.js");

/***/ }),

/***/ "./node_modules/shelljs/src/error.js":
/*!*******************************************!*\
  !*** ./node_modules/shelljs/src/error.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/shelljs/src/common.js\");\n\n//@\n//@ ### error()\n//@\n//@ Tests if error occurred in the last command. Returns a truthy value if an\n//@ error returned, or a falsy value otherwise.\n//@\n//@ **Note**: do not rely on the\n//@ return value to be an error message. If you need the last error message, use\n//@ the `.stderr` attribute from the last command's return value instead.\nfunction error() {\n  return common.state.error;\n}\nmodule.exports = error;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\error.js");

/***/ }),

/***/ "./node_modules/shelljs/src/exec-child.js":
/*!************************************************!*\
  !*** ./node_modules/shelljs/src/exec-child.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\n\n\nif (__webpack_require__.c[__webpack_require__.s] !== module) {\n  throw new Error('This file should not be required');\n}\nvar childProcess = __webpack_require__(/*! child_process */ \"child_process\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar paramFilePath = process.argv[2];\nvar serializedParams = fs.readFileSync(paramFilePath, 'utf8');\nvar params = JSON.parse(serializedParams);\nvar cmd = params.command;\nvar execOptions = params.execOptions;\nvar pipe = params.pipe;\nvar stdoutFile = params.stdoutFile;\nvar stderrFile = params.stderrFile;\nvar c = childProcess.exec(cmd, execOptions, function (err) {\n  if (!err) {\n    process.exitCode = 0;\n  } else if (err.code === undefined) {\n    process.exitCode = 1;\n  } else {\n    process.exitCode = err.code;\n  }\n});\nvar stdoutStream = fs.createWriteStream(stdoutFile);\nvar stderrStream = fs.createWriteStream(stderrFile);\nc.stdout.pipe(stdoutStream);\nc.stderr.pipe(stderrStream);\nc.stdout.pipe(process.stdout);\nc.stderr.pipe(process.stderr);\nif (pipe) {\n  c.stdin.end(pipe);\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\exec-child.js");

/***/ }),

/***/ "./node_modules/shelljs/src/exec.js":
/*!******************************************!*\
  !*** ./node_modules/shelljs/src/exec.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/shelljs/src/common.js\");\nvar _tempDir = (__webpack_require__(/*! ./tempdir */ \"./node_modules/shelljs/src/tempdir.js\").tempDir);\nvar _pwd = __webpack_require__(/*! ./pwd */ \"./node_modules/shelljs/src/pwd.js\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar child = __webpack_require__(/*! child_process */ \"child_process\");\nvar DEFAULT_MAXBUFFER_SIZE = 20 * 1024 * 1024;\nvar DEFAULT_ERROR_CODE = 1;\ncommon.register('exec', _exec, {\n  unix: false,\n  canReceivePipe: true,\n  wrapOutput: false\n});\n\n// We use this function to run `exec` synchronously while also providing realtime\n// output.\nfunction execSync(cmd, opts, pipe) {\n  if (!common.config.execPath) {\n    common.error('Unable to find a path to the node binary. Please manually set config.execPath');\n  }\n  var tempDir = _tempDir();\n  var paramsFile = path.resolve(tempDir + '/' + common.randomFileName());\n  var stderrFile = path.resolve(tempDir + '/' + common.randomFileName());\n  var stdoutFile = path.resolve(tempDir + '/' + common.randomFileName());\n  opts = common.extend({\n    silent: common.config.silent,\n    cwd: _pwd().toString(),\n    env: process.env,\n    maxBuffer: DEFAULT_MAXBUFFER_SIZE,\n    encoding: 'utf8'\n  }, opts);\n  if (fs.existsSync(paramsFile)) common.unlinkSync(paramsFile);\n  if (fs.existsSync(stderrFile)) common.unlinkSync(stderrFile);\n  if (fs.existsSync(stdoutFile)) common.unlinkSync(stdoutFile);\n  opts.cwd = path.resolve(opts.cwd);\n  var paramsToSerialize = {\n    command: cmd,\n    execOptions: opts,\n    pipe: pipe,\n    stdoutFile: stdoutFile,\n    stderrFile: stderrFile\n  };\n\n  // Create the files and ensure these are locked down (for read and write) to\n  // the current user. The main concerns here are:\n  //\n  // * If we execute a command which prints sensitive output, then\n  //   stdoutFile/stderrFile must not be readable by other users.\n  // * paramsFile must not be readable by other users, or else they can read it\n  //   to figure out the path for stdoutFile/stderrFile and create these first\n  //   (locked down to their own access), which will crash exec() when it tries\n  //   to write to the files.\n  function writeFileLockedDown(filePath, data) {\n    fs.writeFileSync(filePath, data, {\n      encoding: 'utf8',\n      mode: parseInt('600', 8)\n    });\n  }\n  writeFileLockedDown(stdoutFile, '');\n  writeFileLockedDown(stderrFile, '');\n  writeFileLockedDown(paramsFile, JSON.stringify(paramsToSerialize));\n  var execArgs = [path.join(__dirname, 'exec-child.js'), paramsFile];\n\n  /* istanbul ignore else */\n  if (opts.silent) {\n    opts.stdio = 'ignore';\n  } else {\n    opts.stdio = [0, 1, 2];\n  }\n  var code = 0;\n\n  // Welcome to the future\n  try {\n    // Bad things if we pass in a `shell` option to child_process.execFileSync,\n    // so we need to explicitly remove it here.\n    delete opts.shell;\n    child.execFileSync(common.config.execPath, execArgs, opts);\n  } catch (e) {\n    // Commands with non-zero exit code raise an exception.\n    code = e.status || DEFAULT_ERROR_CODE;\n  }\n\n  // fs.readFileSync uses buffer encoding by default, so call\n  // it without the encoding option if the encoding is 'buffer'.\n  // Also, if the exec timeout is too short for node to start up,\n  // the files will not be created, so these calls will throw.\n  var stdout = '';\n  var stderr = '';\n  if (opts.encoding === 'buffer') {\n    stdout = fs.readFileSync(stdoutFile);\n    stderr = fs.readFileSync(stderrFile);\n  } else {\n    stdout = fs.readFileSync(stdoutFile, opts.encoding);\n    stderr = fs.readFileSync(stderrFile, opts.encoding);\n  }\n\n  // No biggie if we can't erase the files now -- they're in a temp dir anyway\n  // and we locked down permissions (see the note above).\n  try {\n    common.unlinkSync(paramsFile);\n  } catch (e) {}\n  try {\n    common.unlinkSync(stderrFile);\n  } catch (e) {}\n  try {\n    common.unlinkSync(stdoutFile);\n  } catch (e) {}\n  if (code !== 0) {\n    // Note: `silent` should be unconditionally true to avoid double-printing\n    // the command's stderr, and to avoid printing any stderr when the user has\n    // set `shell.config.silent`.\n    common.error(stderr, code, {\n      continue: true,\n      silent: true\n    });\n  }\n  var obj = common.ShellString(stdout, stderr, code);\n  return obj;\n} // execSync()\n\n// Wrapper around exec() to enable echoing output to console in real time\nfunction execAsync(cmd, opts, pipe, callback) {\n  opts = common.extend({\n    silent: common.config.silent,\n    cwd: _pwd().toString(),\n    env: process.env,\n    maxBuffer: DEFAULT_MAXBUFFER_SIZE,\n    encoding: 'utf8'\n  }, opts);\n  var c = child.exec(cmd, opts, function (err, stdout, stderr) {\n    if (callback) {\n      if (!err) {\n        callback(0, stdout, stderr);\n      } else if (err.code === undefined) {\n        // See issue #536\n        /* istanbul ignore next */\n        callback(1, stdout, stderr);\n      } else {\n        callback(err.code, stdout, stderr);\n      }\n    }\n  });\n  if (pipe) c.stdin.end(pipe);\n  if (!opts.silent) {\n    c.stdout.pipe(process.stdout);\n    c.stderr.pipe(process.stderr);\n  }\n  return c;\n}\n\n//@\n//@ ### exec(command [, options] [, callback])\n//@\n//@ Available options:\n//@\n//@ + `async`: Asynchronous execution. If a callback is provided, it will be set to\n//@   `true`, regardless of the passed value (default: `false`).\n//@ + `silent`: Do not echo program output to console (default: `false`).\n//@ + `encoding`: Character encoding to use. Affects the values returned to stdout and stderr, and\n//@   what is written to stdout and stderr when not in silent mode (default: `'utf8'`).\n//@ + and any option available to Node.js's\n//@   [`child_process.exec()`](https://nodejs.org/api/child_process.html#child_process_child_process_exec_command_options_callback)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ var version = exec('node --version', {silent:true}).stdout;\n//@\n//@ var child = exec('some_long_running_process', {async:true});\n//@ child.stdout.on('data', function(data) {\n//@   /* ... do something with data ... */\n//@ });\n//@\n//@ exec('some_long_running_process', function(code, stdout, stderr) {\n//@   console.log('Exit code:', code);\n//@   console.log('Program output:', stdout);\n//@   console.log('Program stderr:', stderr);\n//@ });\n//@ ```\n//@\n//@ Executes the given `command` _synchronously_, unless otherwise specified.  When in synchronous\n//@ mode, this returns a `ShellString` (compatible with ShellJS v0.6.x, which returns an object\n//@ of the form `{ code:..., stdout:... , stderr:... }`). Otherwise, this returns the child process\n//@ object, and the `callback` receives the arguments `(code, stdout, stderr)`.\n//@\n//@ Not seeing the behavior you want? `exec()` runs everything through `sh`\n//@ by default (or `cmd.exe` on Windows), which differs from `bash`. If you\n//@ need bash-specific behavior, try out the `{shell: 'path/to/bash'}` option.\nfunction _exec(command, options, callback) {\n  options = options || {};\n  if (!command) common.error('must specify command');\n  var pipe = common.readFromPipe();\n\n  // Callback is defined instead of options.\n  if (typeof options === 'function') {\n    callback = options;\n    options = {\n      async: true\n    };\n  }\n\n  // Callback is defined with options.\n  if (typeof options === 'object' && typeof callback === 'function') {\n    options.async = true;\n  }\n  options = common.extend({\n    silent: common.config.silent,\n    async: false\n  }, options);\n  if (options.async) {\n    return execAsync(command, options, pipe, callback);\n  } else {\n    return execSync(command, options, pipe);\n  }\n}\nmodule.exports = _exec;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\exec.js");

/***/ }),

/***/ "./node_modules/shelljs/src/find.js":
/*!******************************************!*\
  !*** ./node_modules/shelljs/src/find.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar path = __webpack_require__(/*! path */ \"path\");\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/shelljs/src/common.js\");\nvar _ls = __webpack_require__(/*! ./ls */ \"./node_modules/shelljs/src/ls.js\");\ncommon.register('find', _find, {});\n\n//@\n//@ ### find(path [, path ...])\n//@ ### find(path_array)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ find('src', 'lib');\n//@ find(['src', 'lib']); // same as above\n//@ find('.').filter(function(file) { return file.match(/\\.js$/); });\n//@ ```\n//@\n//@ Returns array of all files (however deep) in the given paths.\n//@\n//@ The main difference from `ls('-R', path)` is that the resulting file names\n//@ include the base directories (e.g., `lib/resources/file1` instead of just `file1`).\nfunction _find(options, paths) {\n  if (!paths) {\n    common.error('no path specified');\n  } else if (typeof paths === 'string') {\n    paths = [].slice.call(arguments, 1);\n  }\n  var list = [];\n  function pushFile(file) {\n    if (process.platform === 'win32') {\n      file = file.replace(/\\\\/g, '/');\n    }\n    list.push(file);\n  }\n\n  // why not simply do `ls('-R', paths)`? because the output wouldn't give the base dirs\n  // to get the base dir in the output, we need instead `ls('-R', 'dir/*')` for every directory\n\n  paths.forEach(function (file) {\n    var stat;\n    try {\n      stat = common.statFollowLinks(file);\n    } catch (e) {\n      common.error('no such file or directory: ' + file);\n    }\n    pushFile(file);\n    if (stat.isDirectory()) {\n      _ls({\n        recursive: true,\n        all: true\n      }, file).forEach(function (subfile) {\n        pushFile(path.join(file, subfile));\n      });\n    }\n  });\n  return list;\n}\nmodule.exports = _find;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\find.js");

/***/ }),

/***/ "./node_modules/shelljs/src/grep.js":
/*!******************************************!*\
  !*** ./node_modules/shelljs/src/grep.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/shelljs/src/common.js\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\ncommon.register('grep', _grep, {\n  globStart: 2,\n  // don't glob-expand the regex\n  canReceivePipe: true,\n  cmdOptions: {\n    'v': 'inverse',\n    'l': 'nameOnly',\n    'i': 'ignoreCase'\n  }\n});\n\n//@\n//@ ### grep([options,] regex_filter, file [, file ...])\n//@ ### grep([options,] regex_filter, file_array)\n//@\n//@ Available options:\n//@\n//@ + `-v`: Invert `regex_filter` (only print non-matching lines).\n//@ + `-l`: Print only filenames of matching files.\n//@ + `-i`: Ignore case.\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ grep('-v', 'GLOBAL_VARIABLE', '*.js');\n//@ grep('GLOBAL_VARIABLE', '*.js');\n//@ ```\n//@\n//@ Reads input string from given files and returns a string containing all lines of the\n//@ file that match the given `regex_filter`.\nfunction _grep(options, regex, files) {\n  // Check if this is coming from a pipe\n  var pipe = common.readFromPipe();\n  if (!files && !pipe) common.error('no paths given', 2);\n  files = [].slice.call(arguments, 2);\n  if (pipe) {\n    files.unshift('-');\n  }\n  var grep = [];\n  if (options.ignoreCase) {\n    regex = new RegExp(regex, 'i');\n  }\n  files.forEach(function (file) {\n    if (!fs.existsSync(file) && file !== '-') {\n      common.error('no such file or directory: ' + file, 2, {\n        continue: true\n      });\n      return;\n    }\n    var contents = file === '-' ? pipe : fs.readFileSync(file, 'utf8');\n    if (options.nameOnly) {\n      if (contents.match(regex)) {\n        grep.push(file);\n      }\n    } else {\n      var lines = contents.split('\\n');\n      lines.forEach(function (line) {\n        var matched = line.match(regex);\n        if (options.inverse && !matched || !options.inverse && matched) {\n          grep.push(line);\n        }\n      });\n    }\n  });\n  return grep.join('\\n') + '\\n';\n}\nmodule.exports = _grep;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\grep.js");

/***/ }),

/***/ "./node_modules/shelljs/src/head.js":
/*!******************************************!*\
  !*** ./node_modules/shelljs/src/head.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/shelljs/src/common.js\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\ncommon.register('head', _head, {\n  canReceivePipe: true,\n  cmdOptions: {\n    'n': 'numLines'\n  }\n});\n\n// Reads |numLines| lines or the entire file, whichever is less.\nfunction readSomeLines(file, numLines) {\n  var buf = common.buffer();\n  var bufLength = buf.length;\n  var bytesRead = bufLength;\n  var pos = 0;\n  var fdr = fs.openSync(file, 'r');\n  var numLinesRead = 0;\n  var ret = '';\n  while (bytesRead === bufLength && numLinesRead < numLines) {\n    bytesRead = fs.readSync(fdr, buf, 0, bufLength, pos);\n    var bufStr = buf.toString('utf8', 0, bytesRead);\n    numLinesRead += bufStr.split('\\n').length - 1;\n    ret += bufStr;\n    pos += bytesRead;\n  }\n  fs.closeSync(fdr);\n  return ret;\n}\n\n//@\n//@ ### head([{'-n': \\<num\\>},] file [, file ...])\n//@ ### head([{'-n': \\<num\\>},] file_array)\n//@\n//@ Available options:\n//@\n//@ + `-n <num>`: Show the first `<num>` lines of the files\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ var str = head({'-n': 1}, 'file*.txt');\n//@ var str = head('file1', 'file2');\n//@ var str = head(['file1', 'file2']); // same as above\n//@ ```\n//@\n//@ Read the start of a file.\nfunction _head(options, files) {\n  var head = [];\n  var pipe = common.readFromPipe();\n  if (!files && !pipe) common.error('no paths given');\n  var idx = 1;\n  if (options.numLines === true) {\n    idx = 2;\n    options.numLines = Number(arguments[1]);\n  } else if (options.numLines === false) {\n    options.numLines = 10;\n  }\n  files = [].slice.call(arguments, idx);\n  if (pipe) {\n    files.unshift('-');\n  }\n  var shouldAppendNewline = false;\n  files.forEach(function (file) {\n    if (file !== '-') {\n      if (!fs.existsSync(file)) {\n        common.error('no such file or directory: ' + file, {\n          continue: true\n        });\n        return;\n      } else if (common.statFollowLinks(file).isDirectory()) {\n        common.error(\"error reading '\" + file + \"': Is a directory\", {\n          continue: true\n        });\n        return;\n      }\n    }\n    var contents;\n    if (file === '-') {\n      contents = pipe;\n    } else if (options.numLines < 0) {\n      contents = fs.readFileSync(file, 'utf8');\n    } else {\n      contents = readSomeLines(file, options.numLines);\n    }\n    var lines = contents.split('\\n');\n    var hasTrailingNewline = lines[lines.length - 1] === '';\n    if (hasTrailingNewline) {\n      lines.pop();\n    }\n    shouldAppendNewline = hasTrailingNewline || options.numLines < lines.length;\n    head = head.concat(lines.slice(0, options.numLines));\n  });\n  if (shouldAppendNewline) {\n    head.push(''); // to add a trailing newline once we join\n  }\n\n  return head.join('\\n');\n}\nmodule.exports = _head;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\head.js");

/***/ }),

/***/ "./node_modules/shelljs/src/ln.js":
/*!****************************************!*\
  !*** ./node_modules/shelljs/src/ln.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/shelljs/src/common.js\");\ncommon.register('ln', _ln, {\n  cmdOptions: {\n    's': 'symlink',\n    'f': 'force'\n  }\n});\n\n//@\n//@ ### ln([options,] source, dest)\n//@\n//@ Available options:\n//@\n//@ + `-s`: symlink\n//@ + `-f`: force\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ ln('file', 'newlink');\n//@ ln('-sf', 'file', 'existing');\n//@ ```\n//@\n//@ Links `source` to `dest`. Use `-f` to force the link, should `dest` already exist.\nfunction _ln(options, source, dest) {\n  if (!source || !dest) {\n    common.error('Missing <source> and/or <dest>');\n  }\n  source = String(source);\n  var sourcePath = path.normalize(source).replace(RegExp(path.sep + '$'), '');\n  var isAbsolute = path.resolve(source) === sourcePath;\n  dest = path.resolve(process.cwd(), String(dest));\n  if (fs.existsSync(dest)) {\n    if (!options.force) {\n      common.error('Destination file exists', {\n        continue: true\n      });\n    }\n    fs.unlinkSync(dest);\n  }\n  if (options.symlink) {\n    var isWindows = process.platform === 'win32';\n    var linkType = isWindows ? 'file' : null;\n    var resolvedSourcePath = isAbsolute ? sourcePath : path.resolve(process.cwd(), path.dirname(dest), source);\n    if (!fs.existsSync(resolvedSourcePath)) {\n      common.error('Source file does not exist', {\n        continue: true\n      });\n    } else if (isWindows && common.statFollowLinks(resolvedSourcePath).isDirectory()) {\n      linkType = 'junction';\n    }\n    try {\n      fs.symlinkSync(linkType === 'junction' ? resolvedSourcePath : source, dest, linkType);\n    } catch (err) {\n      common.error(err.message);\n    }\n  } else {\n    if (!fs.existsSync(source)) {\n      common.error('Source file does not exist', {\n        continue: true\n      });\n    }\n    try {\n      fs.linkSync(source, dest);\n    } catch (err) {\n      common.error(err.message);\n    }\n  }\n  return '';\n}\nmodule.exports = _ln;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\ln.js");

/***/ }),

/***/ "./node_modules/shelljs/src/ls.js":
/*!****************************************!*\
  !*** ./node_modules/shelljs/src/ls.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar path = __webpack_require__(/*! path */ \"path\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/shelljs/src/common.js\");\nvar glob = __webpack_require__(/*! glob */ \"./node_modules/shelljs/node_modules/glob/glob.js\");\nvar globPatternRecursive = path.sep + '**';\ncommon.register('ls', _ls, {\n  cmdOptions: {\n    'R': 'recursive',\n    'A': 'all',\n    'L': 'link',\n    'a': 'all_deprecated',\n    'd': 'directory',\n    'l': 'long'\n  }\n});\n\n//@\n//@ ### ls([options,] [path, ...])\n//@ ### ls([options,] path_array)\n//@\n//@ Available options:\n//@\n//@ + `-R`: recursive\n//@ + `-A`: all files (include files beginning with `.`, except for `.` and `..`)\n//@ + `-L`: follow symlinks\n//@ + `-d`: list directories themselves, not their contents\n//@ + `-l`: list objects representing each file, each with fields containing `ls\n//@         -l` output fields. See\n//@         [`fs.Stats`](https://nodejs.org/api/fs.html#fs_class_fs_stats)\n//@         for more info\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ ls('projs/*.js');\n//@ ls('-R', '/users/me', '/tmp');\n//@ ls('-R', ['/users/me', '/tmp']); // same as above\n//@ ls('-l', 'file.txt'); // { name: 'file.txt', mode: 33188, nlink: 1, ...}\n//@ ```\n//@\n//@ Returns array of files in the given `path`, or files in\n//@ the current directory if no `path` is  provided.\nfunction _ls(options, paths) {\n  if (options.all_deprecated) {\n    // We won't support the -a option as it's hard to image why it's useful\n    // (it includes '.' and '..' in addition to '.*' files)\n    // For backwards compatibility we'll dump a deprecated message and proceed as before\n    common.log('ls: Option -a is deprecated. Use -A instead');\n    options.all = true;\n  }\n  if (!paths) {\n    paths = ['.'];\n  } else {\n    paths = [].slice.call(arguments, 1);\n  }\n  var list = [];\n  function pushFile(abs, relName, stat) {\n    if (process.platform === 'win32') {\n      relName = relName.replace(/\\\\/g, '/');\n    }\n    if (options.long) {\n      stat = stat || (options.link ? common.statFollowLinks(abs) : common.statNoFollowLinks(abs));\n      list.push(addLsAttributes(relName, stat));\n    } else {\n      // list.push(path.relative(rel || '.', file));\n      list.push(relName);\n    }\n  }\n  paths.forEach(function (p) {\n    var stat;\n    try {\n      stat = options.link ? common.statFollowLinks(p) : common.statNoFollowLinks(p);\n      // follow links to directories by default\n      if (stat.isSymbolicLink()) {\n        /* istanbul ignore next */\n        // workaround for https://github.com/shelljs/shelljs/issues/795\n        // codecov seems to have a bug that miscalculate this block as uncovered.\n        // but according to nyc report this block does get covered.\n        try {\n          var _stat = common.statFollowLinks(p);\n          if (_stat.isDirectory()) {\n            stat = _stat;\n          }\n        } catch (_) {} // bad symlink, treat it like a file\n      }\n    } catch (e) {\n      common.error('no such file or directory: ' + p, 2, {\n        continue: true\n      });\n      return;\n    }\n\n    // If the stat succeeded\n    if (stat.isDirectory() && !options.directory) {\n      if (options.recursive) {\n        // use glob, because it's simple\n        glob.sync(p + globPatternRecursive, {\n          dot: options.all,\n          follow: options.link\n        }).forEach(function (item) {\n          // Glob pattern returns the directory itself and needs to be filtered out.\n          if (path.relative(p, item)) {\n            pushFile(item, path.relative(p, item));\n          }\n        });\n      } else if (options.all) {\n        // use fs.readdirSync, because it's fast\n        fs.readdirSync(p).forEach(function (item) {\n          pushFile(path.join(p, item), item);\n        });\n      } else {\n        // use fs.readdirSync and then filter out secret files\n        fs.readdirSync(p).forEach(function (item) {\n          if (item[0] !== '.') {\n            pushFile(path.join(p, item), item);\n          }\n        });\n      }\n    } else {\n      pushFile(p, p, stat);\n    }\n  });\n\n  // Add methods, to make this more compatible with ShellStrings\n  return list;\n}\nfunction addLsAttributes(pathName, stats) {\n  // Note: this object will contain more information than .toString() returns\n  stats.name = pathName;\n  stats.toString = function () {\n    // Return a string resembling unix's `ls -l` format\n    return [this.mode, this.nlink, this.uid, this.gid, this.size, this.mtime, this.name].join(' ');\n  };\n  return stats;\n}\nmodule.exports = _ls;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\ls.js");

/***/ }),

/***/ "./node_modules/shelljs/src/mkdir.js":
/*!*******************************************!*\
  !*** ./node_modules/shelljs/src/mkdir.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/shelljs/src/common.js\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar path = __webpack_require__(/*! path */ \"path\");\ncommon.register('mkdir', _mkdir, {\n  cmdOptions: {\n    'p': 'fullpath'\n  }\n});\n\n// Recursively creates `dir`\nfunction mkdirSyncRecursive(dir) {\n  var baseDir = path.dirname(dir);\n\n  // Prevents some potential problems arising from malformed UNCs or\n  // insufficient permissions.\n  /* istanbul ignore next */\n  if (baseDir === dir) {\n    common.error('dirname() failed: [' + dir + ']');\n  }\n\n  // Base dir exists, no recursion necessary\n  if (fs.existsSync(baseDir)) {\n    fs.mkdirSync(dir, parseInt('0777', 8));\n    return;\n  }\n\n  // Base dir does not exist, go recursive\n  mkdirSyncRecursive(baseDir);\n\n  // Base dir created, can create dir\n  fs.mkdirSync(dir, parseInt('0777', 8));\n}\n\n//@\n//@ ### mkdir([options,] dir [, dir ...])\n//@ ### mkdir([options,] dir_array)\n//@\n//@ Available options:\n//@\n//@ + `-p`: full path (and create intermediate directories, if necessary)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ mkdir('-p', '/tmp/a/b/c/d', '/tmp/e/f/g');\n//@ mkdir('-p', ['/tmp/a/b/c/d', '/tmp/e/f/g']); // same as above\n//@ ```\n//@\n//@ Creates directories.\nfunction _mkdir(options, dirs) {\n  if (!dirs) common.error('no paths given');\n  if (typeof dirs === 'string') {\n    dirs = [].slice.call(arguments, 1);\n  }\n  // if it's array leave it as it is\n\n  dirs.forEach(function (dir) {\n    try {\n      var stat = common.statNoFollowLinks(dir);\n      if (!options.fullpath) {\n        common.error('path already exists: ' + dir, {\n          continue: true\n        });\n      } else if (stat.isFile()) {\n        common.error('cannot create directory ' + dir + ': File exists', {\n          continue: true\n        });\n      }\n      return; // skip dir\n    } catch (e) {\n      // do nothing\n    }\n\n    // Base dir does not exist, and no -p option given\n    var baseDir = path.dirname(dir);\n    if (!fs.existsSync(baseDir) && !options.fullpath) {\n      common.error('no such file or directory: ' + baseDir, {\n        continue: true\n      });\n      return; // skip dir\n    }\n\n    try {\n      if (options.fullpath) {\n        mkdirSyncRecursive(path.resolve(dir));\n      } else {\n        fs.mkdirSync(dir, parseInt('0777', 8));\n      }\n    } catch (e) {\n      var reason;\n      if (e.code === 'EACCES') {\n        reason = 'Permission denied';\n      } else if (e.code === 'ENOTDIR' || e.code === 'ENOENT') {\n        reason = 'Not a directory';\n      } else {\n        /* istanbul ignore next */\n        throw e;\n      }\n      common.error('cannot create directory ' + dir + ': ' + reason, {\n        continue: true\n      });\n    }\n  });\n  return '';\n} // mkdir\nmodule.exports = _mkdir;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\mkdir.js");

/***/ }),

/***/ "./node_modules/shelljs/src/mv.js":
/*!****************************************!*\
  !*** ./node_modules/shelljs/src/mv.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/shelljs/src/common.js\");\nvar cp = __webpack_require__(/*! ./cp */ \"./node_modules/shelljs/src/cp.js\");\nvar rm = __webpack_require__(/*! ./rm */ \"./node_modules/shelljs/src/rm.js\");\ncommon.register('mv', _mv, {\n  cmdOptions: {\n    'f': '!no_force',\n    'n': 'no_force'\n  }\n});\n\n// Checks if cureent file was created recently\nfunction checkRecentCreated(sources, index) {\n  var lookedSource = sources[index];\n  return sources.slice(0, index).some(function (src) {\n    return path.basename(src) === path.basename(lookedSource);\n  });\n}\n\n//@\n//@ ### mv([options ,] source [, source ...], dest')\n//@ ### mv([options ,] source_array, dest')\n//@\n//@ Available options:\n//@\n//@ + `-f`: force (default behavior)\n//@ + `-n`: no-clobber\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ mv('-n', 'file', 'dir/');\n//@ mv('file1', 'file2', 'dir/');\n//@ mv(['file1', 'file2'], 'dir/'); // same as above\n//@ ```\n//@\n//@ Moves `source` file(s) to `dest`.\nfunction _mv(options, sources, dest) {\n  // Get sources, dest\n  if (arguments.length < 3) {\n    common.error('missing <source> and/or <dest>');\n  } else if (arguments.length > 3) {\n    sources = [].slice.call(arguments, 1, arguments.length - 1);\n    dest = arguments[arguments.length - 1];\n  } else if (typeof sources === 'string') {\n    sources = [sources];\n  } else {\n    // TODO(nate): figure out if we actually need this line\n    common.error('invalid arguments');\n  }\n  var exists = fs.existsSync(dest);\n  var stats = exists && common.statFollowLinks(dest);\n\n  // Dest is not existing dir, but multiple sources given\n  if ((!exists || !stats.isDirectory()) && sources.length > 1) {\n    common.error('dest is not a directory (too many sources)');\n  }\n\n  // Dest is an existing file, but no -f given\n  if (exists && stats.isFile() && options.no_force) {\n    common.error('dest file already exists: ' + dest);\n  }\n  sources.forEach(function (src, srcIndex) {\n    if (!fs.existsSync(src)) {\n      common.error('no such file or directory: ' + src, {\n        continue: true\n      });\n      return; // skip file\n    }\n\n    // If here, src exists\n\n    // When copying to '/path/dir':\n    //    thisDest = '/path/dir/file1'\n    var thisDest = dest;\n    if (fs.existsSync(dest) && common.statFollowLinks(dest).isDirectory()) {\n      thisDest = path.normalize(dest + '/' + path.basename(src));\n    }\n    var thisDestExists = fs.existsSync(thisDest);\n    if (thisDestExists && checkRecentCreated(sources, srcIndex)) {\n      // cannot overwrite file created recently in current execution, but we want to continue copying other files\n      if (!options.no_force) {\n        common.error(\"will not overwrite just-created '\" + thisDest + \"' with '\" + src + \"'\", {\n          continue: true\n        });\n      }\n      return;\n    }\n    if (fs.existsSync(thisDest) && options.no_force) {\n      common.error('dest file already exists: ' + thisDest, {\n        continue: true\n      });\n      return; // skip file\n    }\n\n    if (path.resolve(src) === path.dirname(path.resolve(thisDest))) {\n      common.error('cannot move to self: ' + src, {\n        continue: true\n      });\n      return; // skip file\n    }\n\n    try {\n      fs.renameSync(src, thisDest);\n    } catch (e) {\n      /* istanbul ignore next */\n      if (e.code === 'EXDEV') {\n        // If we're trying to `mv` to an external partition, we'll actually need\n        // to perform a copy and then clean up the original file. If either the\n        // copy or the rm fails with an exception, we should allow this\n        // exception to pass up to the top level.\n        cp('-r', src, thisDest);\n        rm('-rf', src);\n      }\n    }\n  }); // forEach(src)\n  return '';\n} // mv\nmodule.exports = _mv;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\mv.js");

/***/ }),

/***/ "./node_modules/shelljs/src/popd.js":
/*!******************************************!*\
  !*** ./node_modules/shelljs/src/popd.js ***!
  \******************************************/
/***/ (() => {

"use strict";
eval("// see dirs.js\n\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\popd.js");

/***/ }),

/***/ "./node_modules/shelljs/src/pushd.js":
/*!*******************************************!*\
  !*** ./node_modules/shelljs/src/pushd.js ***!
  \*******************************************/
/***/ (() => {

"use strict";
eval("// see dirs.js\n\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\pushd.js");

/***/ }),

/***/ "./node_modules/shelljs/src/pwd.js":
/*!*****************************************!*\
  !*** ./node_modules/shelljs/src/pwd.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar path = __webpack_require__(/*! path */ \"path\");\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/shelljs/src/common.js\");\ncommon.register('pwd', _pwd, {\n  allowGlobbing: false\n});\n\n//@\n//@ ### pwd()\n//@\n//@ Returns the current directory.\nfunction _pwd() {\n  var pwd = path.resolve(process.cwd());\n  return pwd;\n}\nmodule.exports = _pwd;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\pwd.js");

/***/ }),

/***/ "./node_modules/shelljs/src/rm.js":
/*!****************************************!*\
  !*** ./node_modules/shelljs/src/rm.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/shelljs/src/common.js\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\ncommon.register('rm', _rm, {\n  cmdOptions: {\n    'f': 'force',\n    'r': 'recursive',\n    'R': 'recursive'\n  }\n});\n\n// Recursively removes 'dir'\n// Adapted from https://github.com/ryanmcgrath/wrench-js\n//\n// Copyright (c) 2010 Ryan McGrath\n// Copyright (c) 2012 Artur Adib\n//\n// Licensed under the MIT License\n// http://www.opensource.org/licenses/mit-license.php\nfunction rmdirSyncRecursive(dir, force, fromSymlink) {\n  var files;\n  files = fs.readdirSync(dir);\n\n  // Loop through and delete everything in the sub-tree after checking it\n  for (var i = 0; i < files.length; i++) {\n    var file = dir + '/' + files[i];\n    var currFile = common.statNoFollowLinks(file);\n    if (currFile.isDirectory()) {\n      // Recursive function back to the beginning\n      rmdirSyncRecursive(file, force);\n    } else {\n      // Assume it's a file - perhaps a try/catch belongs here?\n      if (force || isWriteable(file)) {\n        try {\n          common.unlinkSync(file);\n        } catch (e) {\n          /* istanbul ignore next */\n          common.error('could not remove file (code ' + e.code + '): ' + file, {\n            continue: true\n          });\n        }\n      }\n    }\n  }\n\n  // if was directory was referenced through a symbolic link,\n  // the contents should be removed, but not the directory itself\n  if (fromSymlink) return;\n\n  // Now that we know everything in the sub-tree has been deleted, we can delete the main directory.\n  // Huzzah for the shopkeep.\n\n  var result;\n  try {\n    // Retry on windows, sometimes it takes a little time before all the files in the directory are gone\n    var start = Date.now();\n\n    // TODO: replace this with a finite loop\n    for (;;) {\n      try {\n        result = fs.rmdirSync(dir);\n        if (fs.existsSync(dir)) throw {\n          code: 'EAGAIN'\n        };\n        break;\n      } catch (er) {\n        /* istanbul ignore next */\n        // In addition to error codes, also check if the directory still exists and loop again if true\n        if (process.platform === 'win32' && (er.code === 'ENOTEMPTY' || er.code === 'EBUSY' || er.code === 'EPERM' || er.code === 'EAGAIN')) {\n          if (Date.now() - start > 1000) throw er;\n        } else if (er.code === 'ENOENT') {\n          // Directory did not exist, deletion was successful\n          break;\n        } else {\n          throw er;\n        }\n      }\n    }\n  } catch (e) {\n    common.error('could not remove directory (code ' + e.code + '): ' + dir, {\n      continue: true\n    });\n  }\n  return result;\n} // rmdirSyncRecursive\n\n// Hack to determine if file has write permissions for current user\n// Avoids having to check user, group, etc, but it's probably slow\nfunction isWriteable(file) {\n  var writePermission = true;\n  try {\n    var __fd = fs.openSync(file, 'a');\n    fs.closeSync(__fd);\n  } catch (e) {\n    writePermission = false;\n  }\n  return writePermission;\n}\nfunction handleFile(file, options) {\n  if (options.force || isWriteable(file)) {\n    // -f was passed, or file is writable, so it can be removed\n    common.unlinkSync(file);\n  } else {\n    common.error('permission denied: ' + file, {\n      continue: true\n    });\n  }\n}\nfunction handleDirectory(file, options) {\n  if (options.recursive) {\n    // -r was passed, so directory can be removed\n    rmdirSyncRecursive(file, options.force);\n  } else {\n    common.error('path is a directory', {\n      continue: true\n    });\n  }\n}\nfunction handleSymbolicLink(file, options) {\n  var stats;\n  try {\n    stats = common.statFollowLinks(file);\n  } catch (e) {\n    // symlink is broken, so remove the symlink itself\n    common.unlinkSync(file);\n    return;\n  }\n  if (stats.isFile()) {\n    common.unlinkSync(file);\n  } else if (stats.isDirectory()) {\n    if (file[file.length - 1] === '/') {\n      // trailing separator, so remove the contents, not the link\n      if (options.recursive) {\n        // -r was passed, so directory can be removed\n        var fromSymlink = true;\n        rmdirSyncRecursive(file, options.force, fromSymlink);\n      } else {\n        common.error('path is a directory', {\n          continue: true\n        });\n      }\n    } else {\n      // no trailing separator, so remove the link\n      common.unlinkSync(file);\n    }\n  }\n}\nfunction handleFIFO(file) {\n  common.unlinkSync(file);\n}\n\n//@\n//@ ### rm([options,] file [, file ...])\n//@ ### rm([options,] file_array)\n//@\n//@ Available options:\n//@\n//@ + `-f`: force\n//@ + `-r, -R`: recursive\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ rm('-rf', '/tmp/*');\n//@ rm('some_file.txt', 'another_file.txt');\n//@ rm(['some_file.txt', 'another_file.txt']); // same as above\n//@ ```\n//@\n//@ Removes files.\nfunction _rm(options, files) {\n  if (!files) common.error('no paths given');\n\n  // Convert to array\n  files = [].slice.call(arguments, 1);\n  files.forEach(function (file) {\n    var lstats;\n    try {\n      var filepath = file[file.length - 1] === '/' ? file.slice(0, -1) // remove the '/' so lstatSync can detect symlinks\n      : file;\n      lstats = common.statNoFollowLinks(filepath); // test for existence\n    } catch (e) {\n      // Path does not exist, no force flag given\n      if (!options.force) {\n        common.error('no such file or directory: ' + file, {\n          continue: true\n        });\n      }\n      return; // skip file\n    }\n\n    // If here, path exists\n    if (lstats.isFile()) {\n      handleFile(file, options);\n    } else if (lstats.isDirectory()) {\n      handleDirectory(file, options);\n    } else if (lstats.isSymbolicLink()) {\n      handleSymbolicLink(file, options);\n    } else if (lstats.isFIFO()) {\n      handleFIFO(file);\n    }\n  }); // forEach(file)\n  return '';\n} // rm\nmodule.exports = _rm;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\rm.js");

/***/ }),

/***/ "./node_modules/shelljs/src/sed.js":
/*!*****************************************!*\
  !*** ./node_modules/shelljs/src/sed.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/shelljs/src/common.js\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\ncommon.register('sed', _sed, {\n  globStart: 3,\n  // don't glob-expand regexes\n  canReceivePipe: true,\n  cmdOptions: {\n    'i': 'inplace'\n  }\n});\n\n//@\n//@ ### sed([options,] search_regex, replacement, file [, file ...])\n//@ ### sed([options,] search_regex, replacement, file_array)\n//@\n//@ Available options:\n//@\n//@ + `-i`: Replace contents of `file` in-place. _Note that no backups will be created!_\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ sed('-i', 'PROGRAM_VERSION', 'v0.1.3', 'source.js');\n//@ sed(/.*DELETE_THIS_LINE.*\\n/, '', 'source.js');\n//@ ```\n//@\n//@ Reads an input string from `file`s, and performs a JavaScript `replace()` on the input\n//@ using the given `search_regex` and `replacement` string or function. Returns the new string after replacement.\n//@\n//@ Note:\n//@\n//@ Like unix `sed`, ShellJS `sed` supports capture groups. Capture groups are specified\n//@ using the `$n` syntax:\n//@\n//@ ```javascript\n//@ sed(/(\\w+)\\s(\\w+)/, '$2, $1', 'file.txt');\n//@ ```\nfunction _sed(options, regex, replacement, files) {\n  // Check if this is coming from a pipe\n  var pipe = common.readFromPipe();\n  if (typeof replacement !== 'string' && typeof replacement !== 'function') {\n    if (typeof replacement === 'number') {\n      replacement = replacement.toString(); // fallback\n    } else {\n      common.error('invalid replacement string');\n    }\n  }\n\n  // Convert all search strings to RegExp\n  if (typeof regex === 'string') {\n    regex = RegExp(regex);\n  }\n  if (!files && !pipe) {\n    common.error('no files given');\n  }\n  files = [].slice.call(arguments, 3);\n  if (pipe) {\n    files.unshift('-');\n  }\n  var sed = [];\n  files.forEach(function (file) {\n    if (!fs.existsSync(file) && file !== '-') {\n      common.error('no such file or directory: ' + file, 2, {\n        continue: true\n      });\n      return;\n    }\n    var contents = file === '-' ? pipe : fs.readFileSync(file, 'utf8');\n    var lines = contents.split('\\n');\n    var result = lines.map(function (line) {\n      return line.replace(regex, replacement);\n    }).join('\\n');\n    sed.push(result);\n    if (options.inplace) {\n      fs.writeFileSync(file, result, 'utf8');\n    }\n  });\n  return sed.join('\\n');\n}\nmodule.exports = _sed;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\sed.js");

/***/ }),

/***/ "./node_modules/shelljs/src/set.js":
/*!*****************************************!*\
  !*** ./node_modules/shelljs/src/set.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/shelljs/src/common.js\");\ncommon.register('set', _set, {\n  allowGlobbing: false,\n  wrapOutput: false\n});\n\n//@\n//@ ### set(options)\n//@\n//@ Available options:\n//@\n//@ + `+/-e`: exit upon error (`config.fatal`)\n//@ + `+/-v`: verbose: show all commands (`config.verbose`)\n//@ + `+/-f`: disable filename expansion (globbing)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ set('-e'); // exit upon first error\n//@ set('+e'); // this undoes a \"set('-e')\"\n//@ ```\n//@\n//@ Sets global configuration variables.\nfunction _set(options) {\n  if (!options) {\n    var args = [].slice.call(arguments, 0);\n    if (args.length < 2) common.error('must provide an argument');\n    options = args[1];\n  }\n  var negate = options[0] === '+';\n  if (negate) {\n    options = '-' + options.slice(1); // parseOptions needs a '-' prefix\n  }\n\n  options = common.parseOptions(options, {\n    'e': 'fatal',\n    'v': 'verbose',\n    'f': 'noglob'\n  });\n  if (negate) {\n    Object.keys(options).forEach(function (key) {\n      options[key] = !options[key];\n    });\n  }\n  Object.keys(options).forEach(function (key) {\n    // Only change the global config if `negate` is false and the option is true\n    // or if `negate` is true and the option is false (aka negate !== option)\n    if (negate !== options[key]) {\n      common.config[key] = options[key];\n    }\n  });\n  return;\n}\nmodule.exports = _set;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\set.js");

/***/ }),

/***/ "./node_modules/shelljs/src/sort.js":
/*!******************************************!*\
  !*** ./node_modules/shelljs/src/sort.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/shelljs/src/common.js\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\ncommon.register('sort', _sort, {\n  canReceivePipe: true,\n  cmdOptions: {\n    'r': 'reverse',\n    'n': 'numerical'\n  }\n});\n\n// parse out the number prefix of a line\nfunction parseNumber(str) {\n  var match = str.match(/^\\s*(\\d*)\\s*(.*)$/);\n  return {\n    num: Number(match[1]),\n    value: match[2]\n  };\n}\n\n// compare two strings case-insensitively, but examine case for strings that are\n// case-insensitive equivalent\nfunction unixCmp(a, b) {\n  var aLower = a.toLowerCase();\n  var bLower = b.toLowerCase();\n  return aLower === bLower ? -1 * a.localeCompare(b) :\n  // unix sort treats case opposite how javascript does\n  aLower.localeCompare(bLower);\n}\n\n// compare two strings in the fashion that unix sort's -n option works\nfunction numericalCmp(a, b) {\n  var objA = parseNumber(a);\n  var objB = parseNumber(b);\n  if (objA.hasOwnProperty('num') && objB.hasOwnProperty('num')) {\n    return objA.num !== objB.num ? objA.num - objB.num : unixCmp(objA.value, objB.value);\n  } else {\n    return unixCmp(objA.value, objB.value);\n  }\n}\n\n//@\n//@ ### sort([options,] file [, file ...])\n//@ ### sort([options,] file_array)\n//@\n//@ Available options:\n//@\n//@ + `-r`: Reverse the results\n//@ + `-n`: Compare according to numerical value\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ sort('foo.txt', 'bar.txt');\n//@ sort('-r', 'foo.txt');\n//@ ```\n//@\n//@ Return the contents of the `file`s, sorted line-by-line. Sorting multiple\n//@ files mixes their content (just as unix `sort` does).\nfunction _sort(options, files) {\n  // Check if this is coming from a pipe\n  var pipe = common.readFromPipe();\n  if (!files && !pipe) common.error('no files given');\n  files = [].slice.call(arguments, 1);\n  if (pipe) {\n    files.unshift('-');\n  }\n  var lines = files.reduce(function (accum, file) {\n    if (file !== '-') {\n      if (!fs.existsSync(file)) {\n        common.error('no such file or directory: ' + file, {\n          continue: true\n        });\n        return accum;\n      } else if (common.statFollowLinks(file).isDirectory()) {\n        common.error('read failed: ' + file + ': Is a directory', {\n          continue: true\n        });\n        return accum;\n      }\n    }\n    var contents = file === '-' ? pipe : fs.readFileSync(file, 'utf8');\n    return accum.concat(contents.trimRight().split('\\n'));\n  }, []);\n  var sorted = lines.sort(options.numerical ? numericalCmp : unixCmp);\n  if (options.reverse) {\n    sorted = sorted.reverse();\n  }\n  return sorted.join('\\n') + '\\n';\n}\nmodule.exports = _sort;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\sort.js");

/***/ }),

/***/ "./node_modules/shelljs/src/tail.js":
/*!******************************************!*\
  !*** ./node_modules/shelljs/src/tail.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/shelljs/src/common.js\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\ncommon.register('tail', _tail, {\n  canReceivePipe: true,\n  cmdOptions: {\n    'n': 'numLines'\n  }\n});\n\n//@\n//@ ### tail([{'-n': \\<num\\>},] file [, file ...])\n//@ ### tail([{'-n': \\<num\\>},] file_array)\n//@\n//@ Available options:\n//@\n//@ + `-n <num>`: Show the last `<num>` lines of `file`s\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ var str = tail({'-n': 1}, 'file*.txt');\n//@ var str = tail('file1', 'file2');\n//@ var str = tail(['file1', 'file2']); // same as above\n//@ ```\n//@\n//@ Read the end of a `file`.\nfunction _tail(options, files) {\n  var tail = [];\n  var pipe = common.readFromPipe();\n  if (!files && !pipe) common.error('no paths given');\n  var idx = 1;\n  if (options.numLines === true) {\n    idx = 2;\n    options.numLines = Number(arguments[1]);\n  } else if (options.numLines === false) {\n    options.numLines = 10;\n  }\n  options.numLines = -1 * Math.abs(options.numLines);\n  files = [].slice.call(arguments, idx);\n  if (pipe) {\n    files.unshift('-');\n  }\n  var shouldAppendNewline = false;\n  files.forEach(function (file) {\n    if (file !== '-') {\n      if (!fs.existsSync(file)) {\n        common.error('no such file or directory: ' + file, {\n          continue: true\n        });\n        return;\n      } else if (common.statFollowLinks(file).isDirectory()) {\n        common.error(\"error reading '\" + file + \"': Is a directory\", {\n          continue: true\n        });\n        return;\n      }\n    }\n    var contents = file === '-' ? pipe : fs.readFileSync(file, 'utf8');\n    var lines = contents.split('\\n');\n    if (lines[lines.length - 1] === '') {\n      lines.pop();\n      shouldAppendNewline = true;\n    } else {\n      shouldAppendNewline = false;\n    }\n    tail = tail.concat(lines.slice(options.numLines));\n  });\n  if (shouldAppendNewline) {\n    tail.push(''); // to add a trailing newline once we join\n  }\n\n  return tail.join('\\n');\n}\nmodule.exports = _tail;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\tail.js");

/***/ }),

/***/ "./node_modules/shelljs/src/tempdir.js":
/*!*********************************************!*\
  !*** ./node_modules/shelljs/src/tempdir.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/shelljs/src/common.js\");\nvar os = __webpack_require__(/*! os */ \"os\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\ncommon.register('tempdir', _tempDir, {\n  allowGlobbing: false,\n  wrapOutput: false\n});\n\n// Returns false if 'dir' is not a writeable directory, 'dir' otherwise\nfunction writeableDir(dir) {\n  if (!dir || !fs.existsSync(dir)) return false;\n  if (!common.statFollowLinks(dir).isDirectory()) return false;\n  var testFile = dir + '/' + common.randomFileName();\n  try {\n    fs.writeFileSync(testFile, ' ');\n    common.unlinkSync(testFile);\n    return dir;\n  } catch (e) {\n    /* istanbul ignore next */\n    return false;\n  }\n}\n\n// Variable to cache the tempdir value for successive lookups.\nvar cachedTempDir;\n\n//@\n//@ ### tempdir()\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ var tmp = tempdir(); // \"/tmp\" for most *nix platforms\n//@ ```\n//@\n//@ Searches and returns string containing a writeable, platform-dependent temporary directory.\n//@ Follows Python's [tempfile algorithm](http://docs.python.org/library/tempfile.html#tempfile.tempdir).\nfunction _tempDir() {\n  if (cachedTempDir) return cachedTempDir;\n  cachedTempDir = writeableDir(os.tmpdir()) || writeableDir(process.env.TMPDIR) || writeableDir(process.env.TEMP) || writeableDir(process.env.TMP) || writeableDir(process.env.Wimp$ScrapDir) ||\n  // RiscOS\n  writeableDir('C:\\\\TEMP') ||\n  // Windows\n  writeableDir('C:\\\\TMP') ||\n  // Windows\n  writeableDir('\\\\TEMP') ||\n  // Windows\n  writeableDir('\\\\TMP') ||\n  // Windows\n  writeableDir('/tmp') || writeableDir('/var/tmp') || writeableDir('/usr/tmp') || writeableDir('.'); // last resort\n\n  return cachedTempDir;\n}\n\n// Indicates if the tempdir value is currently cached. This is exposed for tests\n// only. The return value should only be tested for truthiness.\nfunction isCached() {\n  return cachedTempDir;\n}\n\n// Clears the cached tempDir value, if one is cached. This is exposed for tests\n// only.\nfunction clearCache() {\n  cachedTempDir = undefined;\n}\nmodule.exports.tempDir = _tempDir;\nmodule.exports.isCached = isCached;\nmodule.exports.clearCache = clearCache;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\tempdir.js");

/***/ }),

/***/ "./node_modules/shelljs/src/test.js":
/*!******************************************!*\
  !*** ./node_modules/shelljs/src/test.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/shelljs/src/common.js\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\ncommon.register('test', _test, {\n  cmdOptions: {\n    'b': 'block',\n    'c': 'character',\n    'd': 'directory',\n    'e': 'exists',\n    'f': 'file',\n    'L': 'link',\n    'p': 'pipe',\n    'S': 'socket'\n  },\n  wrapOutput: false,\n  allowGlobbing: false\n});\n\n//@\n//@ ### test(expression)\n//@\n//@ Available expression primaries:\n//@\n//@ + `'-b', 'path'`: true if path is a block device\n//@ + `'-c', 'path'`: true if path is a character device\n//@ + `'-d', 'path'`: true if path is a directory\n//@ + `'-e', 'path'`: true if path exists\n//@ + `'-f', 'path'`: true if path is a regular file\n//@ + `'-L', 'path'`: true if path is a symbolic link\n//@ + `'-p', 'path'`: true if path is a pipe (FIFO)\n//@ + `'-S', 'path'`: true if path is a socket\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ if (test('-d', path)) { /* do something with dir */ };\n//@ if (!test('-f', path)) continue; // skip if it's a regular file\n//@ ```\n//@\n//@ Evaluates `expression` using the available primaries and returns corresponding value.\nfunction _test(options, path) {\n  if (!path) common.error('no path given');\n  var canInterpret = false;\n  Object.keys(options).forEach(function (key) {\n    if (options[key] === true) {\n      canInterpret = true;\n    }\n  });\n  if (!canInterpret) common.error('could not interpret expression');\n  if (options.link) {\n    try {\n      return common.statNoFollowLinks(path).isSymbolicLink();\n    } catch (e) {\n      return false;\n    }\n  }\n  if (!fs.existsSync(path)) return false;\n  if (options.exists) return true;\n  var stats = common.statFollowLinks(path);\n  if (options.block) return stats.isBlockDevice();\n  if (options.character) return stats.isCharacterDevice();\n  if (options.directory) return stats.isDirectory();\n  if (options.file) return stats.isFile();\n\n  /* istanbul ignore next */\n  if (options.pipe) return stats.isFIFO();\n\n  /* istanbul ignore next */\n  if (options.socket) return stats.isSocket();\n\n  /* istanbul ignore next */\n  return false; // fallback\n} // test\nmodule.exports = _test;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\test.js");

/***/ }),

/***/ "./node_modules/shelljs/src/to.js":
/*!****************************************!*\
  !*** ./node_modules/shelljs/src/to.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/shelljs/src/common.js\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar path = __webpack_require__(/*! path */ \"path\");\ncommon.register('to', _to, {\n  pipeOnly: true,\n  wrapOutput: false\n});\n\n//@\n//@ ### ShellString.prototype.to(file)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ cat('input.txt').to('output.txt');\n//@ ```\n//@\n//@ Analogous to the redirection operator `>` in Unix, but works with\n//@ `ShellStrings` (such as those returned by `cat`, `grep`, etc.). _Like Unix\n//@ redirections, `to()` will overwrite any existing file!_\nfunction _to(options, file) {\n  if (!file) common.error('wrong arguments');\n  if (!fs.existsSync(path.dirname(file))) {\n    common.error('no such file or directory: ' + path.dirname(file));\n  }\n  try {\n    fs.writeFileSync(file, this.stdout || this.toString(), 'utf8');\n    return this;\n  } catch (e) {\n    /* istanbul ignore next */\n    common.error('could not write to file (code ' + e.code + '): ' + file, {\n      continue: true\n    });\n  }\n}\nmodule.exports = _to;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\to.js");

/***/ }),

/***/ "./node_modules/shelljs/src/toEnd.js":
/*!*******************************************!*\
  !*** ./node_modules/shelljs/src/toEnd.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/shelljs/src/common.js\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar path = __webpack_require__(/*! path */ \"path\");\ncommon.register('toEnd', _toEnd, {\n  pipeOnly: true,\n  wrapOutput: false\n});\n\n//@\n//@ ### ShellString.prototype.toEnd(file)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ cat('input.txt').toEnd('output.txt');\n//@ ```\n//@\n//@ Analogous to the redirect-and-append operator `>>` in Unix, but works with\n//@ `ShellStrings` (such as those returned by `cat`, `grep`, etc.).\nfunction _toEnd(options, file) {\n  if (!file) common.error('wrong arguments');\n  if (!fs.existsSync(path.dirname(file))) {\n    common.error('no such file or directory: ' + path.dirname(file));\n  }\n  try {\n    fs.appendFileSync(file, this.stdout || this.toString(), 'utf8');\n    return this;\n  } catch (e) {\n    /* istanbul ignore next */\n    common.error('could not append to file (code ' + e.code + '): ' + file, {\n      continue: true\n    });\n  }\n}\nmodule.exports = _toEnd;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\toEnd.js");

/***/ }),

/***/ "./node_modules/shelljs/src/touch.js":
/*!*******************************************!*\
  !*** ./node_modules/shelljs/src/touch.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/shelljs/src/common.js\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\ncommon.register('touch', _touch, {\n  cmdOptions: {\n    'a': 'atime_only',\n    'c': 'no_create',\n    'd': 'date',\n    'm': 'mtime_only',\n    'r': 'reference'\n  }\n});\n\n//@\n//@ ### touch([options,] file [, file ...])\n//@ ### touch([options,] file_array)\n//@\n//@ Available options:\n//@\n//@ + `-a`: Change only the access time\n//@ + `-c`: Do not create any files\n//@ + `-m`: Change only the modification time\n//@ + `-d DATE`: Parse `DATE` and use it instead of current time\n//@ + `-r FILE`: Use `FILE`'s times instead of current time\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ touch('source.js');\n//@ touch('-c', '/path/to/some/dir/source.js');\n//@ touch({ '-r': FILE }, '/path/to/some/dir/source.js');\n//@ ```\n//@\n//@ Update the access and modification times of each `FILE` to the current time.\n//@ A `FILE` argument that does not exist is created empty, unless `-c` is supplied.\n//@ This is a partial implementation of [`touch(1)`](http://linux.die.net/man/1/touch).\nfunction _touch(opts, files) {\n  if (!files) {\n    common.error('no files given');\n  } else if (typeof files === 'string') {\n    files = [].slice.call(arguments, 1);\n  } else {\n    common.error('file arg should be a string file path or an Array of string file paths');\n  }\n  files.forEach(function (f) {\n    touchFile(opts, f);\n  });\n  return '';\n}\nfunction touchFile(opts, file) {\n  var stat = tryStatFile(file);\n  if (stat && stat.isDirectory()) {\n    // don't error just exit\n    return;\n  }\n\n  // if the file doesn't already exist and the user has specified --no-create then\n  // this script is finished\n  if (!stat && opts.no_create) {\n    return;\n  }\n\n  // open the file and then close it. this will create it if it doesn't exist but will\n  // not truncate the file\n  fs.closeSync(fs.openSync(file, 'a'));\n\n  //\n  // Set timestamps\n  //\n\n  // setup some defaults\n  var now = new Date();\n  var mtime = opts.date || now;\n  var atime = opts.date || now;\n\n  // use reference file\n  if (opts.reference) {\n    var refStat = tryStatFile(opts.reference);\n    if (!refStat) {\n      common.error('failed to get attributess of ' + opts.reference);\n    }\n    mtime = refStat.mtime;\n    atime = refStat.atime;\n  } else if (opts.date) {\n    mtime = opts.date;\n    atime = opts.date;\n  }\n  if (opts.atime_only && opts.mtime_only) {\n    // keep the new values of mtime and atime like GNU\n  } else if (opts.atime_only) {\n    mtime = stat.mtime;\n  } else if (opts.mtime_only) {\n    atime = stat.atime;\n  }\n  fs.utimesSync(file, atime, mtime);\n}\nmodule.exports = _touch;\nfunction tryStatFile(filePath) {\n  try {\n    return common.statFollowLinks(filePath);\n  } catch (e) {\n    return null;\n  }\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\touch.js");

/***/ }),

/***/ "./node_modules/shelljs/src/uniq.js":
/*!******************************************!*\
  !*** ./node_modules/shelljs/src/uniq.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/shelljs/src/common.js\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\n\n// add c spaces to the left of str\nfunction lpad(c, str) {\n  var res = '' + str;\n  if (res.length < c) {\n    res = Array(c - res.length + 1).join(' ') + res;\n  }\n  return res;\n}\ncommon.register('uniq', _uniq, {\n  canReceivePipe: true,\n  cmdOptions: {\n    'i': 'ignoreCase',\n    'c': 'count',\n    'd': 'duplicates'\n  }\n});\n\n//@\n//@ ### uniq([options,] [input, [output]])\n//@\n//@ Available options:\n//@\n//@ + `-i`: Ignore case while comparing\n//@ + `-c`: Prefix lines by the number of occurrences\n//@ + `-d`: Only print duplicate lines, one for each group of identical lines\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ uniq('foo.txt');\n//@ uniq('-i', 'foo.txt');\n//@ uniq('-cd', 'foo.txt', 'bar.txt');\n//@ ```\n//@\n//@ Filter adjacent matching lines from `input`.\nfunction _uniq(options, input, output) {\n  // Check if this is coming from a pipe\n  var pipe = common.readFromPipe();\n  if (!pipe) {\n    if (!input) common.error('no input given');\n    if (!fs.existsSync(input)) {\n      common.error(input + ': No such file or directory');\n    } else if (common.statFollowLinks(input).isDirectory()) {\n      common.error(\"error reading '\" + input + \"'\");\n    }\n  }\n  if (output && fs.existsSync(output) && common.statFollowLinks(output).isDirectory()) {\n    common.error(output + ': Is a directory');\n  }\n  var lines = (input ? fs.readFileSync(input, 'utf8') : pipe).trimRight().split('\\n');\n  var compare = function compare(a, b) {\n    return options.ignoreCase ? a.toLocaleLowerCase().localeCompare(b.toLocaleLowerCase()) : a.localeCompare(b);\n  };\n  var uniqed = lines.reduceRight(function (res, e) {\n    // Perform uniq -c on the input\n    if (res.length === 0) {\n      return [{\n        count: 1,\n        ln: e\n      }];\n    } else if (compare(res[0].ln, e) === 0) {\n      return [{\n        count: res[0].count + 1,\n        ln: e\n      }].concat(res.slice(1));\n    } else {\n      return [{\n        count: 1,\n        ln: e\n      }].concat(res);\n    }\n  }, []).filter(function (obj) {\n    // Do we want only duplicated objects?\n    return options.duplicates ? obj.count > 1 : true;\n  }).map(function (obj) {\n    // Are we tracking the counts of each line?\n    return (options.count ? lpad(7, obj.count) + ' ' : '') + obj.ln;\n  }).join('\\n') + '\\n';\n  if (output) {\n    new common.ShellString(uniqed).to(output);\n    // if uniq writes to output, nothing is passed to the next command in the pipeline (if any)\n    return '';\n  } else {\n    return uniqed;\n  }\n}\nmodule.exports = _uniq;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\uniq.js");

/***/ }),

/***/ "./node_modules/shelljs/src/which.js":
/*!*******************************************!*\
  !*** ./node_modules/shelljs/src/which.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/shelljs/src/common.js\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar path = __webpack_require__(/*! path */ \"path\");\ncommon.register('which', _which, {\n  allowGlobbing: false,\n  cmdOptions: {\n    'a': 'all'\n  }\n});\n\n// XP's system default value for `PATHEXT` system variable, just in case it's not\n// set on Windows.\nvar XP_DEFAULT_PATHEXT = '.com;.exe;.bat;.cmd;.vbs;.vbe;.js;.jse;.wsf;.wsh';\n\n// For earlier versions of NodeJS that doesn't have a list of constants (< v6)\nvar FILE_EXECUTABLE_MODE = 1;\nfunction isWindowsPlatform() {\n  return process.platform === 'win32';\n}\n\n// Cross-platform method for splitting environment `PATH` variables\nfunction splitPath(p) {\n  return p ? p.split(path.delimiter) : [];\n}\n\n// Tests are running all cases for this func but it stays uncovered by codecov due to unknown reason\n/* istanbul ignore next */\nfunction isExecutable(pathName) {\n  try {\n    // TODO(node-support): replace with fs.constants.X_OK once remove support for node < v6\n    fs.accessSync(pathName, FILE_EXECUTABLE_MODE);\n  } catch (err) {\n    return false;\n  }\n  return true;\n}\nfunction checkPath(pathName) {\n  return fs.existsSync(pathName) && !common.statFollowLinks(pathName).isDirectory() && (isWindowsPlatform() || isExecutable(pathName));\n}\n\n//@\n//@ ### which(command)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ var nodeExec = which('node');\n//@ ```\n//@\n//@ Searches for `command` in the system's `PATH`. On Windows, this uses the\n//@ `PATHEXT` variable to append the extension if it's not already executable.\n//@ Returns string containing the absolute path to `command`.\nfunction _which(options, cmd) {\n  if (!cmd) common.error('must specify command');\n  var isWindows = isWindowsPlatform();\n  var pathArray = splitPath(process.env.PATH);\n  var queryMatches = [];\n\n  // No relative/absolute paths provided?\n  if (cmd.indexOf('/') === -1) {\n    // Assume that there are no extensions to append to queries (this is the\n    // case for unix)\n    var pathExtArray = [''];\n    if (isWindows) {\n      // In case the PATHEXT variable is somehow not set (e.g.\n      // child_process.spawn with an empty environment), use the XP default.\n      var pathExtEnv = process.env.PATHEXT || XP_DEFAULT_PATHEXT;\n      pathExtArray = splitPath(pathExtEnv.toUpperCase());\n    }\n\n    // Search for command in PATH\n    for (var k = 0; k < pathArray.length; k++) {\n      // already found it\n      if (queryMatches.length > 0 && !options.all) break;\n      var attempt = path.resolve(pathArray[k], cmd);\n      if (isWindows) {\n        attempt = attempt.toUpperCase();\n      }\n      var match = attempt.match(/\\.[^<>:\"/\\|?*.]+$/);\n      if (match && pathExtArray.indexOf(match[0]) >= 0) {\n        // this is Windows-only\n        // The user typed a query with the file extension, like\n        // `which('node.exe')`\n        if (checkPath(attempt)) {\n          queryMatches.push(attempt);\n          break;\n        }\n      } else {\n        // All-platforms\n        // Cycle through the PATHEXT array, and check each extension\n        // Note: the array is always [''] on Unix\n        for (var i = 0; i < pathExtArray.length; i++) {\n          var ext = pathExtArray[i];\n          var newAttempt = attempt + ext;\n          if (checkPath(newAttempt)) {\n            queryMatches.push(newAttempt);\n            break;\n          }\n        }\n      }\n    }\n  } else if (checkPath(cmd)) {\n    // a valid absolute or relative path\n    queryMatches.push(path.resolve(cmd));\n  }\n  if (queryMatches.length > 0) {\n    return options.all ? queryMatches : queryMatches[0];\n  }\n  return options.all ? [] : null;\n}\nmodule.exports = _which;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src\\which.js");

/***/ }),

/***/ "./node_modules/uuid/lib/bytesToUuid.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/bytesToUuid.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');\n}\nmodule.exports = bytesToUuid;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\uuid\\lib\\bytesToUuid.js");

/***/ }),

/***/ "./node_modules/uuid/lib/rng.js":
/*!**************************************!*\
  !*** ./node_modules/uuid/lib/rng.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// Unique ID creation requires a high quality random # generator.  In node.js\n// this is pretty straight-forward - we use the crypto API.\n\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nmodule.exports = function nodeRNG() {\n  return crypto.randomBytes(16);\n};\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\uuid\\lib\\rng.js");

/***/ }),

/***/ "./node_modules/uuid/v4.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v4.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar rng = __webpack_require__(/*! ./lib/rng */ \"./node_modules/uuid/lib/rng.js\");\nvar bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ \"./node_modules/uuid/lib/bytesToUuid.js\");\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n  if (typeof options == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n  return buf || bytesToUuid(rnds);\n}\nmodule.exports = v4;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\uuid\\v4.js");

/***/ }),

/***/ "./node_modules/wrappy/wrappy.js":
/*!***************************************!*\
  !*** ./node_modules/wrappy/wrappy.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy;\nfunction wrappy(fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb);\n  if (typeof fn !== 'function') throw new TypeError('need wrapper function');\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k];\n  });\n  return wrapper;\n  function wrapper() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    var ret = fn.apply(this, args);\n    var cb = args[args.length - 1];\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k];\n      });\n    }\n    return ret;\n  }\n}\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\wrappy\\wrappy.js");

/***/ }),

/***/ "./node_modules/shelljs/src sync recursive ^\\.\\/.*$":
/*!*************************************************!*\
  !*** ./node_modules/shelljs/src/ sync ^\.\/.*$ ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var map = {\n\t\"./cat\": \"./node_modules/shelljs/src/cat.js\",\n\t\"./cat.js\": \"./node_modules/shelljs/src/cat.js\",\n\t\"./cd\": \"./node_modules/shelljs/src/cd.js\",\n\t\"./cd.js\": \"./node_modules/shelljs/src/cd.js\",\n\t\"./chmod\": \"./node_modules/shelljs/src/chmod.js\",\n\t\"./chmod.js\": \"./node_modules/shelljs/src/chmod.js\",\n\t\"./common\": \"./node_modules/shelljs/src/common.js\",\n\t\"./common.js\": \"./node_modules/shelljs/src/common.js\",\n\t\"./cp\": \"./node_modules/shelljs/src/cp.js\",\n\t\"./cp.js\": \"./node_modules/shelljs/src/cp.js\",\n\t\"./dirs\": \"./node_modules/shelljs/src/dirs.js\",\n\t\"./dirs.js\": \"./node_modules/shelljs/src/dirs.js\",\n\t\"./echo\": \"./node_modules/shelljs/src/echo.js\",\n\t\"./echo.js\": \"./node_modules/shelljs/src/echo.js\",\n\t\"./error\": \"./node_modules/shelljs/src/error.js\",\n\t\"./error.js\": \"./node_modules/shelljs/src/error.js\",\n\t\"./exec\": \"./node_modules/shelljs/src/exec.js\",\n\t\"./exec-child\": \"./node_modules/shelljs/src/exec-child.js\",\n\t\"./exec-child.js\": \"./node_modules/shelljs/src/exec-child.js\",\n\t\"./exec.js\": \"./node_modules/shelljs/src/exec.js\",\n\t\"./find\": \"./node_modules/shelljs/src/find.js\",\n\t\"./find.js\": \"./node_modules/shelljs/src/find.js\",\n\t\"./grep\": \"./node_modules/shelljs/src/grep.js\",\n\t\"./grep.js\": \"./node_modules/shelljs/src/grep.js\",\n\t\"./head\": \"./node_modules/shelljs/src/head.js\",\n\t\"./head.js\": \"./node_modules/shelljs/src/head.js\",\n\t\"./ln\": \"./node_modules/shelljs/src/ln.js\",\n\t\"./ln.js\": \"./node_modules/shelljs/src/ln.js\",\n\t\"./ls\": \"./node_modules/shelljs/src/ls.js\",\n\t\"./ls.js\": \"./node_modules/shelljs/src/ls.js\",\n\t\"./mkdir\": \"./node_modules/shelljs/src/mkdir.js\",\n\t\"./mkdir.js\": \"./node_modules/shelljs/src/mkdir.js\",\n\t\"./mv\": \"./node_modules/shelljs/src/mv.js\",\n\t\"./mv.js\": \"./node_modules/shelljs/src/mv.js\",\n\t\"./popd\": \"./node_modules/shelljs/src/popd.js\",\n\t\"./popd.js\": \"./node_modules/shelljs/src/popd.js\",\n\t\"./pushd\": \"./node_modules/shelljs/src/pushd.js\",\n\t\"./pushd.js\": \"./node_modules/shelljs/src/pushd.js\",\n\t\"./pwd\": \"./node_modules/shelljs/src/pwd.js\",\n\t\"./pwd.js\": \"./node_modules/shelljs/src/pwd.js\",\n\t\"./rm\": \"./node_modules/shelljs/src/rm.js\",\n\t\"./rm.js\": \"./node_modules/shelljs/src/rm.js\",\n\t\"./sed\": \"./node_modules/shelljs/src/sed.js\",\n\t\"./sed.js\": \"./node_modules/shelljs/src/sed.js\",\n\t\"./set\": \"./node_modules/shelljs/src/set.js\",\n\t\"./set.js\": \"./node_modules/shelljs/src/set.js\",\n\t\"./sort\": \"./node_modules/shelljs/src/sort.js\",\n\t\"./sort.js\": \"./node_modules/shelljs/src/sort.js\",\n\t\"./tail\": \"./node_modules/shelljs/src/tail.js\",\n\t\"./tail.js\": \"./node_modules/shelljs/src/tail.js\",\n\t\"./tempdir\": \"./node_modules/shelljs/src/tempdir.js\",\n\t\"./tempdir.js\": \"./node_modules/shelljs/src/tempdir.js\",\n\t\"./test\": \"./node_modules/shelljs/src/test.js\",\n\t\"./test.js\": \"./node_modules/shelljs/src/test.js\",\n\t\"./to\": \"./node_modules/shelljs/src/to.js\",\n\t\"./to.js\": \"./node_modules/shelljs/src/to.js\",\n\t\"./toEnd\": \"./node_modules/shelljs/src/toEnd.js\",\n\t\"./toEnd.js\": \"./node_modules/shelljs/src/toEnd.js\",\n\t\"./touch\": \"./node_modules/shelljs/src/touch.js\",\n\t\"./touch.js\": \"./node_modules/shelljs/src/touch.js\",\n\t\"./uniq\": \"./node_modules/shelljs/src/uniq.js\",\n\t\"./uniq.js\": \"./node_modules/shelljs/src/uniq.js\",\n\t\"./which\": \"./node_modules/shelljs/src/which.js\",\n\t\"./which.js\": \"./node_modules/shelljs/src/which.js\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./node_modules/shelljs/src sync recursive ^\\\\.\\\\/.*$\";\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\shelljs\\src%7Csync%7C\\^\\.*$");

/***/ }),

/***/ "./src/lib/common/http-client.ts":
/*!***************************************!*\
  !*** ./src/lib/common/http-client.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HttpResponseError = exports.HttpErrors = exports.getTokenAuthorizationHeader = exports.isErrorStatusCode = exports.isJsonContentType = exports.getContentCharset = exports.isRedirectStatusCode = void 0;\nfunction isRedirectStatusCode(code) {\n    if (typeof code === 'undefined')\n        return false;\n    return code >= 300 && code < 400;\n}\nexports.isRedirectStatusCode = isRedirectStatusCode;\nvar charsetRegx = /;\\s*charset\\s*=[^;]+/i;\nfunction getContentCharset(contentType) {\n    if (!contentType) {\n        return;\n    }\n    var match = contentType.match(charsetRegx);\n    if (match && match.length > 0) {\n        var idx = match[0].indexOf('=');\n        return match[0].substring(idx + 1).trim();\n    }\n    return;\n}\nexports.getContentCharset = getContentCharset;\nfunction isJsonContentType(contentType) {\n    return ((contentType === null || contentType === void 0 ? void 0 : contentType.trim().toLowerCase().startsWith('application/json')) || false);\n}\nexports.isJsonContentType = isJsonContentType;\nfunction isErrorStatusCode(code) {\n    return typeof code !== 'undefined'\n        && code != null\n        && code >= 400 && code < 600;\n}\nexports.isErrorStatusCode = isErrorStatusCode;\nfunction getTokenAuthorizationHeader(token) {\n    var buffer = Buffer.from(\":\".concat(token)).toString('base64');\n    return \"Basic \".concat(buffer);\n}\nexports.getTokenAuthorizationHeader = getTokenAuthorizationHeader;\nvar HttpErrors;\n(function (HttpErrors) {\n    HttpErrors[HttpErrors[\"BadRequest\"] = 400] = \"BadRequest\";\n    HttpErrors[HttpErrors[\"NotFound\"] = 404] = \"NotFound\";\n})(HttpErrors || (exports.HttpErrors = HttpErrors = {}));\nvar HttpResponseError = /** @class */ (function (_super) {\n    __extends(HttpResponseError, _super);\n    /*\n    private _message: string;\n    get name(): string {\n        return 'HttpError';\n    }\n    get message(): string{\n        return this._message;\n    }\n    stack?: string;\n    */\n    function HttpResponseError(statusCode, message, responseContent) {\n        var _this = this;\n        var msg = message || 'HTTPError';\n        _this = _super.call(this, msg) || this;\n        _this.statusCode = statusCode;\n        _this.responseContent = responseContent;\n        if (!msg && statusCode) {\n            msg = \"\".concat(HttpErrors[statusCode]);\n        }\n        _this.message = msg;\n        return _this;\n        //super(message);\n    }\n    return HttpResponseError;\n}(Error));\nexports.HttpResponseError = HttpResponseError;\n\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\src\\lib\\common\\http-client.ts");

/***/ }),

/***/ "./src/lib/common/logging.ts":
/*!***********************************!*\
  !*** ./src/lib/common/logging.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NullLogger = void 0;\nvar NullLogger = exports.NullLogger = /** @class */ (function () {\n    function NullLogger() {\n    }\n    NullLogger.prototype.debug = function () { };\n    NullLogger.prototype.info = function () { };\n    NullLogger.prototype.warn = function () { };\n    NullLogger.prototype.error = function () { };\n    NullLogger.prototype.command = function () { };\n    NullLogger.Instance = new NullLogger();\n    return NullLogger;\n}());\n\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\src\\lib\\common\\logging.ts");

/***/ }),

/***/ "./src/lib/common/utilities.ts":
/*!*************************************!*\
  !*** ./src/lib/common/utilities.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sleep = exports.isNullOrWhitespace = exports.makeAbsoluteUri = exports.isAbsoluteUrl = exports.parseDate = void 0;\nvar moment_1 = __importDefault(__webpack_require__(/*! moment */ \"./node_modules/moment/moment.js\"));\nfunction parseDate(str) {\n    return (0, moment_1.default)(str);\n}\nexports.parseDate = parseDate;\nvar absUrlRegex = new RegExp('^(?:[a-z+]+:)?//', 'i');\nfunction isAbsoluteUrl(url) {\n    return absUrlRegex.test(url);\n}\nexports.isAbsoluteUrl = isAbsoluteUrl;\nfunction makeAbsoluteUri(uri, relativePath) {\n    if (isAbsoluteUrl(uri)) {\n        throw new Error('Cannot make an absolute URI from  ');\n    }\n    var url = new URL(uri);\n    if (relativePath.startsWith('/')) {\n        url.pathname = relativePath;\n    }\n    else {\n        url.pathname += relativePath;\n    }\n    return url;\n}\nexports.makeAbsoluteUri = makeAbsoluteUri;\nfunction isNullOrWhitespace(str) {\n    if (!str)\n        return true;\n    return !str.trim();\n}\nexports.isNullOrWhitespace = isNullOrWhitespace;\nfunction sleep(timeout) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            return [2 /*return*/, new Promise(function (resolve) {\n                    setTimeout(function () { return resolve(); }, timeout);\n                })];\n        });\n    });\n}\nexports.sleep = sleep;\n\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\src\\lib\\common\\utilities.ts");

/***/ }),

/***/ "./src/lib/node/http-client-impl.ts":
/*!******************************************!*\
  !*** ./src/lib/node/http-client-impl.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HttpClientImpl = void 0;\nvar https = __importStar(__webpack_require__(/*! https */ \"https\"));\nvar task_utilities_1 = __webpack_require__(/*! ./task-utilities */ \"./src/lib/node/task-utilities.ts\");\nvar logging_1 = __importDefault(__webpack_require__(/*! ./logging */ \"./src/lib/node/logging.ts\"));\nvar utilities_1 = __webpack_require__(/*! ../common/utilities */ \"./src/lib/common/utilities.ts\");\nvar http_client_1 = __webpack_require__(/*! ../common/http-client */ \"./src/lib/common/http-client.ts\");\nvar logging_2 = __webpack_require__(/*! ../common/logging */ \"./src/lib/common/logging.ts\");\nvar HttpClientImpl = /** @class */ (function () {\n    function HttpClientImpl(access_token, baseUrl, logger) {\n        this._header = {};\n        this.followRedirect = false;\n        this._log = logger || logging_2.NullLogger.Instance;\n        this._baseUrl = baseUrl || (0, task_utilities_1.getCollectionUri)();\n        if (access_token) {\n            this._header['Authorization'] = (0, http_client_1.getTokenAuthorizationHeader)(access_token);\n        }\n        this._header['Accept'] = 'application/json';\n    }\n    HttpClientImpl.prototype._request = function (method, uri, body, headers) {\n        var _this = this;\n        var url;\n        if (!(0, utilities_1.isAbsoluteUrl)(uri)) {\n            if (!this._baseUrl) {\n                throw new Error('Cannot handle relative urls without baseUrl');\n                ;\n            }\n            url = (0, utilities_1.makeAbsoluteUri)(this._baseUrl, uri);\n        }\n        else {\n            url = new URL(uri);\n        }\n        var hdrs = {};\n        if (body) {\n            var contentType = void 0;\n            if (typeof body === 'object') {\n                body = JSON.stringify(body);\n                contentType = 'application/json';\n            }\n            else if (typeof body === 'string') {\n                contentType = 'text';\n            }\n            else {\n                throw new Error('Invalid item type');\n            }\n            hdrs['Content-Type'] = contentType;\n            hdrs['Content-Length'] = Buffer.from(body).byteLength;\n        }\n        if (headers) {\n            hdrs = Object.assign(hdrs, headers);\n        }\n        return new Promise(function (resolve, reject) {\n            var headers = Object.assign(_this._header, hdrs);\n            _this._log.debug(\"\".concat(method, \" \").concat(uri));\n            (0, logging_1.default)(\"Headers:\", headers);\n            var opts = {\n                method: method,\n                hostname: url.hostname,\n                host: url.host,\n                port: url.port,\n                path: \"\".concat(url.pathname).concat(url.search),\n                headers: headers\n            };\n            var buffer = undefined;\n            var end_called = false;\n            var request = https.request(opts, function (res) {\n                res.on('data', function (chunk) {\n                    _this._log.debug('DATA received');\n                    if (!buffer) {\n                        buffer = Buffer.from(chunk);\n                    }\n                    else {\n                        buffer = Buffer.concat([buffer, chunk]);\n                    }\n                });\n                res.on('end', function () {\n                    end_called = true;\n                    console.log(res.headers);\n                    var resp;\n                    var ct = res.headers['content-type'];\n                    var cl = res.headers['content-length'];\n                    if ((0, http_client_1.isRedirectStatusCode)(res.statusCode)) {\n                        if (_this.followRedirect) {\n                            // no need to read content. Directly redirect (TODO)\n                        }\n                    }\n                    if (buffer && buffer.length > 0) {\n                        if (!cl || (buffer.length !== parseInt(cl))) {\n                            console.warn('Buffer length and content-length differs');\n                        }\n                        var chSet = (0, http_client_1.getContentCharset)(ct);\n                        if (chSet)\n                            logging_1.default.info(\"Got charset: \".concat(chSet));\n                        else\n                            logging_1.default.info('No charset returned');\n                        try {\n                            resp = buffer.toString(chSet);\n                        }\n                        catch (err) {\n                            try {\n                                resp = buffer.toString('utf-8');\n                                chSet = 'utf-8';\n                            }\n                            catch (err2) {\n                                throw err;\n                            }\n                        }\n                        if (resp && (0, http_client_1.isJsonContentType)(ct)) {\n                            resp = JSON.parse(resp);\n                        }\n                        else\n                            console.log('NO: ', ct);\n                    }\n                    logging_1.default.info('HTTP reponse status:', res.statusCode);\n                    try {\n                        if ((0, http_client_1.isErrorStatusCode)(res.statusCode)) {\n                            //reject(new HttpResponseError(res.statusCode, res.statusMessage, resp));\n                            reject(new http_client_1.HttpResponseError(res.statusCode, res.statusMessage, resp));\n                        }\n                        else if ((0, http_client_1.isRedirectStatusCode)(res.statusCode)) {\n                            reject(new http_client_1.HttpResponseError(res.statusCode, res.statusMessage, resp));\n                        }\n                        else {\n                            resolve(resp);\n                        }\n                    }\n                    catch (err) {\n                        reject(err);\n                    }\n                });\n                res.on('close', function () {\n                    if (!end_called) {\n                        _this._log.warn('CLOSE CALLED BEFORE END');\n                        setTimeout(function () { return reject('Close without end?'); }, 500);\n                    }\n                });\n                res.on('error', function (err) {\n                    reject(err);\n                });\n            });\n            if (body) {\n                request.write(body);\n            }\n            request.end();\n        });\n    };\n    HttpClientImpl.prototype.getAsync = function (uri, headers) {\n        return this._request('GET', uri, null, headers);\n        ;\n    };\n    HttpClientImpl.prototype.postAsync = function (uri, body) {\n        return this._request('POST', uri, body);\n        ;\n    };\n    HttpClientImpl.prototype.putAsync = function (uri, body) {\n        return this._request('PUT', uri, body);\n        ;\n    };\n    HttpClientImpl.prototype.patchAsync = function (uri, body) {\n        return this._request('PATCH', uri, body);\n        ;\n    };\n    HttpClientImpl.prototype.deleteAsync = function (uri, body) {\n        return this._request('DELETE', uri, body);\n        ;\n    };\n    return HttpClientImpl;\n}());\nexports.HttpClientImpl = HttpClientImpl;\n\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\src\\lib\\node\\http-client-impl.ts");

/***/ }),

/***/ "./src/lib/node/logging.ts":
/*!*********************************!*\
  !*** ./src/lib/node/logging.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar _info;\nvar _warn;\nvar _error;\nvar _debug;\nvar fancy = true;\ntry {\n    new (__webpack_require__(/*! console */ \"console\").Console)({\n        stdout: process.stdout,\n        stderr: process.stderr,\n    });\n}\ncatch (err) {\n    fancy = false;\n    //console.error(`Console (O: ${process.stdout.writable}, E: ${process.stderr.writable}) not created`);\n}\nif (!fancy || !process.stdout.writable || !process.stderr.writable) {\n    //_info = console.log;\n    _info = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        console.error('WRITING INFO', args);\n        console.log.apply(null, args);\n        process.stdout.write.apply(process.stdout, args);\n    };\n    _warn = console.warn;\n    //_error = console.error;\n    _error = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        console.error('WRITING ERROR', args);\n        console.error.apply(null, args);\n        process.stderr.write.apply(process.stderr, args);\n    };\n    _debug = console.debug;\n}\nelse {\n    var _fancy = __webpack_require__(/*! fancy-log */ \"./node_modules/fancy-log/index.js\");\n    _info = _fancy.info;\n    _warn = _fancy.warn;\n    _error = _fancy.error;\n    _debug = _fancy.info;\n}\nvar exported = _info;\nexported.info = _info;\nexported.error = _error;\nexported.warn = _warn;\nexported.debug = _debug;\nexports[\"default\"] = exported;\n\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\src\\lib\\node\\logging.ts");

/***/ }),

/***/ "./src/lib/node/task-utilities.ts":
/*!****************************************!*\
  !*** ./src/lib/node/task-utilities.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EXTENSION_NAME = exports.PUBLISHER_NAME = exports.BUILD_NUMBER = exports.BUILD_ID = exports.BUILD_DEFINITION_ID = exports.getCollectionUri = exports.getCollectionName = exports.getExtensionManagementHostUri = exports.splitPatterns = exports.filterPatterns = exports.LocalFileSystem = void 0;\n//import { glob } from \"glob\";\nvar fast_glob_1 = __webpack_require__(/*! fast-glob */ \"./node_modules/fast-glob/out/index.js\");\nvar minimatch_1 = __webpack_require__(/*! minimatch */ \"./node_modules/minimatch/dist/cjs/index.js\");\nvar process_1 = __webpack_require__(/*! process */ \"process\");\nvar vss_extension_json_1 = __importDefault(__webpack_require__(/*! ../../../vss-extension.json */ \"./vss-extension.json\"));\nvar LocalFileSystem = /** @class */ (function () {\n    function LocalFileSystem() {\n    }\n    LocalFileSystem.prototype.findAsync = function (patterns) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, (0, fast_glob_1.glob)(patterns.included, {\n                            ignore: patterns.excluded\n                        })];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    return LocalFileSystem;\n}());\nexports.LocalFileSystem = LocalFileSystem;\nfunction filterPatterns(paths, collection) {\n    var matches = collection.included.map(function (x) { return new minimatch_1.Minimatch(x, {\n        nocase: true\n    }); });\n    var found = [];\n    for (var _i = 0, paths_1 = paths; _i < paths_1.length; _i++) {\n        var path = paths_1[_i];\n        for (var _a = 0, matches_1 = matches; _a < matches_1.length; _a++) {\n            var match = matches_1[_a];\n            if (match.match(path)) {\n                found.push(path);\n                continue;\n            }\n        }\n    }\n    return found;\n}\nexports.filterPatterns = filterPatterns;\nfunction splitPatterns(text) {\n    var patterns = text.split('\\n');\n    var excludePatterns = [];\n    var includedPatterns = [];\n    for (var _i = 0, patterns_1 = patterns; _i < patterns_1.length; _i++) {\n        var pattern = patterns_1[_i];\n        if (!pattern)\n            continue;\n        if (pattern[0] === '!') {\n            excludePatterns.push(pattern.substring(1));\n            continue;\n        }\n        includedPatterns.push(pattern);\n    }\n    return {\n        included: includedPatterns,\n        excluded: excludePatterns\n    };\n}\nexports.splitPatterns = splitPatterns;\nfunction getExtensionManagementHostUri() {\n    return 'https://extmgmt.dev.azure.com';\n}\nexports.getExtensionManagementHostUri = getExtensionManagementHostUri;\nfunction getCollectionName() {\n    return process_1.env['SYSTEM_COLLECTIONID'];\n}\nexports.getCollectionName = getCollectionName;\nfunction getCollectionUri() {\n    return process_1.env['SYSTEM_TEAMFOUNDATIONCOLLECTIONURI'];\n}\nexports.getCollectionUri = getCollectionUri;\nexports.BUILD_DEFINITION_ID = process_1.env['SYSTEM_DEFINITIONID'];\nexports.BUILD_ID = process_1.env['BUILD_BUILDID'];\nexports.BUILD_NUMBER = process_1.env['BUILD_BUILNUMBER'];\nexports.PUBLISHER_NAME = vss_extension_json_1.default.publisher;\nexports.EXTENSION_NAME = vss_extension_json_1.default.name;\n\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\src\\lib\\node\\task-utilities.ts");

/***/ }),

/***/ "./src/tasks/azure-sdk-utils.ts":
/*!**************************************!*\
  !*** ./src/tasks/azure-sdk-utils.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getAccessToken = void 0;\nvar task_1 = __webpack_require__(/*! azure-pipelines-task-lib/task */ \"./node_modules/azure-pipelines-task-lib/task.js\");\nvar process_1 = __webpack_require__(/*! process */ \"process\");\nfunction getAccessToken() {\n    var _a;\n    var accessToken = (_a = process_1.env['SYSTEM_ACCESSTOKEN']) !== null && _a !== void 0 ? _a : process_1.env['SECRET_SYSTEM_ACCESSTOKEN'];\n    if (accessToken)\n        return accessToken;\n    return (0, task_1.getEndpointAuthorizationParameter)('SystemVssConnection', 'AccessToken', false);\n}\nexports.getAccessToken = getAccessToken;\n\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\src\\tasks\\azure-sdk-utils.ts");

/***/ }),

/***/ "./src/tasks/document-data.service.ts":
/*!********************************************!*\
  !*** ./src/tasks/document-data.service.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DocumentDataService = void 0;\nvar task_utilities_1 = __webpack_require__(/*! ../lib/node/task-utilities */ \"./src/lib/node/task-utilities.ts\");\nvar http_client_1 = __webpack_require__(/*! ../lib/common/http-client */ \"./src/lib/common/http-client.ts\");\nvar logging_1 = __webpack_require__(/*! ../lib/common/logging */ \"./src/lib/common/logging.ts\");\nvar utilities_1 = __webpack_require__(/*! ../lib/common/utilities */ \"./src/lib/common/utilities.ts\");\nvar API_VERSION = '7.1-preview.1';\nfunction getScope(scope) {\n    if (scope === 1 /* DocumentScope.Project */)\n        return 'Default/Current';\n    else if (scope === 2 /* DocumentScope.User */)\n        return 'User/Me';\n    else\n        throw new Error('Unknown document scope');\n}\nvar DocumentDataService = /** @class */ (function () {\n    function DocumentDataService(_handler) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        this._handler = _handler;\n        this._logger = null;\n        if (args.length > 0) {\n            if (typeof args[0] === 'string') {\n                this._default_doc_collection = args[0];\n            }\n            else if (typeof args[0] === 'object') {\n                this._logger = args[0];\n            }\n            else {\n                throw new Error();\n            }\n            if (args.length > 1) {\n                if (typeof args[1] === 'object') {\n                    if (this._logger) {\n                        throw new Error();\n                    }\n                    this._logger = args[1];\n                }\n                else {\n                    throw new Error();\n                }\n            }\n        }\n        if (!this._logger) {\n            this._logger = logging_1.NullLogger.Instance;\n        }\n    }\n    DocumentDataService.prototype.updateDocumentAsync = function (document_id, document_collection, scope) {\n        if (scope === void 0) { scope = 1 /* DocumentScope.Project */; }\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/];\n            });\n        });\n    };\n    DocumentDataService.prototype.listDocumentsAsync = function (document_collection, scope) {\n        return __awaiter(this, void 0, void 0, function () {\n            var url, response;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        url = this._getDocumentUri(false, document_collection, scope);\n                        this._logger.debug(\"Connecting to: \".concat(url));\n                        return [4 /*yield*/, this._handler.getAsync(url)];\n                    case 1:\n                        response = _a.sent();\n                        return [2 /*return*/, response.value];\n                }\n            });\n        });\n    };\n    DocumentDataService.prototype.getDocumentAsync = function (document_id, document_collection, scope) {\n        return __awaiter(this, void 0, void 0, function () {\n            var url;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        url = this._getDocumentUri(document_id, document_collection, scope);\n                        this._logger.debug(\"Connecting to: \".concat(url));\n                        return [4 /*yield*/, this._handler.getAsync(url)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    DocumentDataService.prototype.deleteDocumentAsync = function (documentId, document_collection, scope) {\n        return __awaiter(this, void 0, void 0, function () {\n            var url, err_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        url = this._getDocumentUri(documentId, document_collection, scope);\n                        this._logger.debug(\"Deleting document: \".concat(url));\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, this._handler.deleteAsync(url)];\n                    case 2:\n                        _a.sent();\n                        return [2 /*return*/, true];\n                    case 3:\n                        err_1 = _a.sent();\n                        if (err_1 instanceof http_client_1.HttpResponseError\n                            && err_1.statusCode == http_client_1.HttpErrors.NotFound) {\n                            return [2 /*return*/, false];\n                        }\n                        throw err_1;\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    DocumentDataService.prototype.createDocumentAsync = function (documentId, content, document_collection, scope) {\n        return __awaiter(this, void 0, void 0, function () {\n            var url, doc;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        url = this._getDocumentUri(documentId, document_collection, scope);\n                        this._logger.debug(\"Creating document: \".concat(url));\n                        doc = {\n                            id: documentId,\n                            value: content\n                        };\n                        return [4 /*yield*/, this._handler.postAsync(url, doc)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    DocumentDataService.prototype._getDocumentUri = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var document_id = args[0];\n        if (typeof document_id === 'undefined') {\n            throw new Error('Null or undefined document id');\n        }\n        else if (typeof document_id === 'string') {\n            if ((0, utilities_1.isNullOrWhitespace)(document_id))\n                throw new Error('Null or undefined document id');\n        }\n        else if (typeof document_id === 'boolean') {\n        }\n        else {\n            throw new Error('Invalid document_id argument');\n        }\n        var scope = 1 /* DocumentScope.Project */;\n        if (args.length > 2 && typeof args[2] !== 'undefined')\n            scope = args[2];\n        var document_collection;\n        if (args.length > 1 && typeof args[1] !== 'undefined')\n            document_collection = args[2];\n        else if (!this._default_doc_collection) {\n            throw new Error();\n        }\n        else {\n            document_collection = this._default_doc_collection;\n        }\n        var scopeUrl = getScope(scope);\n        var url = \"\".concat((0, task_utilities_1.getExtensionManagementHostUri)(), \"/\").concat((0, task_utilities_1.getCollectionName)(), \"/\")\n            + \"_apis/ExtensionManagement/InstalledExtensions/\".concat(task_utilities_1.PUBLISHER_NAME, \"/\").concat(task_utilities_1.EXTENSION_NAME, \"/\")\n            + \"Data/Scopes/\".concat(scopeUrl, \"/Collections/\").concat(document_collection, \"/Documents\");\n        if (document_id)\n            url += \"/\".concat(document_id);\n        url += \"?api-version=\".concat(API_VERSION);\n        return url;\n    };\n    return DocumentDataService;\n}());\nexports.DocumentDataService = DocumentDataService;\n\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\src\\tasks\\document-data.service.ts");

/***/ }),

/***/ "./src/tasks/publish-benchmark-reports/publish-benchmark-reports.ts":
/*!**************************************************************************!*\
  !*** ./src/tasks/publish-benchmark-reports/publish-benchmark-reports.ts ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar tl = __webpack_require__(/*! azure-pipelines-task-lib/task */ \"./node_modules/azure-pipelines-task-lib/task.js\");\nvar task_utilities_1 = __webpack_require__(/*! ../../lib/node/task-utilities */ \"./src/lib/node/task-utilities.ts\");\nvar azure_sdk_utils_1 = __webpack_require__(/*! ../azure-sdk-utils */ \"./src/tasks/azure-sdk-utils.ts\");\nvar task_logger_1 = __webpack_require__(/*! ../task-logger */ \"./src/tasks/task-logger.ts\");\nvar document_data_service_1 = __webpack_require__(/*! ../document-data.service */ \"./src/tasks/document-data.service.ts\");\nvar http_client_impl_1 = __webpack_require__(/*! ../../lib/node/http-client-impl */ \"./src/lib/node/http-client-impl.ts\");\nvar fast_glob_1 = __webpack_require__(/*! fast-glob */ \"./node_modules/fast-glob/out/index.js\");\nfunction run() {\n    return __awaiter(this, void 0, void 0, function () {\n        var paths, logger, accessToken, httpClient, svc, allDocs, patterns, found, err_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 3, , 4]);\n                    paths = tl.getInput('reportPaths', true);\n                    if (!paths) {\n                        console.log('Input 1');\n                        tl.setResult(tl.TaskResult.SucceededWithIssues, 'No inputs provided');\n                        return [2 /*return*/];\n                    }\n                    console.log('Input 2');\n                    logger = new task_logger_1.TaskLogger();\n                    accessToken = (0, azure_sdk_utils_1.getAccessToken)();\n                    if (!accessToken) {\n                        tl.setResult(tl.TaskResult.Failed, 'Unable to obtain agent acess token');\n                        return [2 /*return*/];\n                    }\n                    console.log(\"Got access token \".concat(accessToken.substring(0, Math.min(accessToken.length, 5))));\n                    httpClient = new http_client_impl_1.HttpClientImpl(accessToken);\n                    svc = new document_data_service_1.DocumentDataService(httpClient);\n                    return [4 /*yield*/, svc.listDocumentsAsync('my-document')];\n                case 1:\n                    allDocs = _a.sent();\n                    console.log('OK done', allDocs);\n                    patterns = (0, task_utilities_1.splitPatterns)(paths);\n                    return [4 /*yield*/, (0, fast_glob_1.glob)(patterns.included, {\n                            ignore: patterns.excluded,\n                        })];\n                case 2:\n                    found = _a.sent();\n                    return [3 /*break*/, 4];\n                case 3:\n                    err_1 = _a.sent();\n                    tl.setResult(tl.TaskResult.Failed, \"Error while getting inputs: \".concat(err_1.message));\n                    console.log(err_1.stack);\n                    return [3 /*break*/, 4];\n                case 4: return [2 /*return*/];\n            }\n        });\n    });\n}\nrun();\n\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\src\\tasks\\publish-benchmark-reports\\publish-benchmark-reports.ts");

/***/ }),

/***/ "./src/tasks/task-logger.ts":
/*!**********************************!*\
  !*** ./src/tasks/task-logger.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TaskLogger = void 0;\nvar azure_pipelines_task_lib_1 = __webpack_require__(/*! azure-pipelines-task-lib */ \"./node_modules/azure-pipelines-task-lib/task.js\");\nvar TaskLogger = /** @class */ (function () {\n    function TaskLogger() {\n    }\n    TaskLogger.prototype.command = function (text) {\n        console.log('##[command]' + text);\n    };\n    TaskLogger.prototype.info = function (message) {\n        console.log(\"##[debug]\".concat(message));\n    };\n    TaskLogger.prototype.debug = function (message) {\n        this.info(message);\n    };\n    TaskLogger.prototype.warn = function (message) {\n        console.log(\"##[warn]\".concat(message));\n        (0, azure_pipelines_task_lib_1.logIssue)(azure_pipelines_task_lib_1.IssueType.Warning, message);\n    };\n    TaskLogger.prototype.error = function (message) {\n        console.log(\"##[error]\".concat(message));\n        (0, azure_pipelines_task_lib_1.logIssue)(azure_pipelines_task_lib_1.IssueType.Error, message);\n    };\n    return TaskLogger;\n}());\nexports.TaskLogger = TaskLogger;\n\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\src\\tasks\\task-logger.ts");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ "console":
/*!**************************!*\
  !*** external "console" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("console");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "process":
/*!**************************!*\
  !*** external "process" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("process");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "./node_modules/minimatch/dist/cjs/assert-valid-pattern.js":
/*!*****************************************************************!*\
  !*** ./node_modules/minimatch/dist/cjs/assert-valid-pattern.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.assertValidPattern = void 0;\nconst MAX_PATTERN_LENGTH = 1024 * 64;\nconst assertValidPattern = pattern => {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern');\n  }\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long');\n  }\n};\nexports.assertValidPattern = assertValidPattern;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\minimatch\\dist\\cjs\\assert-valid-pattern.js");

/***/ }),

/***/ "./node_modules/minimatch/dist/cjs/ast.js":
/*!************************************************!*\
  !*** ./node_modules/minimatch/dist/cjs/ast.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n// parse a single path portion\nvar _class;\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }\nfunction _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError(\"Cannot initialize the same private elements twice on an object\"); } }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError(\"attempted to get private field on non-instance\"); } return fn; }\nfunction _classStaticPrivateMethodGet(receiver, classConstructor, method) { _classCheckPrivateStaticAccess(receiver, classConstructor); return method; }\nfunction _classCheckPrivateStaticAccess(receiver, classConstructor) { if (receiver !== classConstructor) { throw new TypeError(\"Private static access of wrong provenance\"); } }\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\"); return _classApplyDescriptorGet(receiver, descriptor); }\nfunction _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError(\"attempted to \" + action + \" private field on non-instance\"); } return privateMap.get(receiver); }\nfunction _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.AST = void 0;\nconst brace_expressions_js_1 = __webpack_require__(/*! ./brace-expressions.js */ \"./node_modules/minimatch/dist/cjs/brace-expressions.js\");\nconst unescape_js_1 = __webpack_require__(/*! ./unescape.js */ \"./node_modules/minimatch/dist/cjs/unescape.js\");\nconst types = new Set(['!', '?', '+', '*', '@']);\nconst isExtglobType = c => types.has(c);\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))';\nconst startNoDot = '(?!\\\\.)';\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.']);\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.']);\nconst reSpecials = new Set('().*{}+?[]^$\\\\!');\nconst regExpEscape = s => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// any single thing other than /\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?';\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\nvar _root = /*#__PURE__*/new WeakMap();\nvar _hasMagic2 = /*#__PURE__*/new WeakMap();\nvar _uflag = /*#__PURE__*/new WeakMap();\nvar _parts = /*#__PURE__*/new WeakMap();\nvar _parent = /*#__PURE__*/new WeakMap();\nvar _parentIndex = /*#__PURE__*/new WeakMap();\nvar _negs = /*#__PURE__*/new WeakMap();\nvar _filledNegs = /*#__PURE__*/new WeakMap();\nvar _options = /*#__PURE__*/new WeakMap();\nvar _toString = /*#__PURE__*/new WeakMap();\nvar _emptyExt = /*#__PURE__*/new WeakMap();\nvar _fillNegs = /*#__PURE__*/new WeakSet();\nvar _partsToRegExp = /*#__PURE__*/new WeakSet();\nclass AST {\n  constructor(type, parent, options = {}) {\n    _classPrivateMethodInitSpec(this, _partsToRegExp);\n    _classPrivateMethodInitSpec(this, _fillNegs);\n    _defineProperty(this, \"type\", void 0);\n    _classPrivateFieldInitSpec(this, _root, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _hasMagic2, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _uflag, {\n      writable: true,\n      value: false\n    });\n    _classPrivateFieldInitSpec(this, _parts, {\n      writable: true,\n      value: []\n    });\n    _classPrivateFieldInitSpec(this, _parent, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _parentIndex, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _negs, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _filledNegs, {\n      writable: true,\n      value: false\n    });\n    _classPrivateFieldInitSpec(this, _options, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _toString, {\n      writable: true,\n      value: void 0\n    });\n    // set to true if it's an extglob with no children\n    // (which really means one child of '')\n    _classPrivateFieldInitSpec(this, _emptyExt, {\n      writable: true,\n      value: false\n    });\n    this.type = type;\n    // extglobs are inherently magical\n    if (type) _classPrivateFieldSet(this, _hasMagic2, true);\n    _classPrivateFieldSet(this, _parent, parent);\n    _classPrivateFieldSet(this, _root, _classPrivateFieldGet(this, _parent) ? _classPrivateFieldGet(_classPrivateFieldGet(this, _parent), _root) : this);\n    _classPrivateFieldSet(this, _options, _classPrivateFieldGet(this, _root) === this ? options : _classPrivateFieldGet(_classPrivateFieldGet(this, _root), _options));\n    _classPrivateFieldSet(this, _negs, _classPrivateFieldGet(this, _root) === this ? [] : _classPrivateFieldGet(_classPrivateFieldGet(this, _root), _negs));\n    if (type === '!' && !_classPrivateFieldGet(_classPrivateFieldGet(this, _root), _filledNegs)) _classPrivateFieldGet(this, _negs).push(this);\n    _classPrivateFieldSet(this, _parentIndex, _classPrivateFieldGet(this, _parent) ? _classPrivateFieldGet(_classPrivateFieldGet(this, _parent), _parts).length : 0);\n  }\n  get hasMagic() {\n    /* c8 ignore start */\n    if (_classPrivateFieldGet(this, _hasMagic2) !== undefined) return _classPrivateFieldGet(this, _hasMagic2);\n    /* c8 ignore stop */\n    var _iterator = _createForOfIteratorHelper(_classPrivateFieldGet(this, _parts)),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        const p = _step.value;\n        if (typeof p === 'string') continue;\n        if (p.type || p.hasMagic) return _classPrivateFieldSet(this, _hasMagic2, true);\n      }\n      // note: will be undefined until we generate the regexp src and find out\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return _classPrivateFieldGet(this, _hasMagic2);\n  }\n  // reconstructs the pattern\n  toString() {\n    if (_classPrivateFieldGet(this, _toString) !== undefined) return _classPrivateFieldGet(this, _toString);\n    if (!this.type) {\n      return _classPrivateFieldSet(this, _toString, _classPrivateFieldGet(this, _parts).map(p => String(p)).join(''));\n    } else {\n      return _classPrivateFieldSet(this, _toString, this.type + '(' + _classPrivateFieldGet(this, _parts).map(p => String(p)).join('|') + ')');\n    }\n  }\n  push(...parts) {\n    for (var _i = 0, _parts2 = parts; _i < _parts2.length; _i++) {\n      const p = _parts2[_i];\n      if (p === '') continue;\n      /* c8 ignore start */\n      if (typeof p !== 'string' && !(p instanceof AST && _classPrivateFieldGet(p, _parent) === this)) {\n        throw new Error('invalid part: ' + p);\n      }\n      /* c8 ignore stop */\n      _classPrivateFieldGet(this, _parts).push(p);\n    }\n  }\n  toJSON() {\n    var _classPrivateFieldGet2;\n    const ret = this.type === null ? _classPrivateFieldGet(this, _parts).slice().map(p => typeof p === 'string' ? p : p.toJSON()) : [this.type, ..._classPrivateFieldGet(this, _parts).map(p => p.toJSON())];\n    if (this.isStart() && !this.type) ret.unshift([]);\n    if (this.isEnd() && (this === _classPrivateFieldGet(this, _root) || _classPrivateFieldGet(_classPrivateFieldGet(this, _root), _filledNegs) && ((_classPrivateFieldGet2 = _classPrivateFieldGet(this, _parent)) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.type) === '!')) {\n      ret.push({});\n    }\n    return ret;\n  }\n  isStart() {\n    var _classPrivateFieldGet3;\n    if (_classPrivateFieldGet(this, _root) === this) return true;\n    // if (this.type) return !!this.#parent?.isStart()\n    if (!((_classPrivateFieldGet3 = _classPrivateFieldGet(this, _parent)) !== null && _classPrivateFieldGet3 !== void 0 && _classPrivateFieldGet3.isStart())) return false;\n    if (_classPrivateFieldGet(this, _parentIndex) === 0) return true;\n    // if everything AHEAD of this is a negation, then it's still the \"start\"\n    const p = _classPrivateFieldGet(this, _parent);\n    for (let i = 0; i < _classPrivateFieldGet(this, _parentIndex); i++) {\n      const pp = _classPrivateFieldGet(p, _parts)[i];\n      if (!(pp instanceof AST && pp.type === '!')) {\n        return false;\n      }\n    }\n    return true;\n  }\n  isEnd() {\n    var _classPrivateFieldGet4, _classPrivateFieldGet5, _classPrivateFieldGet6;\n    if (_classPrivateFieldGet(this, _root) === this) return true;\n    if (((_classPrivateFieldGet4 = _classPrivateFieldGet(this, _parent)) === null || _classPrivateFieldGet4 === void 0 ? void 0 : _classPrivateFieldGet4.type) === '!') return true;\n    if (!((_classPrivateFieldGet5 = _classPrivateFieldGet(this, _parent)) !== null && _classPrivateFieldGet5 !== void 0 && _classPrivateFieldGet5.isEnd())) return false;\n    if (!this.type) return (_classPrivateFieldGet6 = _classPrivateFieldGet(this, _parent)) === null || _classPrivateFieldGet6 === void 0 ? void 0 : _classPrivateFieldGet6.isEnd();\n    // if not root, it'll always have a parent\n    /* c8 ignore start */\n    const pl = _classPrivateFieldGet(this, _parent) ? _classPrivateFieldGet(_classPrivateFieldGet(this, _parent), _parts).length : 0;\n    /* c8 ignore stop */\n    return _classPrivateFieldGet(this, _parentIndex) === pl - 1;\n  }\n  copyIn(part) {\n    if (typeof part === 'string') this.push(part);else this.push(part.clone(this));\n  }\n  clone(parent) {\n    const c = new AST(this.type, parent);\n    var _iterator2 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _parts)),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        const p = _step2.value;\n        c.copyIn(p);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    return c;\n  }\n  static fromGlob(pattern, options = {}) {\n    const ast = new AST(null, undefined, options);\n    _classStaticPrivateMethodGet(AST, AST, _parseAST).call(AST, pattern, ast, 0, options);\n    return ast;\n  }\n  // returns the regular expression if there's magic, or the unescaped\n  // string if not.\n  toMMPattern() {\n    // should only be called on root\n    /* c8 ignore start */\n    if (this !== _classPrivateFieldGet(this, _root)) return _classPrivateFieldGet(this, _root).toMMPattern();\n    /* c8 ignore stop */\n    const glob = this.toString();\n    const _this$toRegExpSource = this.toRegExpSource(),\n      _this$toRegExpSource2 = _slicedToArray(_this$toRegExpSource, 4),\n      re = _this$toRegExpSource2[0],\n      body = _this$toRegExpSource2[1],\n      hasMagic = _this$toRegExpSource2[2],\n      uflag = _this$toRegExpSource2[3];\n    // if we're in nocase mode, and not nocaseMagicOnly, then we do\n    // still need a regular expression if we have to case-insensitively\n    // match capital/lowercase characters.\n    const anyMagic = hasMagic || _classPrivateFieldGet(this, _hasMagic2) || _classPrivateFieldGet(this, _options).nocase && !_classPrivateFieldGet(this, _options).nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();\n    if (!anyMagic) {\n      return body;\n    }\n    const flags = (_classPrivateFieldGet(this, _options).nocase ? 'i' : '') + (uflag ? 'u' : '');\n    return Object.assign(new RegExp(`^${re}$`, flags), {\n      _src: re,\n      _glob: glob\n    });\n  }\n  // returns the string match, the regexp source, whether there's magic\n  // in the regexp (so a regular expression is required) and whether or\n  // not the uflag is needed for the regular expression (for posix classes)\n  // TODO: instead of injecting the start/end at this point, just return\n  // the BODY of the regexp, along with the start/end portions suitable\n  // for binding the start/end in either a joined full-path makeRe context\n  // (where we bind to (^|/), or a standalone matchPart context (where\n  // we bind to ^, and not /).  Otherwise slashes get duped!\n  //\n  // In part-matching mode, the start is:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n  // - if dots allowed or not possible: ^\n  // - if dots possible and not allowed: ^(?!\\.)\n  // end is:\n  // - if not isEnd(): nothing\n  // - else: $\n  //\n  // In full-path matching mode, we put the slash at the START of the\n  // pattern, so start is:\n  // - if first pattern: same as part-matching mode\n  // - if not isStart(): nothing\n  // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n  // - if dots allowed or not possible: /\n  // - if dots possible and not allowed: /(?!\\.)\n  // end is:\n  // - if last pattern, same as part-matching mode\n  // - else nothing\n  //\n  // Always put the (?:$|/) on negated tails, though, because that has to be\n  // there to bind the end of the negated pattern portion, and it's easier to\n  // just stick it in now rather than try to inject it later in the middle of\n  // the pattern.\n  //\n  // We can just always return the same end, and leave it up to the caller\n  // to know whether it's going to be used joined or in parts.\n  // And, if the start is adjusted slightly, can do the same there:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n  // - if dots allowed or not possible: (?:/|^)\n  // - if dots possible and not allowed: (?:/|^)(?!\\.)\n  //\n  // But it's better to have a simpler binding without a conditional, for\n  // performance, so probably better to return both start options.\n  //\n  // Then the caller just ignores the end if it's not the first pattern,\n  // and the start always gets applied.\n  //\n  // But that's always going to be $ if it's the ending pattern, or nothing,\n  // so the caller can just attach $ at the end of the pattern when building.\n  //\n  // So the todo is:\n  // - better detect what kind of start is needed\n  // - return both flavors of starting pattern\n  // - attach $ at the end of the pattern when creating the actual RegExp\n  //\n  // Ah, but wait, no, that all only applies to the root when the first pattern\n  // is not an extglob. If the first pattern IS an extglob, then we need all\n  // that dot prevention biz to live in the extglob portions, because eg\n  // +(*|.x*) can match .xy but not .yx.\n  //\n  // So, return the two flavors if it's #root and the first child is not an\n  // AST, otherwise leave it to the child AST to handle it, and there,\n  // use the (?:^|/) style of start binding.\n  //\n  // Even simplified further:\n  // - Since the start for a join is eg /(?!\\.) and the start for a part\n  // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n  // or start or whatever) and prepend ^ or / at the Regexp construction.\n  toRegExpSource(allowDot) {\n    const dot = allowDot !== null && allowDot !== void 0 ? allowDot : !!_classPrivateFieldGet(this, _options).dot;\n    if (_classPrivateFieldGet(this, _root) === this) _classPrivateMethodGet(this, _fillNegs, _fillNegs2).call(this);\n    if (!this.type) {\n      var _classPrivateFieldGet7;\n      const noEmpty = this.isStart() && this.isEnd();\n      const src = _classPrivateFieldGet(this, _parts).map(p => {\n        const _ref = typeof p === 'string' ? _classStaticPrivateMethodGet(AST, AST, _parseGlob).call(AST, p, _classPrivateFieldGet(this, _hasMagic2), noEmpty) : p.toRegExpSource(allowDot),\n          _ref2 = _slicedToArray(_ref, 4),\n          re = _ref2[0],\n          _ = _ref2[1],\n          hasMagic = _ref2[2],\n          uflag = _ref2[3];\n        _classPrivateFieldSet(this, _hasMagic2, _classPrivateFieldGet(this, _hasMagic2) || hasMagic);\n        _classPrivateFieldSet(this, _uflag, _classPrivateFieldGet(this, _uflag) || uflag);\n        return re;\n      }).join('');\n      let start = '';\n      if (this.isStart()) {\n        if (typeof _classPrivateFieldGet(this, _parts)[0] === 'string') {\n          // this is the string that will match the start of the pattern,\n          // so we need to protect against dots and such.\n          // '.' and '..' cannot match unless the pattern is that exactly,\n          // even if it starts with . or dot:true is set.\n          const dotTravAllowed = _classPrivateFieldGet(this, _parts).length === 1 && justDots.has(_classPrivateFieldGet(this, _parts)[0]);\n          if (!dotTravAllowed) {\n            const aps = addPatternStart;\n            // check if we have a possibility of matching . or ..,\n            // and prevent that.\n            const needNoTrav =\n            // dots are allowed, and the pattern starts with [ or .\n            dot && aps.has(src.charAt(0)) ||\n            // the pattern starts with \\., and then [ or .\n            src.startsWith('\\\\.') && aps.has(src.charAt(2)) ||\n            // the pattern starts with \\.\\., and then [ or .\n            src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4));\n            // no need to prevent dots if it can't match a dot, or if a\n            // sub-pattern will be preventing it anyway.\n            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));\n            start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';\n          }\n        }\n      }\n      // append the \"end of path portion\" pattern to negation tails\n      let end = '';\n      if (this.isEnd() && _classPrivateFieldGet(_classPrivateFieldGet(this, _root), _filledNegs) && ((_classPrivateFieldGet7 = _classPrivateFieldGet(this, _parent)) === null || _classPrivateFieldGet7 === void 0 ? void 0 : _classPrivateFieldGet7.type) === '!') {\n        end = '(?:$|\\\\/)';\n      }\n      const final = start + src + end;\n      return [final, (0, unescape_js_1.unescape)(src), _classPrivateFieldSet(this, _hasMagic2, !!_classPrivateFieldGet(this, _hasMagic2)), _classPrivateFieldGet(this, _uflag)];\n    }\n    // We need to calculate the body *twice* if it's a repeat pattern\n    // at the start, once in nodot mode, then again in dot mode, so a\n    // pattern like *(?) can match 'x.y'\n    const repeated = this.type === '*' || this.type === '+';\n    // some kind of extglob\n    const start = this.type === '!' ? '(?:(?!(?:' : '(?:';\n    let body = _classPrivateMethodGet(this, _partsToRegExp, _partsToRegExp2).call(this, dot);\n    if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n      // invalid extglob, has to at least be *something* present, if it's\n      // the entire path portion.\n      const s = this.toString();\n      _classPrivateFieldSet(this, _parts, [s]);\n      this.type = null;\n      _classPrivateFieldSet(this, _hasMagic2, undefined);\n      return [s, (0, unescape_js_1.unescape)(this.toString()), false, false];\n    }\n    // XXX abstract out this map method\n    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? '' : _classPrivateMethodGet(this, _partsToRegExp, _partsToRegExp2).call(this, true);\n    if (bodyDotAllowed === body) {\n      bodyDotAllowed = '';\n    }\n    if (bodyDotAllowed) {\n      body = `(?:${body})(?:${bodyDotAllowed})*?`;\n    }\n    // an empty !() is exactly equivalent to a starNoEmpty\n    let final = '';\n    if (this.type === '!' && _classPrivateFieldGet(this, _emptyExt)) {\n      final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;\n    } else {\n      const close = this.type === '!' ?\n      // !() must match something,but !(x) can match ''\n      '))' + (this.isStart() && !dot && !allowDot ? startNoDot : '') + star + ')' : this.type === '@' ? ')' : this.type === '?' ? ')?' : this.type === '+' && bodyDotAllowed ? ')' : this.type === '*' && bodyDotAllowed ? `)?` : `)${this.type}`;\n      final = start + body + close;\n    }\n    return [final, (0, unescape_js_1.unescape)(body), _classPrivateFieldSet(this, _hasMagic2, !!_classPrivateFieldGet(this, _hasMagic2)), _classPrivateFieldGet(this, _uflag)];\n  }\n}\n_class = AST;\nfunction _fillNegs2() {\n  /* c8 ignore start */\n  if (this !== _classPrivateFieldGet(this, _root)) throw new Error('should only call on root');\n  if (_classPrivateFieldGet(this, _filledNegs)) return this;\n  /* c8 ignore stop */\n  // call toString() once to fill this out\n  this.toString();\n  _classPrivateFieldSet(this, _filledNegs, true);\n  let n;\n  while (n = _classPrivateFieldGet(this, _negs).pop()) {\n    if (n.type !== '!') continue;\n    // walk up the tree, appending everthing that comes AFTER parentIndex\n    let p = n;\n    let pp = _classPrivateFieldGet(p, _parent);\n    while (pp) {\n      for (let i = _classPrivateFieldGet(p, _parentIndex) + 1; !pp.type && i < _classPrivateFieldGet(pp, _parts).length; i++) {\n        var _iterator3 = _createForOfIteratorHelper(_classPrivateFieldGet(n, _parts)),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            const part = _step3.value;\n            /* c8 ignore start */\n            if (typeof part === 'string') {\n              throw new Error('string part in extglob AST??');\n            }\n            /* c8 ignore stop */\n            part.copyIn(_classPrivateFieldGet(pp, _parts)[i]);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n      p = pp;\n      pp = _classPrivateFieldGet(p, _parent);\n    }\n  }\n  return this;\n}\nfunction _parseAST(str, ast, pos, opt) {\n  let escaping = false;\n  let inBrace = false;\n  let braceStart = -1;\n  let braceNeg = false;\n  if (ast.type === null) {\n    // outside of a extglob, append until we find a start\n    let i = pos;\n    let acc = '';\n    while (i < str.length) {\n      const c = str.charAt(i++);\n      // still accumulate escapes at this point, but we do ignore\n      // starts that are escaped\n      if (escaping || c === '\\\\') {\n        escaping = !escaping;\n        acc += c;\n        continue;\n      }\n      if (inBrace) {\n        if (i === braceStart + 1) {\n          if (c === '^' || c === '!') {\n            braceNeg = true;\n          }\n        } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n          inBrace = false;\n        }\n        acc += c;\n        continue;\n      } else if (c === '[') {\n        inBrace = true;\n        braceStart = i;\n        braceNeg = false;\n        acc += c;\n        continue;\n      }\n      if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n        ast.push(acc);\n        acc = '';\n        const ext = new _class(c, ast);\n        i = _classStaticPrivateMethodGet(_class, _class, _parseAST).call(_class, str, ext, i, opt);\n        ast.push(ext);\n        continue;\n      }\n      acc += c;\n    }\n    ast.push(acc);\n    return i;\n  }\n  // some kind of extglob, pos is at the (\n  // find the next | or )\n  let i = pos + 1;\n  let part = new _class(null, ast);\n  const parts = [];\n  let acc = '';\n  while (i < str.length) {\n    const c = str.charAt(i++);\n    // still accumulate escapes at this point, but we do ignore\n    // starts that are escaped\n    if (escaping || c === '\\\\') {\n      escaping = !escaping;\n      acc += c;\n      continue;\n    }\n    if (inBrace) {\n      if (i === braceStart + 1) {\n        if (c === '^' || c === '!') {\n          braceNeg = true;\n        }\n      } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n        inBrace = false;\n      }\n      acc += c;\n      continue;\n    } else if (c === '[') {\n      inBrace = true;\n      braceStart = i;\n      braceNeg = false;\n      acc += c;\n      continue;\n    }\n    if (isExtglobType(c) && str.charAt(i) === '(') {\n      part.push(acc);\n      acc = '';\n      const ext = new _class(c, part);\n      part.push(ext);\n      i = _classStaticPrivateMethodGet(_class, _class, _parseAST).call(_class, str, ext, i, opt);\n      continue;\n    }\n    if (c === '|') {\n      part.push(acc);\n      acc = '';\n      parts.push(part);\n      part = new _class(null, ast);\n      continue;\n    }\n    if (c === ')') {\n      if (acc === '' && _classPrivateFieldGet(ast, _parts).length === 0) {\n        _classPrivateFieldSet(ast, _emptyExt, true);\n      }\n      part.push(acc);\n      acc = '';\n      ast.push(...parts, part);\n      return i;\n    }\n    acc += c;\n  }\n  // unfinished extglob\n  // if we got here, it was a malformed extglob! not an extglob, but\n  // maybe something else in there.\n  ast.type = null;\n  _classPrivateFieldSet(ast, _hasMagic2, undefined);\n  _classPrivateFieldSet(ast, _parts, [str.substring(pos - 1)]);\n  return i;\n}\nfunction _partsToRegExp2(dot) {\n  return _classPrivateFieldGet(this, _parts).map(p => {\n    // extglob ASTs should only contain parent ASTs\n    /* c8 ignore start */\n    if (typeof p === 'string') {\n      throw new Error('string type in extglob ast??');\n    }\n    /* c8 ignore stop */\n    // can ignore hasMagic, because extglobs are already always magic\n    const _p$toRegExpSource = p.toRegExpSource(dot),\n      _p$toRegExpSource2 = _slicedToArray(_p$toRegExpSource, 4),\n      re = _p$toRegExpSource2[0],\n      _ = _p$toRegExpSource2[1],\n      _hasMagic = _p$toRegExpSource2[2],\n      uflag = _p$toRegExpSource2[3];\n    _classPrivateFieldSet(this, _uflag, _classPrivateFieldGet(this, _uflag) || uflag);\n    return re;\n  }).filter(p => !(this.isStart() && this.isEnd()) || !!p).join('|');\n}\nfunction _parseGlob(glob, hasMagic, noEmpty = false) {\n  let escaping = false;\n  let re = '';\n  let uflag = false;\n  for (let i = 0; i < glob.length; i++) {\n    const c = glob.charAt(i);\n    if (escaping) {\n      escaping = false;\n      re += (reSpecials.has(c) ? '\\\\' : '') + c;\n      continue;\n    }\n    if (c === '\\\\') {\n      if (i === glob.length - 1) {\n        re += '\\\\\\\\';\n      } else {\n        escaping = true;\n      }\n      continue;\n    }\n    if (c === '[') {\n      const _ref3 = (0, brace_expressions_js_1.parseClass)(glob, i),\n        _ref4 = _slicedToArray(_ref3, 4),\n        src = _ref4[0],\n        needUflag = _ref4[1],\n        consumed = _ref4[2],\n        magic = _ref4[3];\n      if (consumed) {\n        re += src;\n        uflag = uflag || needUflag;\n        i += consumed - 1;\n        hasMagic = hasMagic || magic;\n        continue;\n      }\n    }\n    if (c === '*') {\n      if (noEmpty && glob === '*') re += starNoEmpty;else re += star;\n      hasMagic = true;\n      continue;\n    }\n    if (c === '?') {\n      re += qmark;\n      hasMagic = true;\n      continue;\n    }\n    re += regExpEscape(c);\n  }\n  return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];\n}\nexports.AST = AST;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\minimatch\\dist\\cjs\\ast.js");

/***/ }),

/***/ "./node_modules/minimatch/dist/cjs/brace-expressions.js":
/*!**************************************************************!*\
  !*** ./node_modules/minimatch/dist/cjs/brace-expressions.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n// translate the various posix character classes into unicode properties\n// this works across all unicode locales\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.parseClass = void 0;\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses = {\n  '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n  '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n  '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n  '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n  '[:cntrl:]': ['\\\\p{Cc}', true],\n  '[:digit:]': ['\\\\p{Nd}', true],\n  '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n  '[:lower:]': ['\\\\p{Ll}', true],\n  '[:print:]': ['\\\\p{C}', true],\n  '[:punct:]': ['\\\\p{P}', true],\n  '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n  '[:upper:]': ['\\\\p{Lu}', true],\n  '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n  '[:xdigit:]': ['A-Fa-f0-9', false]\n};\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = s => s.replace(/[[\\]\\\\-]/g, '\\\\$&');\n// escape all regexp magic characters\nconst regexpEscape = s => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// everything has already been escaped, we just have to join\nconst rangesToString = ranges => ranges.join('');\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nconst parseClass = (glob, position) => {\n  const pos = position;\n  /* c8 ignore start */\n  if (glob.charAt(pos) !== '[') {\n    throw new Error('not in a brace expression');\n  }\n  /* c8 ignore stop */\n  const ranges = [];\n  const negs = [];\n  let i = pos + 1;\n  let sawStart = false;\n  let uflag = false;\n  let escaping = false;\n  let negate = false;\n  let endPos = pos;\n  let rangeStart = '';\n  WHILE: while (i < glob.length) {\n    const c = glob.charAt(i);\n    if ((c === '!' || c === '^') && i === pos + 1) {\n      negate = true;\n      i++;\n      continue;\n    }\n    if (c === ']' && sawStart && !escaping) {\n      endPos = i + 1;\n      break;\n    }\n    sawStart = true;\n    if (c === '\\\\') {\n      if (!escaping) {\n        escaping = true;\n        i++;\n        continue;\n      }\n      // escaped \\ char, fall through and treat like normal char\n    }\n\n    if (c === '[' && !escaping) {\n      // either a posix class, a collation equivalent, or just a [\n      for (var _i = 0, _Object$entries = Object.entries(posixClasses); _i < _Object$entries.length; _i++) {\n        const _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n          cls = _Object$entries$_i[0],\n          _Object$entries$_i$ = _slicedToArray(_Object$entries$_i[1], 3),\n          unip = _Object$entries$_i$[0],\n          u = _Object$entries$_i$[1],\n          neg = _Object$entries$_i$[2];\n        if (glob.startsWith(cls, i)) {\n          // invalid, [a-[] is fine, but not [a-[:alpha]]\n          if (rangeStart) {\n            return ['$.', false, glob.length - pos, true];\n          }\n          i += cls.length;\n          if (neg) negs.push(unip);else ranges.push(unip);\n          uflag = uflag || u;\n          continue WHILE;\n        }\n      }\n    }\n    // now it's just a normal character, effectively\n    escaping = false;\n    if (rangeStart) {\n      // throw this range away if it's not valid, but others\n      // can still match.\n      if (c > rangeStart) {\n        ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));\n      } else if (c === rangeStart) {\n        ranges.push(braceEscape(c));\n      }\n      rangeStart = '';\n      i++;\n      continue;\n    }\n    // now might be the start of a range.\n    // can be either c-d or c-] or c<more...>] or c] at this point\n    if (glob.startsWith('-]', i + 1)) {\n      ranges.push(braceEscape(c + '-'));\n      i += 2;\n      continue;\n    }\n    if (glob.startsWith('-', i + 1)) {\n      rangeStart = c;\n      i += 2;\n      continue;\n    }\n    // not the start of a range, just a single character\n    ranges.push(braceEscape(c));\n    i++;\n  }\n  if (endPos < i) {\n    // didn't see the end of the class, not a valid class,\n    // but might still be valid as a literal match.\n    return ['', false, 0, false];\n  }\n  // if we got no ranges and no negates, then we have a range that\n  // cannot possibly match anything, and that poisons the whole glob\n  if (!ranges.length && !negs.length) {\n    return ['$.', false, glob.length - pos, true];\n  }\n  // if we got one positive range, and it's a single character, then that's\n  // not actually a magic pattern, it's just that one literal character.\n  // we should not treat that as \"magic\", we should just return the literal\n  // character. [_] is a perfectly valid way to escape glob magic chars.\n  if (negs.length === 0 && ranges.length === 1 && /^\\\\?.$/.test(ranges[0]) && !negate) {\n    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];\n    return [regexpEscape(r), false, endPos - pos, false];\n  }\n  const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';\n  const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';\n  const comb = ranges.length && negs.length ? '(' + sranges + '|' + snegs + ')' : ranges.length ? sranges : snegs;\n  return [comb, uflag, endPos - pos, true];\n};\nexports.parseClass = parseClass;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\minimatch\\dist\\cjs\\brace-expressions.js");

/***/ }),

/***/ "./node_modules/minimatch/dist/cjs/escape.js":
/*!***************************************************!*\
  !*** ./node_modules/minimatch/dist/cjs/escape.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.escape = void 0;\n/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */\nconst escape = (s, {\n  windowsPathsNoEscape = false\n} = {}) => {\n  // don't need to escape +@! because we escape the parens\n  // that make those magic, and escaping ! as [!] isn't valid,\n  // because [!]] is a valid glob class meaning not ']'.\n  return windowsPathsNoEscape ? s.replace(/[?*()[\\]]/g, '[$&]') : s.replace(/[?*()[\\]\\\\]/g, '\\\\$&');\n};\nexports.escape = escape;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\minimatch\\dist\\cjs\\escape.js");

/***/ }),

/***/ "./node_modules/minimatch/dist/cjs/index.js":
/*!**************************************************!*\
  !*** ./node_modules/minimatch/dist/cjs/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar __importDefault = void 0 && (void 0).__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = void 0;\nconst brace_expansion_1 = __importDefault(__webpack_require__(/*! brace-expansion */ \"./node_modules/brace-expansion/index.js\"));\nconst assert_valid_pattern_js_1 = __webpack_require__(/*! ./assert-valid-pattern.js */ \"./node_modules/minimatch/dist/cjs/assert-valid-pattern.js\");\nconst ast_js_1 = __webpack_require__(/*! ./ast.js */ \"./node_modules/minimatch/dist/cjs/ast.js\");\nconst escape_js_1 = __webpack_require__(/*! ./escape.js */ \"./node_modules/minimatch/dist/cjs/escape.js\");\nconst unescape_js_1 = __webpack_require__(/*! ./unescape.js */ \"./node_modules/minimatch/dist/cjs/unescape.js\");\nconst minimatch = (p, pattern, options = {}) => {\n  (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false;\n  }\n  return new Minimatch(pattern, options).match(p);\n};\nexports.minimatch = minimatch;\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/;\nconst starDotExtTest = ext => f => !f.startsWith('.') && f.endsWith(ext);\nconst starDotExtTestDot = ext => f => f.endsWith(ext);\nconst starDotExtTestNocase = ext => {\n  ext = ext.toLowerCase();\n  return f => !f.startsWith('.') && f.toLowerCase().endsWith(ext);\n};\nconst starDotExtTestNocaseDot = ext => {\n  ext = ext.toLowerCase();\n  return f => f.toLowerCase().endsWith(ext);\n};\nconst starDotStarRE = /^\\*+\\.\\*+$/;\nconst starDotStarTest = f => !f.startsWith('.') && f.includes('.');\nconst starDotStarTestDot = f => f !== '.' && f !== '..' && f.includes('.');\nconst dotStarRE = /^\\.\\*+$/;\nconst dotStarTest = f => f !== '.' && f !== '..' && f.startsWith('.');\nconst starRE = /^\\*+$/;\nconst starTest = f => f.length !== 0 && !f.startsWith('.');\nconst starTestDot = f => f.length !== 0 && f !== '.' && f !== '..';\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/;\nconst qmarksTestNocase = ([$0, ext = '']) => {\n  const noext = qmarksTestNoExt([$0]);\n  if (!ext) return noext;\n  ext = ext.toLowerCase();\n  return f => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestNocaseDot = ([$0, ext = '']) => {\n  const noext = qmarksTestNoExtDot([$0]);\n  if (!ext) return noext;\n  ext = ext.toLowerCase();\n  return f => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestDot = ([$0, ext = '']) => {\n  const noext = qmarksTestNoExtDot([$0]);\n  return !ext ? noext : f => noext(f) && f.endsWith(ext);\n};\nconst qmarksTest = ([$0, ext = '']) => {\n  const noext = qmarksTestNoExt([$0]);\n  return !ext ? noext : f => noext(f) && f.endsWith(ext);\n};\nconst qmarksTestNoExt = ([$0]) => {\n  const len = $0.length;\n  return f => f.length === len && !f.startsWith('.');\n};\nconst qmarksTestNoExtDot = ([$0]) => {\n  const len = $0.length;\n  return f => f.length === len && f !== '.' && f !== '..';\n};\n/* c8 ignore start */\nconst defaultPlatform = typeof process === 'object' && process ? typeof process.env === 'object' && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : 'posix';\nconst path = {\n  win32: {\n    sep: '\\\\'\n  },\n  posix: {\n    sep: '/'\n  }\n};\n/* c8 ignore stop */\nexports.sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;\nexports.minimatch.sep = exports.sep;\nexports.GLOBSTAR = Symbol('globstar **');\nexports.minimatch.GLOBSTAR = exports.GLOBSTAR;\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?';\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?';\nconst filter = (pattern, options = {}) => p => (0, exports.minimatch)(p, pattern, options);\nexports.filter = filter;\nexports.minimatch.filter = exports.filter;\nconst ext = (a, b = {}) => Object.assign({}, a, b);\nconst defaults = def => {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return exports.minimatch;\n  }\n  const orig = exports.minimatch;\n  const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));\n  return Object.assign(m, {\n    Minimatch: class Minimatch extends orig.Minimatch {\n      constructor(pattern, options = {}) {\n        super(pattern, ext(def, options));\n      }\n      static defaults(options) {\n        return orig.defaults(ext(def, options)).Minimatch;\n      }\n    },\n    AST: class AST extends orig.AST {\n      /* c8 ignore start */\n      constructor(type, parent, options = {}) {\n        super(type, parent, ext(def, options));\n      }\n      /* c8 ignore stop */\n      static fromGlob(pattern, options = {}) {\n        return orig.AST.fromGlob(pattern, ext(def, options));\n      }\n    },\n    unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),\n    escape: (s, options = {}) => orig.escape(s, ext(def, options)),\n    filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),\n    defaults: options => orig.defaults(ext(def, options)),\n    makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),\n    braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),\n    match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),\n    sep: orig.sep,\n    GLOBSTAR: exports.GLOBSTAR\n  });\n};\nexports.defaults = defaults;\nexports.minimatch.defaults = exports.defaults;\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nconst braceExpand = (pattern, options = {}) => {\n  (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern];\n  }\n  return (0, brace_expansion_1.default)(pattern);\n};\nexports.braceExpand = braceExpand;\nexports.minimatch.braceExpand = exports.braceExpand;\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nconst makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();\nexports.makeRe = makeRe;\nexports.minimatch.makeRe = exports.makeRe;\nconst match = (list, pattern, options = {}) => {\n  const mm = new Minimatch(pattern, options);\n  list = list.filter(f => mm.match(f));\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern);\n  }\n  return list;\n};\nexports.match = match;\nexports.minimatch.match = exports.match;\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/;\nconst regExpEscape = s => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\nclass Minimatch {\n  constructor(pattern, options = {}) {\n    _defineProperty(this, \"options\", void 0);\n    _defineProperty(this, \"set\", void 0);\n    _defineProperty(this, \"pattern\", void 0);\n    _defineProperty(this, \"windowsPathsNoEscape\", void 0);\n    _defineProperty(this, \"nonegate\", void 0);\n    _defineProperty(this, \"negate\", void 0);\n    _defineProperty(this, \"comment\", void 0);\n    _defineProperty(this, \"empty\", void 0);\n    _defineProperty(this, \"preserveMultipleSlashes\", void 0);\n    _defineProperty(this, \"partial\", void 0);\n    _defineProperty(this, \"globSet\", void 0);\n    _defineProperty(this, \"globParts\", void 0);\n    _defineProperty(this, \"nocase\", void 0);\n    _defineProperty(this, \"isWindows\", void 0);\n    _defineProperty(this, \"platform\", void 0);\n    _defineProperty(this, \"windowsNoMagicRoot\", void 0);\n    _defineProperty(this, \"regexp\", void 0);\n    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n    options = options || {};\n    this.options = options;\n    this.pattern = pattern;\n    this.platform = options.platform || defaultPlatform;\n    this.isWindows = this.platform === 'win32';\n    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n    if (this.windowsPathsNoEscape) {\n      this.pattern = this.pattern.replace(/\\\\/g, '/');\n    }\n    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;\n    this.regexp = null;\n    this.negate = false;\n    this.nonegate = !!options.nonegate;\n    this.comment = false;\n    this.empty = false;\n    this.partial = !!options.partial;\n    this.nocase = !!this.options.nocase;\n    this.windowsNoMagicRoot = options.windowsNoMagicRoot !== undefined ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);\n    this.globSet = [];\n    this.globParts = [];\n    this.set = [];\n    // make the set of regexps etc.\n    this.make();\n  }\n  hasMagic() {\n    if (this.options.magicalBraces && this.set.length > 1) {\n      return true;\n    }\n    var _iterator = _createForOfIteratorHelper(this.set),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        const pattern = _step.value;\n        var _iterator2 = _createForOfIteratorHelper(pattern),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            const part = _step2.value;\n            if (typeof part !== 'string') return true;\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return false;\n  }\n  debug(..._) {}\n  make() {\n    const pattern = this.pattern;\n    const options = this.options;\n    // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n      this.comment = true;\n      return;\n    }\n    if (!pattern) {\n      this.empty = true;\n      return;\n    }\n    // step 1: figure out negation, etc.\n    this.parseNegate();\n    // step 2: expand braces\n    this.globSet = [...new Set(this.braceExpand())];\n    if (options.debug) {\n      this.debug = (...args) => console.error(...args);\n    }\n    this.debug(this.pattern, this.globSet);\n    // step 3: now we have a set, so turn each one into a series of\n    // path-portion matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n    //\n    // First, we preprocess to make the glob pattern sets a bit simpler\n    // and deduped.  There are some perf-killing patterns that can cause\n    // problems with a glob walk, but we can simplify them down a bit.\n    const rawGlobParts = this.globSet.map(s => this.slashSplit(s));\n    this.globParts = this.preprocess(rawGlobParts);\n    this.debug(this.pattern, this.globParts);\n    // glob --> regexps\n    let set = this.globParts.map((s, _, __) => {\n      if (this.isWindows && this.windowsNoMagicRoot) {\n        // check if it's a drive or unc path.\n        const isUNC = s[0] === '' && s[1] === '' && (s[2] === '?' || !globMagic.test(s[2])) && !globMagic.test(s[3]);\n        const isDrive = /^[a-z]:/i.test(s[0]);\n        if (isUNC) {\n          return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];\n        } else if (isDrive) {\n          return [s[0], ...s.slice(1).map(ss => this.parse(ss))];\n        }\n      }\n      return s.map(ss => this.parse(ss));\n    });\n    this.debug(this.pattern, set);\n    // filter out everything that didn't compile properly.\n    this.set = set.filter(s => s.indexOf(false) === -1);\n    // do not treat the ? in UNC paths as magic\n    if (this.isWindows) {\n      for (let i = 0; i < this.set.length; i++) {\n        const p = this.set[i];\n        if (p[0] === '' && p[1] === '' && this.globParts[i][2] === '?' && typeof p[3] === 'string' && /^[a-z]:$/i.test(p[3])) {\n          p[2] = '?';\n        }\n      }\n    }\n    this.debug(this.pattern, this.set);\n  }\n  // various transforms to equivalent pattern sets that are\n  // faster to process in a filesystem walk.  The goal is to\n  // eliminate what we can, and push all ** patterns as far\n  // to the right as possible, even if it increases the number\n  // of patterns that we have to process.\n  preprocess(globParts) {\n    // if we're not in globstar mode, then turn all ** into *\n    if (this.options.noglobstar) {\n      for (let i = 0; i < globParts.length; i++) {\n        for (let j = 0; j < globParts[i].length; j++) {\n          if (globParts[i][j] === '**') {\n            globParts[i][j] = '*';\n          }\n        }\n      }\n    }\n    const _this$options$optimiz = this.options.optimizationLevel,\n      optimizationLevel = _this$options$optimiz === void 0 ? 1 : _this$options$optimiz;\n    if (optimizationLevel >= 2) {\n      // aggressive optimization for the purpose of fs walking\n      globParts = this.firstPhasePreProcess(globParts);\n      globParts = this.secondPhasePreProcess(globParts);\n    } else if (optimizationLevel >= 1) {\n      // just basic optimizations to remove some .. parts\n      globParts = this.levelOneOptimize(globParts);\n    } else {\n      globParts = this.adjascentGlobstarOptimize(globParts);\n    }\n    return globParts;\n  }\n  // just get rid of adjascent ** portions\n  adjascentGlobstarOptimize(globParts) {\n    return globParts.map(parts => {\n      let gs = -1;\n      while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n        let i = gs;\n        while (parts[i + 1] === '**') {\n          i++;\n        }\n        if (i !== gs) {\n          parts.splice(gs, i - gs);\n        }\n      }\n      return parts;\n    });\n  }\n  // get rid of adjascent ** and resolve .. portions\n  levelOneOptimize(globParts) {\n    return globParts.map(parts => {\n      parts = parts.reduce((set, part) => {\n        const prev = set[set.length - 1];\n        if (part === '**' && prev === '**') {\n          return set;\n        }\n        if (part === '..') {\n          if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n            set.pop();\n            return set;\n          }\n        }\n        set.push(part);\n        return set;\n      }, []);\n      return parts.length === 0 ? [''] : parts;\n    });\n  }\n  levelTwoFileOptimize(parts) {\n    if (!Array.isArray(parts)) {\n      parts = this.slashSplit(parts);\n    }\n    let didSomething = false;\n    do {\n      didSomething = false;\n      // <pre>/<e>/<rest> -> <pre>/<rest>\n      if (!this.preserveMultipleSlashes) {\n        for (let i = 1; i < parts.length - 1; i++) {\n          const p = parts[i];\n          // don't squeeze out UNC patterns\n          if (i === 1 && p === '' && parts[0] === '') continue;\n          if (p === '.' || p === '') {\n            didSomething = true;\n            parts.splice(i, 1);\n            i--;\n          }\n        }\n        if (parts[0] === '.' && parts.length === 2 && (parts[1] === '.' || parts[1] === '')) {\n          didSomething = true;\n          parts.pop();\n        }\n      }\n      // <pre>/<p>/../<rest> -> <pre>/<rest>\n      let dd = 0;\n      while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n        const p = parts[dd - 1];\n        if (p && p !== '.' && p !== '..' && p !== '**') {\n          didSomething = true;\n          parts.splice(dd - 1, 2);\n          dd -= 2;\n        }\n      }\n    } while (didSomething);\n    return parts.length === 0 ? [''] : parts;\n  }\n  // First phase: single-pattern processing\n  // <pre> is 1 or more portions\n  // <rest> is 1 or more portions\n  // <p> is any portion other than ., .., '', or **\n  // <e> is . or ''\n  //\n  // **/.. is *brutal* for filesystem walking performance, because\n  // it effectively resets the recursive walk each time it occurs,\n  // and ** cannot be reduced out by a .. pattern part like a regexp\n  // or most strings (other than .., ., and '') can be.\n  //\n  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n  // <pre>/<e>/<rest> -> <pre>/<rest>\n  // <pre>/<p>/../<rest> -> <pre>/<rest>\n  // **/**/<rest> -> **/<rest>\n  //\n  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n  // this WOULD be allowed if ** did follow symlinks, or * didn't\n  firstPhasePreProcess(globParts) {\n    let didSomething = false;\n    do {\n      didSomething = false;\n      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n      var _iterator3 = _createForOfIteratorHelper(globParts),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          let parts = _step3.value;\n          let gs = -1;\n          while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n            let gss = gs;\n            while (parts[gss + 1] === '**') {\n              // <pre>/**/**/<rest> -> <pre>/**/<rest>\n              gss++;\n            }\n            // eg, if gs is 2 and gss is 4, that means we have 3 **\n            // parts, and can remove 2 of them.\n            if (gss > gs) {\n              parts.splice(gs + 1, gss - gs);\n            }\n            let next = parts[gs + 1];\n            const p = parts[gs + 2];\n            const p2 = parts[gs + 3];\n            if (next !== '..') continue;\n            if (!p || p === '.' || p === '..' || !p2 || p2 === '.' || p2 === '..') {\n              continue;\n            }\n            didSomething = true;\n            // edit parts in place, and push the new one\n            parts.splice(gs, 1);\n            const other = parts.slice(0);\n            other[gs] = '**';\n            globParts.push(other);\n            gs--;\n          }\n          // <pre>/<e>/<rest> -> <pre>/<rest>\n          if (!this.preserveMultipleSlashes) {\n            for (let i = 1; i < parts.length - 1; i++) {\n              const p = parts[i];\n              // don't squeeze out UNC patterns\n              if (i === 1 && p === '' && parts[0] === '') continue;\n              if (p === '.' || p === '') {\n                didSomething = true;\n                parts.splice(i, 1);\n                i--;\n              }\n            }\n            if (parts[0] === '.' && parts.length === 2 && (parts[1] === '.' || parts[1] === '')) {\n              didSomething = true;\n              parts.pop();\n            }\n          }\n          // <pre>/<p>/../<rest> -> <pre>/<rest>\n          let dd = 0;\n          while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n            const p = parts[dd - 1];\n            if (p && p !== '.' && p !== '..' && p !== '**') {\n              didSomething = true;\n              const needDot = dd === 1 && parts[dd + 1] === '**';\n              const splin = needDot ? ['.'] : [];\n              parts.splice(dd - 1, 2, ...splin);\n              if (parts.length === 0) parts.push('');\n              dd -= 2;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    } while (didSomething);\n    return globParts;\n  }\n  // second phase: multi-pattern dedupes\n  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n  //\n  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n  // ^-- not valid because ** doens't follow symlinks\n  secondPhasePreProcess(globParts) {\n    for (let i = 0; i < globParts.length - 1; i++) {\n      for (let j = i + 1; j < globParts.length; j++) {\n        const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);\n        if (!matched) continue;\n        globParts[i] = matched;\n        globParts[j] = [];\n      }\n    }\n    return globParts.filter(gs => gs.length);\n  }\n  partsMatch(a, b, emptyGSMatch = false) {\n    let ai = 0;\n    let bi = 0;\n    let result = [];\n    let which = '';\n    while (ai < a.length && bi < b.length) {\n      if (a[ai] === b[bi]) {\n        result.push(which === 'b' ? b[bi] : a[ai]);\n        ai++;\n        bi++;\n      } else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n        result.push(a[ai]);\n        ai++;\n      } else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n        result.push(b[bi]);\n        bi++;\n      } else if (a[ai] === '*' && b[bi] && (this.options.dot || !b[bi].startsWith('.')) && b[bi] !== '**') {\n        if (which === 'b') return false;\n        which = 'a';\n        result.push(a[ai]);\n        ai++;\n        bi++;\n      } else if (b[bi] === '*' && a[ai] && (this.options.dot || !a[ai].startsWith('.')) && a[ai] !== '**') {\n        if (which === 'a') return false;\n        which = 'b';\n        result.push(b[bi]);\n        ai++;\n        bi++;\n      } else {\n        return false;\n      }\n    }\n    // if we fall out of the loop, it means they two are identical\n    // as long as their lengths match\n    return a.length === b.length && result;\n  }\n  parseNegate() {\n    if (this.nonegate) return;\n    const pattern = this.pattern;\n    let negate = false;\n    let negateOffset = 0;\n    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n      negate = !negate;\n      negateOffset++;\n    }\n    if (negateOffset) this.pattern = pattern.slice(negateOffset);\n    this.negate = negate;\n  }\n  // set partial to true to test if, for example,\n  // \"/a/b\" matches the start of \"/*/b/*/d\"\n  // Partial means, if you run out of file before you run\n  // out of pattern, then that's fine, as long as all\n  // the parts match.\n  matchOne(file, pattern, partial = false) {\n    const options = this.options;\n    // UNC paths like //?/X:/... can match X:/... and vice versa\n    // Drive letters in absolute drive or unc paths are always compared\n    // case-insensitively.\n    if (this.isWindows) {\n      const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);\n      const fileUNC = !fileDrive && file[0] === '' && file[1] === '' && file[2] === '?' && /^[a-z]:$/i.test(file[3]);\n      const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);\n      const patternUNC = !patternDrive && pattern[0] === '' && pattern[1] === '' && pattern[2] === '?' && typeof pattern[3] === 'string' && /^[a-z]:$/i.test(pattern[3]);\n      const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;\n      const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;\n      if (typeof fdi === 'number' && typeof pdi === 'number') {\n        const _ref = [file[fdi], pattern[pdi]],\n          fd = _ref[0],\n          pd = _ref[1];\n        if (fd.toLowerCase() === pd.toLowerCase()) {\n          pattern[pdi] = fd;\n          if (pdi > fdi) {\n            pattern = pattern.slice(pdi);\n          } else if (fdi > pdi) {\n            file = file.slice(fdi);\n          }\n        }\n      }\n    }\n    // resolve and reduce . and .. portions in the file as well.\n    // dont' need to do the second phase, because it's only one string[]\n    const _this$options$optimiz2 = this.options.optimizationLevel,\n      optimizationLevel = _this$options$optimiz2 === void 0 ? 1 : _this$options$optimiz2;\n    if (optimizationLevel >= 2) {\n      file = this.levelTwoFileOptimize(file);\n    }\n    this.debug('matchOne', this, {\n      file,\n      pattern\n    });\n    this.debug('matchOne', file.length, pattern.length);\n    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n      this.debug('matchOne loop');\n      var p = pattern[pi];\n      var f = file[fi];\n      this.debug(pattern, p, f);\n      // should be impossible.\n      // some invalid regexp stuff in the set.\n      /* c8 ignore start */\n      if (p === false) {\n        return false;\n      }\n      /* c8 ignore stop */\n      if (p === exports.GLOBSTAR) {\n        this.debug('GLOBSTAR', [pattern, p, f]);\n        // \"**\"\n        // a/**/b/**/c would match the following:\n        // a/b/x/y/z/c\n        // a/x/y/z/b/c\n        // a/b/x/b/x/c\n        // a/b/c\n        // To do this, take the rest of the pattern after\n        // the **, and see if it would match the file remainder.\n        // If so, return success.\n        // If not, the ** \"swallows\" a segment, and try again.\n        // This is recursively awful.\n        //\n        // a/**/b/**/c matching a/b/x/y/z/c\n        // - a matches a\n        // - doublestar\n        //   - matchOne(b/x/y/z/c, b/**/c)\n        //     - b matches b\n        //     - doublestar\n        //       - matchOne(x/y/z/c, c) -> no\n        //       - matchOne(y/z/c, c) -> no\n        //       - matchOne(z/c, c) -> no\n        //       - matchOne(c, c) yes, hit\n        var fr = fi;\n        var pr = pi + 1;\n        if (pr === pl) {\n          this.debug('** at the end');\n          // a ** at the end will just swallow the rest.\n          // We have found a match.\n          // however, it will not swallow /.x, unless\n          // options.dot is set.\n          // . and .. are *never* matched by **, for explosively\n          // exponential reasons.\n          for (; fi < fl; fi++) {\n            if (file[fi] === '.' || file[fi] === '..' || !options.dot && file[fi].charAt(0) === '.') return false;\n          }\n          return true;\n        }\n        // ok, let's see if we can swallow whatever we can.\n        while (fr < fl) {\n          var swallowee = file[fr];\n          this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee);\n          // XXX remove this slice.  Just pass the start index.\n          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n            this.debug('globstar found match!', fr, fl, swallowee);\n            // found a match.\n            return true;\n          } else {\n            // can't swallow \".\" or \"..\" ever.\n            // can only swallow \".foo\" when explicitly asked.\n            if (swallowee === '.' || swallowee === '..' || !options.dot && swallowee.charAt(0) === '.') {\n              this.debug('dot detected!', file, fr, pattern, pr);\n              break;\n            }\n            // ** swallows a segment, and continue.\n            this.debug('globstar swallow a segment, and continue');\n            fr++;\n          }\n        }\n        // no match was found.\n        // However, in partial mode, we can't say this is necessarily over.\n        /* c8 ignore start */\n        if (partial) {\n          // ran out of file\n          this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n          if (fr === fl) {\n            return true;\n          }\n        }\n        /* c8 ignore stop */\n        return false;\n      }\n      // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n      let hit;\n      if (typeof p === 'string') {\n        hit = f === p;\n        this.debug('string match', p, f, hit);\n      } else {\n        hit = p.test(f);\n        this.debug('pattern match', p, f, hit);\n      }\n      if (!hit) return false;\n    }\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true;\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial;\n    } else if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      return fi === fl - 1 && file[fi] === '';\n      /* c8 ignore start */\n    } else {\n      // should be unreachable.\n      throw new Error('wtf?');\n    }\n    /* c8 ignore stop */\n  }\n\n  braceExpand() {\n    return (0, exports.braceExpand)(this.pattern, this.options);\n  }\n  parse(pattern) {\n    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n    const options = this.options;\n    // shortcuts\n    if (pattern === '**') return exports.GLOBSTAR;\n    if (pattern === '') return '';\n    // far and away, the most common glob pattern parts are\n    // *, *.*, and *.<ext>  Add a fast check method for those.\n    let m;\n    let fastTest = null;\n    if (m = pattern.match(starRE)) {\n      fastTest = options.dot ? starTestDot : starTest;\n    } else if (m = pattern.match(starDotExtRE)) {\n      fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);\n    } else if (m = pattern.match(qmarksRE)) {\n      fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);\n    } else if (m = pattern.match(starDotStarRE)) {\n      fastTest = options.dot ? starDotStarTestDot : starDotStarTest;\n    } else if (m = pattern.match(dotStarRE)) {\n      fastTest = dotStarTest;\n    }\n    const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();\n    return fastTest ? Object.assign(re, {\n      test: fastTest\n    }) : re;\n  }\n  makeRe() {\n    if (this.regexp || this.regexp === false) return this.regexp;\n    // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n    const set = this.set;\n    if (!set.length) {\n      this.regexp = false;\n      return this.regexp;\n    }\n    const options = this.options;\n    const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;\n    const flags = new Set(options.nocase ? ['i'] : []);\n    // regexpify non-globstar patterns\n    // if ** is only item, then we just do one twoStar\n    // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n    // if ** is last, append (\\/twoStar|) to previous\n    // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n    // then filter out GLOBSTAR symbols\n    let re = set.map(pattern => {\n      const pp = pattern.map(p => {\n        if (p instanceof RegExp) {\n          var _iterator4 = _createForOfIteratorHelper(p.flags.split('')),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              const f = _step4.value;\n              flags.add(f);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n        return typeof p === 'string' ? regExpEscape(p) : p === exports.GLOBSTAR ? exports.GLOBSTAR : p._src;\n      });\n      pp.forEach((p, i) => {\n        const next = pp[i + 1];\n        const prev = pp[i - 1];\n        if (p !== exports.GLOBSTAR || prev === exports.GLOBSTAR) {\n          return;\n        }\n        if (prev === undefined) {\n          if (next !== undefined && next !== exports.GLOBSTAR) {\n            pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next;\n          } else {\n            pp[i] = twoStar;\n          }\n        } else if (next === undefined) {\n          pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?';\n        } else if (next !== exports.GLOBSTAR) {\n          pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next;\n          pp[i + 1] = exports.GLOBSTAR;\n        }\n      });\n      return pp.filter(p => p !== exports.GLOBSTAR).join('/');\n    }).join('|');\n    // need to wrap in parens if we had more than one thing with |,\n    // otherwise only the first will be anchored to ^ and the last to $\n    const _ref2 = set.length > 1 ? ['(?:', ')'] : ['', ''],\n      _ref3 = _slicedToArray(_ref2, 2),\n      open = _ref3[0],\n      close = _ref3[1];\n    // must match entire pattern\n    // ending in a * or ** will make it less strict.\n    re = '^' + open + re + close + '$';\n    // can match anything, as long as it's not this.\n    if (this.negate) re = '^(?!' + re + ').+$';\n    try {\n      this.regexp = new RegExp(re, [...flags].join(''));\n      /* c8 ignore start */\n    } catch (ex) {\n      // should be impossible\n      this.regexp = false;\n    }\n    /* c8 ignore stop */\n    return this.regexp;\n  }\n  slashSplit(p) {\n    // if p starts with // on windows, we preserve that\n    // so that UNC paths aren't broken.  Otherwise, any number of\n    // / characters are coalesced into one, unless\n    // preserveMultipleSlashes is set to true.\n    if (this.preserveMultipleSlashes) {\n      return p.split('/');\n    } else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n      // add an extra '' for the one we lose\n      return ['', ...p.split(/\\/+/)];\n    } else {\n      return p.split(/\\/+/);\n    }\n  }\n  match(f, partial = this.partial) {\n    this.debug('match', f, this.pattern);\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) {\n      return false;\n    }\n    if (this.empty) {\n      return f === '';\n    }\n    if (f === '/' && partial) {\n      return true;\n    }\n    const options = this.options;\n    // windows: need to use /, not \\\n    if (this.isWindows) {\n      f = f.split('\\\\').join('/');\n    }\n    // treat the test path as a set of pathparts.\n    const ff = this.slashSplit(f);\n    this.debug(this.pattern, 'split', ff);\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n    const set = this.set;\n    this.debug(this.pattern, 'set', set);\n    // Find the basename of the path by looking for the last non-empty segment\n    let filename = ff[ff.length - 1];\n    if (!filename) {\n      for (let i = ff.length - 2; !filename && i >= 0; i--) {\n        filename = ff[i];\n      }\n    }\n    for (let i = 0; i < set.length; i++) {\n      const pattern = set[i];\n      let file = ff;\n      if (options.matchBase && pattern.length === 1) {\n        file = [filename];\n      }\n      const hit = this.matchOne(file, pattern, partial);\n      if (hit) {\n        if (options.flipNegate) {\n          return true;\n        }\n        return !this.negate;\n      }\n    }\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) {\n      return false;\n    }\n    return this.negate;\n  }\n  static defaults(def) {\n    return exports.minimatch.defaults(def).Minimatch;\n  }\n}\nexports.Minimatch = Minimatch;\n/* c8 ignore start */\nvar ast_js_2 = __webpack_require__(/*! ./ast.js */ \"./node_modules/minimatch/dist/cjs/ast.js\");\nObject.defineProperty(exports, \"AST\", ({\n  enumerable: true,\n  get: function get() {\n    return ast_js_2.AST;\n  }\n}));\nvar escape_js_2 = __webpack_require__(/*! ./escape.js */ \"./node_modules/minimatch/dist/cjs/escape.js\");\nObject.defineProperty(exports, \"escape\", ({\n  enumerable: true,\n  get: function get() {\n    return escape_js_2.escape;\n  }\n}));\nvar unescape_js_2 = __webpack_require__(/*! ./unescape.js */ \"./node_modules/minimatch/dist/cjs/unescape.js\");\nObject.defineProperty(exports, \"unescape\", ({\n  enumerable: true,\n  get: function get() {\n    return unescape_js_2.unescape;\n  }\n}));\n/* c8 ignore stop */\nexports.minimatch.AST = ast_js_1.AST;\nexports.minimatch.Minimatch = Minimatch;\nexports.minimatch.escape = escape_js_1.escape;\nexports.minimatch.unescape = unescape_js_1.unescape;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\minimatch\\dist\\cjs\\index.js");

/***/ }),

/***/ "./node_modules/minimatch/dist/cjs/unescape.js":
/*!*****************************************************!*\
  !*** ./node_modules/minimatch/dist/cjs/unescape.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.unescape = void 0;\n/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */\nconst unescape = (s, {\n  windowsPathsNoEscape = false\n} = {}) => {\n  return windowsPathsNoEscape ? s.replace(/\\[([^\\/\\\\])\\]/g, '$1') : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, '$1$2').replace(/\\\\([^\\/])/g, '$1');\n};\nexports.unescape = unescape;\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\node_modules\\minimatch\\dist\\cjs\\unescape.js");

/***/ }),

/***/ "./vss-extension.json":
/*!****************************!*\
  !*** ./vss-extension.json ***!
  \****************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"manifestVersion\":1,\"id\":\"sw-benchmarker\",\"version\":\"0.0.39\",\"public\":false,\"publisher\":\"frederic-kpama\",\"name\":\"Benchmarker Extension\",\"description\":\"A sample Visual Studio Services extension\",\"categories\":[\"Azure Pipelines\"],\"scopes\":[\"vso.extension.data_write\",\"vso.features_write\"],\"targets\":[{\"id\":\"Microsoft.VisualStudio.Services\"}],\"contributions\":[{\"id\":\"benchmark-report-available-feature\",\"type\":\"ms.vss-web.feature\",\"description\":\"Show the new ABC hub in the Pipelines hub group\",\"targets\":[\"ms.vss-web.managed-features\",\"ms.vss-web.managed-features-onprem\"],\"properties\":{\"name\":\"Benchmarks\",\"userConfigurable\":true,\"hostConfigurable\":false,\"visible\":false}},{\"id\":\"benchmarker.benchmarks-details-tab\",\"type\":\"ms.vss-web.action\",\"description\":\"Benchmark Detail tab\",\"targets\":[\"ms.vss-test-web.test-results-actions-menu\"],\"properties\":{\"text\":\"Benchmarks\",\"group\":\"actions\",\"order\":100,\"title\":\"Benchmarks\",\"name\":\"Benchmarks\",\"uri\":\"storage.html\",\"icon\":\"show-properties.png\",\"registeredObjectId\":\"openBenchmarks\"}},{\"id\":\"test-benchmark-detail-tab\",\"description\":\"Tab Description\",\"type\":\"ms.vss-build-web.build-results-tab\",\"targets\":[\"ms.vss-build-web.build-results-view\"],\"properties\":{\"uri\":\"benchmarks-build-summary-tab.html\",\"name\":\"Benchmarks\",\"dynamic\":true,\"supportsTasks\":[\"5557b64a-8c04-4a07-abeb-343ef9ab5870\"]},\"constraints\":[{\"name\":\"Feature\",\"properties\":{\"featureId\":\"frederic-kpama.sw-benchmarker.benchmark-report-available-feature\"}}]},{\"id\":\"benchmarks-queryparams-subscription\",\"type\":\"ms.vss-web.event-subscription\",\"targets\":[\"ms.vss-web.tfs-website\"],\"properties\":{\"eventName\":\"page-interactive\",\"command\":{\"uri\":\"query-params-service.html\",\"serviceName\":\"SwQueryParamsService\",\"methodName\":\"handleQueryParams\"}},\"constraints\":[{\"name\":\"QueryParameters\",\"inverse\":true,\"properties\":{\"filters\":{\"buildId\":\"\"}}}]},{\"id\":\"abcfef-build-status-section\",\"type\":\"ms.vss-build-web.build-results-section\",\"description\":\"ABC Scan Summary\",\"targets\":[\"ms.vss-build-web.build-results-summary-tab\"],\"properties\":{\"name\":\"ABC Summary Section\",\"uri\":\"storage.html\",\"order\":20,\"height\":500}}],\"files\":[{\"path\":\"dist\",\"addressable\":true,\"packagePath\":\"/\"},{\"path\":\"assets\",\"addressable\":true,\"packagePath\":\"/\"},{\"path\":\"node_modules/azure-devops-extension-sdk/SDK.min.js\",\"addressable\":true,\"packagePath\":\"lib/SDK.min.js\"}]}');\n\n//# sourceURL=F:\\Sources\\Sodiware\\DevToolsProject\\SwBenchmark\\src\\DevOps\\Extension\\vss-extension.json");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__(__webpack_require__.s = "./src/tasks/publish-benchmark-reports/publish-benchmark-reports.ts");
/******/ 	
/******/ })()
;