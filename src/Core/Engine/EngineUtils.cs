using BenchmarkDotNet.Loggers;

namespace Benchmarker
{
    internal static class EngineUtils
    {
        internal static bool IsStepNotification(LogKind logKind, string text)
            => logKind == LogKind.Default
            && (text.StartsWithO("// AfterAll "));

        internal static bool IsNoExporterDefined(LogKind logKind, string text)
            => logKind == LogKind.Error
            && text.EqualsOrd("//    * No exporters defined, results will not be persisted.");

        internal static bool IsStackTraceLine(string text)
            => text.StartsWithO(" at ")
            || text.EqualsOrd("--- End of inner exception stack trace ---");

        internal static bool IsTargetInvocationException(this string str)
            => str.StartsWithO("System.Reflection.TargetInvocationException: ");

        internal static bool IsTargetInvocationException(LogKind logKind, string text)
            => (logKind == LogKind.Default || logKind == LogKind.Error)
            && IsTargetInvocationException(text);

        internal static string SanitizeStackTrace(string text)
        {
#if DEBUG
            if (Directory.Exists(@"C:\Temp"))
                File.AppendAllText(@"C:\Temp\exception.txt", text);
#endif
            var lines = text.Split(new[] { '\n' }, StringSplitOptions.RemoveEmptyEntries);
            return SanitizeStackTrace(lines);
        }
        internal static string SanitizeStackTrace(IEnumerable<string> lines)
        {
            var innerStackTraceText = lines.FirstOrDefault(x => x.TrimStart().StartsWithO("--- "));
            if (innerStackTraceText is null)
                return string.Join("\n", lines);
            var groups = splitStackTrace(lines, innerStackTraceText);
            List<string> result = new();
            foreach(var group in groups)
            {
                if (sanitizeException(group))
                    result.AddRange(group);
            }
            if (result.Count == 0)
            {
                // nothing? unlikely so return the raw output
                return string.Join("\n", lines);
            }
            if (IsTargetInvocationException(result[0]))
                result.RemoveAt(0);
            return string.Join("\n", result).TrimEnd();
        }

        private static bool sanitizeException(List<string> group)
        {
            for(; group.Count > 0; )
            {
                bool bdotnetFound = false;
                var current = group[group.Count - 1];
                if ((!bdotnetFound && (current.StartsWithO("   at System.Reflection.")
                    || current.StartsWithO("   at System.RuntimeMethodHandle.")))
                    || (bdotnetFound |= current.StartsWithO("   at BenchmarkDotNet.")))
                    group.RemoveAt(group.Count - 1);
                else
                    break;
            }

            return group.Count > 0;
        }

        // Generated by ChatGPT. Maybe not optim or bug, don't care for now
        static List<List<string>> splitStackTrace(IEnumerable<string> strings, string prefix)
        {

            List<List<string>> all = new();

            foreach(var x in doSplit(strings, x => x.StartsWithO(" ---> "), true))
            {
                all.AddRange(doSplit(x, s => s.StartsWithO(prefix), false));
            }
            return all;
            static List<List<string>> doSplit(IEnumerable<string> strings, Predicate<string> s, bool addMatching)
            {
                List<List<string>> result = new();
                List<string> currentArray = new();

                foreach (string line in strings)
                {
                    if (s(line))
                    {
                        if (currentArray.Count > 0)
                        {
                            result.Add(currentArray);
                            currentArray = new();
                        }
                        if (addMatching)
                            currentArray.Add(line);
                    }
                    else
                    {
                        currentArray.Add(line);
                    }
                }

                if (currentArray.Count > 0)
                {
                    result.Add(currentArray);
                }

                return result;
            }

        }
    }
}
